# TIPOVI CODE SPLITTING-A

ZASTO JE OVO USTVARI, IMPORTANT?

PA ZATO STO:

## FUTURE OF WEB IS MOBILE

DANAS, AVERAGE MOBILE SITE-U, JE POTREBN O14 SEKUNDI DA POSTANE INTERAKTIVAN

STO MANJE CODE-A SHIPP-UJEM, ZNACI DA SAJT MOZE BRZE POSTATI INTERAKTIVAN

## DINAMICKI IMPORT (import()) (RAZLIKA IZMEDJU import(), U SPECIFIKACIJAM I ONOG import() IZ WEBPACK-A, POSTOJI)

**DAKLE POMENUTA DVA import() NISU ISTO**

VEC SAM GOVORIO O POMENUTOM, DINAMICKOM IMPORT-U, IZ WEBPACK-A

KADA TRAZIM POMENUTI DYNAMIC imprt(), ONO STO CE NA PRIMER U canuise-U IZACI JESTE ONAJ DINAMICKI IMPORT, KOJI SE TICE BROWSER LAND-A, ODNOSNO ZVANICNIH SPECIFIKACIJA

[caniuse](https://caniuse.com/#search=dynamic%20import) (KADA SAM PISAO OVO EDGE I FIREFOX NISU IMALI PODRSKU ZA OVO)

ON JE DEO STAGE 3 [whatwg/loader SPECIFIKACIJA](https://whatwg.github.io/loader/)

NA TOJ STRANICI SAM GA PRONSAO ZAVEDENIM, U OKVIRU NASLOVA "**9. Local loading**", ZATIM "**3.3.2. Loader.prototype.import(name[, referrer])**"

**[OVDE](https://tc39.github.io/proposal-dynamic-import/) SAM NASO DA JE PROPOSED**

SADA DA KAZEM *KAKAV JE TAJ DINAMICKI IMPORT IZ SPECIFIKACIJA*

U BROWSER LAND-U, POMENUTI IMPORT SLUZI DA SE DINAMICKI FETCH-UJE AT RUNTIME, BILO KOJI KOMAD JAVASCRIPT-A, KOJI SE ONDA KORISTI KAO MODUL

U TOM POGLEDU POSTOJI MNOGO CONSTRAINTS:

- NISTA STO RADIM DINAMICKI SE NE MOZE OPTIMIZOVATI

- POSTOJE NEKI SECURITY CONCERNS

- NO COMPLETE BROWSER INTEROP, U POGLEDU SINTAKSE

## WEBPACK-OV DYNAMIC import()

PRE Webpack-A 3.0, JEDINI NACIN DA DOVEDEM CODE SPLITTING, BIO JE KORISCENJE: &nbsp;&nbsp;&nbsp;&nbsp; **require.ensure()**

ALI NIJE BROWSER SPECIFIKACIJA, TAK ODA SU GA SE OTARASILI

## TREBAM DA ZAPAMTIM DA JE OVO DYNAMIC IMPORT: import()

OVO KAZEM IZ TERMINOLOSKIH RAZLOGA, JER KORISTICU JOS NEKE TERMINE KAO STO SU **DYNAMIC I STATIC CODE SPLITTING**

**NEMOJ DA CONFUSE-UJES POMENUTE TERMINE** (MISLIM NA UPOTREBU TERMINA *DYNAMIC IMPORT* I *DYNAMIC CODE SPLITTING*)

## KONACNO DA KAZEM O TIPOVIMA CODE SPLITTING-A

- STATIC

- "DYNAMIC" (POD NAVODNICIMA) (LARKIN KAZE DA SU OVO SUPER HEAVY QUOTES)

ON TO KAZE JER NE POSTOJI NISTA U WEBPACK-U, STO JE PURELY DYNAMIC (JER SVE STO RADIM, JA RADIM AT BUILD TIME)

*LJUDI LARKINU POSTAVLJAJU PITANJE: DALI MOGU URADITI NESTO OVAKO:*  **import(nekaVarijabla)**

**TO SE NE MOZE URADITI, I TO NIAKADA NECE BITI SUPPORTED, JER JE TO ANTI PATTERN, I KREATORI WEBPACK-A ,NE ZELE DA NESTO TAKVO RADIM AT RUNTIME**

AKO IMAM SOURCES AVAILABLE AT CODE BASE, ZELIM DA IH CODE SPLITT-UJEM STATICNO

## STATIC CODE SPLITTING

KADA OVO ZELIM DA KORISTIM

KADA IMAM "HEAVY" JAVASCRIPT (HEAVY LIBRARY), KOJI ZELIM DA KORISTIM, ALI MI NE TREBA UP FRONT (UNAPRED)

AKO 3GS LIBRARY NE KORISTIM U MOM INITIALL DOWNLOAD-U, ZASTO BI TO IMAO U MOJIM INITALLY DOWNLOADED BUNDLE-OVIMA (YOU ONLY WANTED WHEN IT'S NEEDED)

ANYTHING TEMPORAL (AKO NIJE TAMO INITIALLY, IT APEARS AND GOES AWAY) (ZAMISLI MODAL ILI TOOLTIP, ILI DIALOG) (SVE STO NIJE VISIBLE NA STRANICI I TREBA CONDITIONALLY DA SE LOAD-UJE) (TO JE TEMPORAL)

TU SE UBRAJA I SCROLLING DOWN THE PAGE (ONO STO JE BELLOW THE FOLD JESTE, TEHNICKI TEMPORAL)

PA CAK I **ROUTS**

****

MORAM SE TACNO POZABAVITI STA JE [ROUTING](https://medium.com/@fro_g/routing-in-javascript-d552ff4d2921)(DOBAR MEDIUM-OV BLOG POST) DO DETALJA, ODNOSNO **CLIENT SIDE ROUTING**

JASNO MI JE SLEDECE ALI MORAM NAUCITI React Router DO DETALJA

**IZ ONOGA STA SAM RAZUMEO, ON SIMULIRA PRELAZ SA JEDNE NA DRUGU STRANICU, KOD SINGLE PAGE APLIKACIJA, JER SINGLE PAGE APP NE MOZE IMATI DODATNI HTML DOKUMENT**

>>>> The router will be in charge of simulating transitions between documents by watching changes on the URL. When the document is reloaded or the URL is modified somehow, it will detect that change and render the view that is associated with the new URL. (I OVO MI SADA IMA SMISLA OD RANIJE, JER KORISTECU ROUTER U React-U, `<Router>` JE WRAPP-OVA JSX CODE MAIN KOMPONENTE)

[CLIENT-SIDE ROUTING AND SERVER-SIDE ROUTING](https://medium.com/@wilbo/server-side-vs-client-side-routing-71d710e9227f)

>>>> A client-side route happens when the route is handled internally by the JavaScript that is loaded on the page. (React ROUTER, I NJEGOVE KOMPONENTE `<Link>` JESU TAJ JAVASCRIPT)

>>>> When browsing, the adjustment of a URL can make a lot of things happen. This will happen regularly by clicking on a link, which in turn will request a new page from the server.

>>>> A whole new document is served to the user.

>>>> A server-side request causes the whole page to refresh. This is because a new GET request is sent to the server which responds with a new document, completely discarding the old page altogether.

**IZ PREDHODNIH RECENICA JE POTPUNO JASNO STA JE TO SERVER-SIDE ROUTING (TO JE DEFAULT, ODNOSNO SLUCAJ KADA MOJ APP NIJE SINGLE PAGE APP) I CLIENT-SIDE ROUTING (JAVASCRIPT KOJI SIMULIRA PRELAZ NA DRUGU STRANICU, KOJ ISE NE DESAVA, VEC SE USTVARI RENDERUJU NOVI ELEMENTI IZ NEKOG TEMPALTE-A, KADA SE PREDHODNO SVI TRENUTNI UKLONE)**

****

DAKLE, STO SE TICE WEBPACK-A, SVAKI PUT KAD IMAM ROUTS, POSEBNO CLIENT SIDE ROUTING, USER CE PRI POSETI TVOG APP OTICI NA TVOJ PRVI ROUT; STO ZNACI DA BI TREBAO SPLITT-OVATI EVERY SINGLE ROUT KOJI IMAS; KAKO BI SE POSTARO DA, JEDINI CODE KOJI BIVA DELIVERED, ZA KORISNIKOV EXPERIENCE, JESTE NA ONOM ROUT-U NA KOJEM JE KORISNIK TRENUTNO