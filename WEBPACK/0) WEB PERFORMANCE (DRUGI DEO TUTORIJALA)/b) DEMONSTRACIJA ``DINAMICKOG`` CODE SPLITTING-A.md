# DEMONSTRACIJA "DINAMICKOG" CODE SPLITTING-A

- U src FOLDERU, KREIRAM NOVI FOLDER, KOJI SE ZOVE **button-styles** I TAMO DODAJEM NEKOLIKO FAJLOVA

- TAMO KREIRAM MODULE:

1. tomato.js

2. olive.js

3. almond.js

- A DIREKTNO U src FOLDER-U, ONI FAJLOVI, KOJI SU BITNI ZA OVU DEMONSTRACIJU SU button-style.js MODUL I, NARAVNO ENTRY POINT index.js

IMAM OVAKVU FILE/FOLDER STRUKTURU

```linux
 src
    |   ...
    │   button-style.js
    │   index.js
    │
    └───button-styles
            almond.js
            olive.js
            tomato.js
```

**tomato.js** FAJL:

```javascript
export default "color: tomato";
```

**olive.js** FAJL:

```javascript
export default "color: olive";
```

**almond.js** FAJL:

```javascript
export default "color: blanchedalmond";
```

****
****

**button-style.js** FAJL:

```javascript
export default (button, style) => {
    button.style = style;
}
```

**index.js** FAJL:

**PRATI KOMENTARE U OVOM FAJLU, POSTARAO SAM SE DA KROZ NJIH BUDE SVE RAZUMLJIVO**

```javascript
import butonStyleFunc from './button-style'

// EVO GA "DINAMICKI" CODE SPLITTING
const bringButtonStyleDinamicly = fileName => import(`./button-styles/${fileName}`);

// AKO SAMO OSTAVIM GORNJI DEO CODE-A, ODNOSNO SAMO "DYNAMIC CODE SPLITTING FUNKCIJU"
// I AKO SAVE-UJEM (NARAVNO POKRENUT MI JE DEV SERVER), BICE BUNDLED VISE FAJLOVA, BICE BUNDLED
// USTVARI:

            //      OSNOVNI BUNDLE (KOJI JE JEDINI UCITAN U HTML)

            //       3      DODATNA BUNDLE-A, KOJI SU BUNDLE-I, MODULA IZ          button-style       FOLDERA

                            // ONI NARAVNO NISU UCITANI U HTML


// ALI DALJE NASTAVLJAM DEFINISANJE

const hipsterButton = document.createElement('button');
hipsterButton.innerText = "hipster";
document.body.appendChild(hipsterButton);

hipsterButton.onclick = ev => {
    // OVDE CU UPOTREBITI "DINAMICKI" IMPORT, KAKO BI PROMENIO BOJU DUGMETA NA OLIVE

    // JA SAM USTVARI OVDE MOGAO STAVLJATI debugger IZJAVU (PRE SLEDECEG CODE-A)
    // TIME MOGU VRSITI DEBUGGING, AKO JE PROBLEM SA "DINAMICKIM" CODE SPLITTING-OM

    bringButtonStyleDinamicly('olive')
    .then(module => buttonStyleFunc(ev.target, module.default))

    // POSTO SAM PASSED IN, "olive", NESTALI SU DODATNI BUNDLE-I
    // SADA IMA SAMO DVA
                            // GLAVNI
                            // I ONAJ KOJI JE BUNDLE olive.js FAJLA
}
```

ps. SAZNAJ VISE O [debugger STATEMENT-U](https://github.com/Rade58/apis_trying_out_and_practicing/blob/master/JAVASCRIPT%20OBJASNJENJA/4.%20debugger%20STATEMENT.md)

*LARKIN NAROCITO VOL IDA KORISTI **debugger** STATEMENT KADA RADI DINAMICKI CODE SPLITTING*

**DAKLE JA SAM MORAO OBEZBEDITI WEBPACK-U INFORMACIJU, GDE CE USTVARI, RESOLVE-OVATI MODULE A TA INFORMACIJA JE:**

- PATH "./button-styles"

**JA SAM MOGAO VRSITI I CONCATENATION (*"./button-styles" + fileName*) ALI BILO JE, VISE CONVINIENT KORISTITI TEMPLATE STRING**

**DAKLE, NAROCITO JE ZANIMLJIVO, BAR MENI, KAKO SE OVAJ "DINAMICKI" CODE SPLITTING, ODVIJA U DVA STADIJUMA**

- TAMO GDE JE DEFINISAN BI BIO PRVI STADIJUM (POZVAN KAO POVRATNA VREDNOST NEKE FUNKCIJE, KOJA NIJE JOS POZVANA) TADA JE OBEZBEDJEN PATH

>>>> I TADA SU KREIRANU BUNDLE-I, SVIH MODULA IZ FOLDER-A

- A DRUGI STADIJUM JE POZIVANJE, SAME FUNKCIJE U KOJOJ JE POVRATNA VREDNOST TAJ "DINAMICNO" UPOTREBLJEN DINAMICKI import() (TADA SE VREDNOST VARIJABLE PROSLEDJUJE, ODNOSNO STRING IMENA FAJLA PROSLEDJUJE PATH-U)

>>>> TADA JE BUNDLED SAMO TRAZENI MODUL (DAKLE SAMO NJEGOV FAJL JE KREIRAN)

**OPET PONAVLJAM DA JE DOBRO KORISTITI debugger STATEMENT U CODE-U ENTRY POINT-A, ILI KORISTITI BREAKPOINTS U DEV TOOLS-U, ZA FAJL ENTRYPOINT-A, PRE SAMOG POZIVANJA FUNKCIJE CIJA JE POVRATNA VREDNOST, TAJ "DINAMICKI" UPOTREBLJEN DINAMICKI import() (ODNOSNO SKLANJATI I STAVLJATI BREAKPOINT (UZ TO RELOAD-OVATI STRANICU), KAKO BIH SAZNAO DA LI JE PROBLEM UPRAVO "DINAMICKI" CODE SPLITTING)**

## DAKLE, NA OVAJ NACIN JA SAM KREIRAO FUNKCIJU CIJA JE ULOGA "DINAMICKI" CODE SPLITTING, KOJ JE ZAISTA REUSABLE

```javascript
const bringButtonStyleDinamicly = fileName => import(`./button-styles/${fileName}`);
```

OVA FUNKCIJA SE MOZE KORISTITI DALJE U CODE-U, ZA SLUCAJ NEKOG DRUGOG FAJLA U **button-styles** FOLDERU

## ZAPAMTI UVEK, DA AKO NISI PROVIDE-OVAO PARTIAL PATH, NECES MOCI KORISTITI POMENUTI "DINAMICKI" CODE SPLITTING (ZNAM DA SAM VEC REAKO ALI TREBA DA OVO ZACEMENTIRAM U GLAVI)

AKO DODAM SAMO VREDNOST VARIJABLE, BICE THROWN, ONAJ ERROR, KOJI SAM VEC POMINJAO

```javascript
// OVO NIJE DOBRO
const bringButtonStyleDinamicly = filePath => import(filePath);
```

:warning::warning::warning: **Critical dependency: the request of a dependency is an expression** :warning::warning::warning:

>> LARKIN KAZE DA BI MAINTAINER-I WEBPACK-A TREBALI MOZDA DA OVA WARNING UCINE VISE RAZUMLJIVIM, NEGO STO JE SADA

POENTA JE U TOME DA WEBPACK MORA DA RESOLVE-UJE DEPENDANCY, A JA SAM MU SAMO PLASIRAO VREDNOST VARIJABLE; **I ON UOPSTE NE ZNA GDE DA TRAZI CODE**

**TO SE MORA URADITI STATICKI**

- I ZATO JE PARTIAL PATH PROVIDED

## RegExp UNDER THE HOOD

**WEBOPACK USTVARI KORISTI RegExp UNDER THE HOOD, I SEPARATE-UJE PARTIAL PATH OD VARIJABLE**

**CAK JE MOGUCE DODATI I** .js PATH-U

```javascript
const bringButtonStyleDinamicly = fileName => import(`./button-styles/${fileName}.js`);  // DODAO .js
```

**U OVOM SLUCAJU WEBPACK BI PRVO POKUSAO DA RESOLVE-UJE PATH, SA INFORMACIJO MDA JE REC O JAVASCRIPT-U**

OVO ZNACI DA AKO BIH NA PRIMER IMAO css MODULE, ONI NE BI BIL IRESOLVED I ONI NE BI BILI BUNDLED

BILI BI BUNDLED SAMO JAVASCRIPT FAJLOVI

TO MOGU PROVERITI I PUTEM PRIMERA

**DAKLE DODAVANJE .js JE USTVARI ZADLO FILTER, KOJI "GOVORI": *Resolve-uj samo javascript module***

THIS IS COOLEST THING