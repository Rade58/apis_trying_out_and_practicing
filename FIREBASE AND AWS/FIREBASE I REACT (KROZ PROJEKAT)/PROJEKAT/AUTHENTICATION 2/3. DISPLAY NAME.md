# DISPLAY NAME

KADA KORISNIK NIJE PRIJAVLJEN, ODNONO KADA OTVORIM MOJA APP MOGU VIDETI ONO STO JE RENDERED KAO POSLEDICA KOMPONENTE SignInAnSignUP

A CIJA JE POD KOMPONENTA UPRAVO I ONA SignUp KOMPONENTA

DAKLE JEDAN OD FORMULARA JE RENDERED, I TU JE KAO POSLEDICA REACT ELEMENTA, REPRESENTED BY SignUp COMPONENT

IMAM TRI INPUT FIELD-A: ZA DISPLAY NAME, ZA EMAIL I ZA PASSWORD

I IMAM DUGME ZA SUBMIT, ODNOSNO DUGME ZA Sign Up, KOJE ZA SADA NEMA FUNKCIJU (MOGU UNOSITI STAVARI I PRITISKATI POMENUTO DUGME I ONO STA CE SE DOGODITI JESTE UKLANJANJE TEKSTA IZ INPUTA, JER SE SADA ON SUBMIT, SAMO STATE SignUp KOMPONENTE VRACA NA POCETNO STANJE)

## SADA CU DA JUMP-UJEM IN SignUp.jsx FAJL KAKO BI POCEO SA IMPLEMENTIRANJEM, A PRVO CU USTAVRI POGLEDATI SA IMAM U TOJ KOMPONENTI

SignUp.jsx FAJL:

```javascript
import React, {Component} from 'react';

class SignUp extends Component {

    state = {displayName: '', email: '', password: ''}

    handleChange = ev => {

        const {name, value} = ev.target;

        this.setState({
            [name]: value
        })

    }

    handleSubmit = ev => {

        ev.preventDefault();

        // DAKLE, NEMA NISTA OVEDE ZA SADA
        // SEM VRACANJA STATE-A NA POCETNO STANJE

        this.setState({
            email: '',
            password: '',
            displayName: ''
        })

    }

    render(){

        const {displayName, email, password} = this.state;

        return (
            <form className="sign_up" onSubmit={this.handleSubmit}>
                <h2>Sign Up</h2>
                <input
                    type="text"
                    name="displayName"
                    placeholder="Display Name"
                    value={displayName}
                    onChange={this.handleChange}
                />
                <input
                    type="email"
                    name="email"
                    value={email}
                    placeholder="Email"
                    onChange={this.handleChange}
                />
                <input
                    type="password"
                    name="password"
                    value={password}
                    placeholder="Password"
                    onChange={this.handleChange}
                />
                <input
                    type="submit"
                    value='Sign Up'
                />
            </form>
        );

    }

}

export default SignUp;
```

## SADA MOGU RESTRUKTURIRATI STATE, SignUp KOMPONENTE, JER ZELIM DA KORISTIM TE VREDNOSTI; A ONO STO ZELIM DA URADIM, JESTE DA KREIRAM USER OBJEKAT

**ALI ZELIM DA onSubmit UCINIM async FUNKCIJOM**

ZASTO?

PA ZATO STO SU, KAO STO ZNAM, MOST OF FIREBASE FAETURE-A, SU Promise BASED, I JA MOGU KORISTITI then catch CHAINING

ALI URADICU NESTO DRUGO

**U POMENUTOJ async FUNKCIJI CU KORISTITI OLD SCHOOL** *try{} catch{}* BLOKOVE

MEDJUTIM, PRE SVEGA TOGA BICE MI POTREBAN **auth** IZ *src/firebase.js* FAJLA

ZASTO

PA ZATO STO NA auth OBJEKTU ZELIM DA PRISTUPIM FUNKCIJI **createUserWithEmailAndPassword**

## POMENUTOJ FUNKCIJI ARGUMENTI SU EMAIL I PASSWORD STRINGOVI

SignUp.jsx

```javascript
import React, {Component} from 'react';

// DAKLE PRVO DA UVEZEM auth IZ src/firebase.js
import {auth} from '../firebase';

class SignUp extends Component {

    state = {displayName: '', email: '', password: ''}

    handleChange = ev => {

        const {name, value} = ev.target;

        this.setState({
            [name]: value
        })

    }

    handleSubmit = async ev => {              // KAO STO RECE OVO JE OD SADA async FUNKCIJA

        ev.preventDefault();

        // RESTRUKTUIRAM STATE, OVE KOMPONENTE

        const {displayName, email, password} = this.state;

        // SADA CU KORISTITI try {}  catch {}   BLOKOVE

        try {
            // U OVOM BLOKU KORISTICU POMENUTI auth.createUserWithEmailAndPassword()
            // ARGUMENTI SU JOJ EMAIL I PASSWORD STRINGOVI

            // A BITNO MI JE DA DODAM DA CE POMENUTA METODA RETURN-OVATI Promise
            // KOJI TREBA DA BUDE RESOLVED SA OBJEKTOM, KOJI CE NA SEBI IMATI I user PROPERTI
            // MENA SAMO ZANIMA TAJ user PROPERTI

            const {user} = await auth.createUserWithEmailAndPassword(email, password)


        }catch(error){

            // OVDE CU DA ISKORISTIM        console.error

            console.error(error);


        }

        this.setState({
            email: '',
            password: '',
            displayName: ''
        })

    }

    render(){

        const {displayName, email, password} = this.state;

        return (
            <form className="sign_up" onSubmit={this.handleSubmit}>
                <h2>Sign Up</h2>
                <input
                    type="text"
                    name="displayName"
                    placeholder="Display Name"
                    value={displayName}
                    onChange={this.handleChange}
                />
                <input
                    type="email"
                    name="email"
                    value={email}
                    placeholder="Email"
                    onChange={this.handleChange}
                />
                <input
                    type="password"
                    name="password"
                    value={password}
                    placeholder="Password"
                    onChange={this.handleChange}
                />
                <input
                    type="submit"
                    value='Sign Up'
                />
            </form>
        );

    }

}

export default SignUp;
```

PRIMECUJES DA NIGDE NISI ISKORISTIO displayName; ODNOSNO KAO ARGUMENT SE NIGDE NIJE DODAVAO DISPLAY NAME, NAIME UBRZO CU NAUCITI KAKO I TO DA URADIM, ALI PRVO DA VIDIM, CIME SE TO RESOLVE-UJE Promise, KOJI PROIZILAZI IZ POZIVANJE, GORNJE FUNKCIJE

## DAKLE OBJEKAT (KOJI SAM JA GORE RESTRUKTURIRAO, JER ZELIM NJGOV user PROPERTI) SA KOJIM JE RESOLVED Promise RETURNED BY createUserWithEmailAndPassword, JESTE USTVARI USER CREDENTIALS OBJEKAT

TO JE SLICAN OBJEKAT, KOJ ISAM DOBIJAO KADA SAM KORISTIO GOOGLE AUTH

## POMENUTO DEFINISANO BI TREBALO DA KREIRA KORISNIKA I DA GA TAKODJE LOGG-UJE IN

## :cyclone::cyclone::cyclone::cyclone: SADA CU SE UPOZNATI SA JEDNOM OPCIJOM, KOJA CE MI POMOCI DA RESIM displayName ISSUE; ALI VIDECU I DA TAKAV NACIN NECE BITI BAS IDEALAN :cyclone::cyclone::cyclone::cyclone:

HOPES ARE BROUGHT UP, AND THEN THEY ARE, AGAIN BROUGHT DOWN

## ZA POMENUTU POTREBU, DODAVANJA diplayName-A KORISTICU TAJ user OBJEKAT, KOJI SAM DOBIO RETRUKTURIRANJEM USER CREDENTIALS OBJEKAT, O KOJEM SAM GORE GOVORIO; A NA TOM user OBJEKTU, PRIMENICU updateProfile() METODU, KOJOJ KAO ARGUMENT ZADAJEM OBJEKAT, KOJI MOZE IMATI DVA PROPERTIJA; A TO SU displayName i photoURL, KOJE SADA, NA OVAJ NACIN MOGU ZADATI

NEMAM photoURL; DAKL ZADAJEM SAMO displayName

SignUp.jsx

```javascript
import React, {Component} from 'react';

// DAKLE PRVO DA UVEZEM auth IZ src/firebase.js
import {auth} from '../firebase';

class SignUp extends Component {

    state = {displayName: '', email: '', password: ''}

    handleChange = ev => {

        const {name, value} = ev.target;

        this.setState({
            [name]: value
        })

    }

    handleSubmit = async ev => {

        ev.preventDefault();

        const {displayName, email, password} = this.state;

        try {

            const {user} = await auth.createUserWithEmailAndPassword(email, password)

            // EVO ZADAJEM ODNOSNO UPDATE-UJEM user OBJEKAT, SA PROPERTIJEM displayName

            user.updateProfile({displayName})

        }catch(error){

            console.error(error);

        }

        this.setState({
            email: '',
            password: '',
            displayName: ''
        })

    }

    render(){

        const {displayName, email, password} = this.state;

        return (
            <form className="sign_up" onSubmit={this.handleSubmit}>
                <h2>Sign Up</h2>
                <input
                    type="text"
                    name="displayName"
                    placeholder="Display Name"
                    value={displayName}
                    onChange={this.handleChange}
                />
                <input
                    type="email"
                    name="email"
                    value={email}
                    placeholder="Email"
                    onChange={this.handleChange}
                />
                <input
                    type="password"
                    name="password"
                    value={password}
                    placeholder="Password"
                    onChange={this.handleChange}
                />
                <input
                    type="submit"
                    value='Sign Up'
                />
            </form>
        );

    }

}

export default SignUp;
```

## :o::o::o::o: KADA KORISNIK SADA UNESE BILO KOJU EMAIL ADRESU I BILO KOJI PASSWORD (NARAVNO EMAIL I PASSWORD SE MORAJU UNOSITI PO U SKLADU SA TIM KAKO JE U HTML PREDEFINISANO, ODNOSNO MOJ STRING MORA DA MATCH-UJE PATTERN KOJI ODGOVARA ONOME STO JE PREDEFINISANO U HTML-U); USER CE BITI KREIRANI KORISNIK CE AUTOMATSKI BITI LOGGED IN ALI POSTOJACE JEDAN PROBLEM :o::o::o::o:

KAKO JE I SAM STEVE KINNEY SAM REKAO:
> "TO JE ONAJ PROBLEM, KOJIEG SE PODSETIS JEDAN DAN TOKO MSETNJE I SLUCAJNO OTKRIJES RESENJE"

U SUSTINI, KORISNIK CE BITI SIGNED INA, ALI **NECE BITI PRIKAZAN displayName**

ZASTO JE TO U PITANJU VIDECU UBRZO

HAJDE SADA DA PRVO POGLEDAM JEDAN ERROR, KOJI SE TAKODJE POJAVIO

## POGLEDACU POMENUTI ERROR, PA CU SE ONDA VRATIT NA TO ZASTO SE NIJE RENDER-OVAO I DISPLAY NAME

DAKLE, HAJDE DA STAMPAM ERROR

>>>> Warning: Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.
> in SignUp (at SignInAndSignUp.jsx:9)
> in div (at SignInAndSignUp.jsx:7)
> in SignInAndSignUp (at Authentication.jsx:19)

**JA, KREIRAJUCI NOVOG KORISNIKA, UCINIO SAM DA SE NA CLOUD STRAN ITRIGGER-UJE AUTH STATE CHANGE**

A KADA POSTOJI user U OBIMU onAuthStateChange CALLBACK-A (SLUSAM OVO U componentDidMout LIFECYCLE HOOK-U Application KOMPONENTE), DAKLE DESICE SE RE RENDERING, JER U OBIMU TOG CALLBACKA MENJAM STATE APLIKACIJE SA PRISTIGLI Muser OBJEKTOM, I KAO STO REKOH RERENDERING SE DOGADJA DOWN THE PIPLINE

DAKLE OVDE JE UPITNA PROMENA STATE-A, KOJU MENJAM onSubmit KADA VRACAM STATE NA POCETNI POLOZAJ

DA UPROSTIM JER NEMAM VREMNA:

*PROMENA TOG STATE-A JE POKRENUTA, ALI ZBOG TOGO STO SAM PROIZVEO SITUACIJU U KOJOJ JE user PROMENJENO ON SNAPSHOT, DESIO SE CONDITIONAL RENDERING KOMPONENTE KOJA JE NAD KOMPONENTA SignUp-A; ODNOSNO DESILO SE DA SE TA NAD KOMPONENTA (U PITANJU JE SignInAndSignUp) UNMOUNTUJE, A ZAJEDNO SN JOM I PODKOMPONENTA SignUp, KOJA JE ZAPOCEA PROMENU STATE-A*

A PROMNA STATA SE NE TREBA VRSITI NA UNMOUNTED KOMPONENTI

ZATO AKO POSTOJI BOJAZAN DA SE OVO MOZE DOGODITI, MOGU PONUDITI OVAKVO RESENJE

ODNOSNO MOGU DEFINISATI 'BOOLEAN' **PROPERTI** KOJU BI IMALA SignUp INSTANCA I KOJA SUGERISE DA LI SE DOGODITIT UNMOUNTING ILI NE

NARAVNO ZA TU POTRBU CU KORISTITI **componentWillUnmaunt** LIFECYCLE HOOK

```javascript
import React, {Component} from 'react';

// DAKLE PRVO DA UVEZEM auth IZ src/firebase.js
import {auth} from '../firebase';

class SignUp extends Component {

    state = {displayName: '', email: '', password: ''}

    // ZADAJEM NOVI PROPERTI, KOJI CUVA INFO DA LI CE SE KOMPONENTA UNMOUNT-OVATI
    // ILI NECE
    _willUnmount = false; // ZA POCETAK JE false

    handleChange = ev => {

        const {name, value} = ev.target;

        this.setState({
            [name]: value
        })

    }

    handleSubmit = async ev => {

        ev.preventDefault();

        const {displayName, email, password} = this.state;

        try {

            // OVO CE DAKLE IZAZVATI RE-RENDERING MOG APP-A, I UCINICE DA SE
            // IZMEDJU OSTALOG, OVA KOMPONENTA UNMOUNT-UJE
            const {user} = await auth.createUserWithEmailAndPassword(email, password)

            user.updateProfile({displayName})

        }catch(error){

            console.error(error);

        }

        // A SLEDECE JE PROMENA STATE-A, KOJA SE RANIJE NASTAVILA, IAKO JE
        // TAKODJE COMPONENTA OTPOCELA SA UNMOUNTING-OM
        // DAKLE CILJ MI JE DA SLEDECE PROMENIM

        /* this.setState({
            email: '',
            password: '',
            displayName: ''
        }) */

        // DAKLE, NEKA SE PROMENA STATE-A IZVRSI SAMO ONDA KADA SE KOMPONENTA NECE UNMOUNT-OVATI

        if(!this._willUnmount){

            this.setState({
                email: '',
                password: '',
                displayName: ''
            })


        }
    }

    // A ONADA KADA CE SE SIGURNO KOMPONENTA UNMOUNT-OVATI, MENJAM VREDNOST, POMENUTE VARIJABLE

    componentWillUnmount = () => {
        this._willUnmount = !this._willUnmount;
    }

    render(){

        const {displayName, email, password} = this.state;

        return (
            <form className="sign_up" onSubmit={this.handleSubmit}>
                <h2>Sign Up</h2>
                <input
                    type="text"
                    name="displayName"
                    placeholder="Display Name"
                    value={displayName}
                    onChange={this.handleChange}
                />
                <input
                    type="email"
                    name="email"
                    value={email}
                    placeholder="Email"
                    onChange={this.handleChange}
                />
                <input
                    type="password"
                    name="password"
                    value={password}
                    placeholder="Password"
                    onChange={this.handleChange}
                />
                <input
                    type="submit"
                    value='Sign Up'
                />
            </form>
        );

    }

}

export default SignUp;
```

NA KRAJU KRAJEVA LOGICNO JE: **ZASTO UOPSE OTPOCINJATI PROMENU STATE-A NA KOMPONENTI KOJA CE BITI UNMOUNTED**

I SADA KADA BUDEM POKUSAO DA SE SIGN-UJEM UP UZ POMOC mail-a, KAO POSLEDICNA STVAR DESICE SE, NARAVNO POKRENUCE SE UNMOUNTING (ZASTO, REKOH MNOGO PUTA GORE), ALI POSTO SAM IZABRAO DA STATE NE MENJAM KADA SE TO DESAVA, NA GORE DEFINISANI NACIN UZ POMOC PROPERTIJA; ZAISTA SE NECE DOGODITI POMENUTI ERROR

MOZDA MOZES ZABORAVITI ALI UNMOUNDING KOMPONENTE ZNACI UNISTAVANJE, NJENE INSTANCE, ILI UNISTAVANJE REACT ELEMENT-A, KOJI JE REPREZENTUJE I, ODNOSNO TO JE DEATH INSTANCE KOMPONENTE I ONA TADA BIVA GARBAGE COLLECTED

[POGLEDAJ TO U OVOM IN DEPT TUTORIJALU](https://developmentarc.gitbooks.io/react-indepth/content/life_cycle/death_unmounting_indepth.html) (OSTAVIO SAM OVAJ CEO TUTORIJAL U PODSETNIKU)

## :rewind::rewind::rewind::rewind: JA NAIME NISAM OBJASNIO SLEDECE: U SLUCAJU SIGNING UP-A WITH EMAIL, KORISNIK CE UNETI EMAIL, PASSWORD I DISPLAY NAME, ALI KADA SE RENDER-UJE USER PROFILE, TAM OGDE JE NAMENJEN ODA SE PRIKAZE displayName, NECE BITI NISTA, ODNOSNO TAM OSE PROSLEDJUJE PRAZAN STRING :rewind::rewind::rewind::rewind:

POGLEDACU OPET UPOTREBU 

```javascript
import React, {Component} from 'react';

// DAKLE PRVO DA UVEZEM auth IZ src/firebase.js
import {auth} from '../firebase';

class SignUp extends Component {

    state = {displayName: '', email: '', password: ''}

    _willUnmount = false;

    handleChange = ev => {

        const {name, value} = ev.target;

        this.setState({
            [name]: value
        })

    }

    handleSubmit = async ev => {

        ev.preventDefault();

        const {displayName, email, password} = this.state;

        try {

            // EVO OVO JE DAKLE RESTRUKTURIRANI OBJEKAT, A KOJI JE VREDNOST SA KOJOM SE
            // RESOLEVE-UJE Promise, PROIZISAO IZ POZIVANJA         auth.createUserWithEmailAndPassword
            const {user} = await auth.createUserWithEmailAndPassword(email, password);



            user.updateProfile({displayName})

        }catch(error){

            console.error(error);

        }


        if(!this._willUnmount){

            this.setState({
                email: '',
                password: '',
                displayName: ''
            })

        }
    }


    componentWillUnmount = () => {
        this._willUnmount = !this._willUnmount;
    }

    render(){

        const {displayName, email, password} = this.state;

        return (
            <form className="sign_up" onSubmit={this.handleSubmit}>
                <h2>Sign Up</h2>
                <input
                    type="text"
                    name="displayName"
                    placeholder="Display Name"
                    value={displayName}
                    onChange={this.handleChange}
                />
                <input
                    type="email"
                    name="email"
                    value={email}
                    placeholder="Email"
                    onChange={this.handleChange}
                />
                <input
                    type="password"
                    name="password"
                    value={password}
                    placeholder="Password"
                    onChange={this.handleChange}
                />
                <input
                    type="submit"
                    value='Sign Up'
                />
            </form>
        );

    }

}

export default SignUp;
```