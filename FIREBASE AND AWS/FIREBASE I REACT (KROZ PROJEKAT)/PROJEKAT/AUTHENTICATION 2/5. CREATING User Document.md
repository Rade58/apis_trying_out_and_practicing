# KREIRANJE USED DOKUMENTA

DAKLE, ONO STA ZELIM SADA DA URADIM JESTE DA STORE-UJEM USER INFORMATION, ODNOSNO DA KREIRAM USER PROFILE

ALI JA SAD IMAM DVA 'CODE PATH-A'

KAKO TO?

:one: PA KADA SE NOVI KORISNIK *SIGNUJE UP SA GOOGLE oAuth-om*, ON U STAVRI TADA NIJE MORAO DA SE SIGN-UJE UP U KLASICNOM SMISLU, ON SE TADA USTVARI **SIGN-OVAO IN UZ POSTOJECI GOOGLE ACCOUNT, I ONDA JE FIREBASE KREIRAO user OBJEKAT ZA TOG KORISNIKA**

DAKLE JEDAN NACIN SA KOJI MSE MOZES :v: *Sign Up-OVATI* :v: FOR ACCOUNT, JESTE JEDNOSTAVNO SIGNING IN UZ POSTOJECI GOOGLE ACCOUNT

:two: I IMAM NACIN PO KOJEM KORISNIK POPUNJAVA **Sign Up FORMULAR** I NA TAJ NACIN SE KREIRA NOVI user OBJEKAT

## DAKLE IMAM DVA CODE PATH-A, SA KOJIMA OVDE TREBAM DA DEAL-UJEM

DAKLI, MORAM DA FIGURE-UJEM OUT, DA LI SE POMENUTO DESAVA, IZ SIGN UP FORMULARA, ILI UZ GOOGLE oAuth

## TAKODJE OVDE MORAM DA PAZIM DA NE RECREATE-UJE ACCOUNT

NA PRIMER AKO SE KORISNIK SIGN IN-UJE UZ POMOC GOOGLE-A, MOGU 'RECI' DA: UZMI TAJ photoURL, UZMI TAJ displayName, JER TO IZGLEDAJU KAO SENSIBLE DEFAULTS, LETS GO WITH THAT

KADA BI TO URADIO ON EVERY LOG IN

TO ZNACI UPLOADING PICTURE-A I CHANGING DISPLAY NAME-A, AND WE BLOW IT AWAY NEXT TIME WHEN THEY LOG IN (NE MOGU SADA DA ZAMISLIM OVAJ PROBLEM, MOZDA CU SHVATITI, KADA KRENEM SA CODIRANJEM) THATS NOT GREAT

## ONO KAK OZELIM DA POCNEM, JESTE DA CHECK-UJEM DA LI TA JDOKUMENT, VEC POSTOJI; I AKO NE POSTOJI, KREIRACU PROFILA ZA KORISNIKA; A AKO POSTOJI RESPECT-OVACU PROFIL KOJI, VEC IMAJU I KORISTICU TO INSTEAD OF AUTH DATA

DAKLE OVDE CE MI TREBATI DVE METODE:

- JEDNA ZA CREATING USER PROFILA, ODNOSNO USER DOKUMENTA

- JEDNA ZA GETTING USER DOCUMENT, ODNSNO USER PROFILE

## DAKLE DODAJEM JOS STVARI U src/firebase.js FAJL (JA SAM MOGA OSVE TO SPLIT-OVATI U MULTIPLE FILES, ALI ONDA BI TO BILO CONFUSING)

DAKLE U POMENUTOM FAJLU, AVAILABLE SU MI auth I firestore

CODE KOJI CU PISATI BICE MALKO 'SQURLIER' NEGO RANIJE, JER CU VRSITI PROVERE, DA LI DOKUMENT POSTOJI, ALI POKRICU GA KOMENTARIMA

## PRVO KREIRAM I EXPORTUJEM METODU, KAOJA CE SE ZVATI createUserProfileDocument

src/firebase.js FAJL:

```javascript
import firebase from 'firebase/app';

import 'firebase/firestore';

import 'firebase/auth';

const firebaseConfig = {
    apiKey: "AIzaSyBNNF3Fz3Q8SLRUzmpDvEFG29QiMUQnGWg",
    authDomain: "think-clone.firebaseapp.com",
    databaseURL: "https://think-clone.firebaseio.com",
    projectId: "think-clone",
    storageBucket: "",
    messagingSenderId: "885463908020",
    appId: "1:885463908020:web:ba744ff22f41a4a7"
};

firebase.initializeApp(firebaseConfig);

export const firestore = firebase.firestore();

export const auth = firebase.auth();

export const provider = new firebase.auth.GoogleAuthProvider();

export const signInWithGoogle = () => auth.signInWithPopup(provider);

export const signOut = () => auth.signOut();

//EVO TO CU URADITI OVDE
// OVO CE BITI async FUNCTION, CIJI CE RAGUMENTI BITI       user        DOBIJEN OD auth MODULA 
//                                   I TAKODJE NESTO STO CU NAZVADI         additionalData

export const createUserProfileDocument = async (user, additionalData) => {

    // ONO STA ZELIM DA STAVIM U additionaslData BICE USTVARI displayName
    // AKO SE PODSETIM, KADA SAM DEFINISAO SIGNING UP WITH EMAIL    displayName
    // NIJE MOGLO DA SE PRIKAZE IZ RAZLOGA KOJE SAM OBJASNIO PRI KRAJU TRECEG md DOKUMENTA
    // U TREBUTNOM FOLDERU GDE PISEM OBJASNJENJA

    // NAIME ZA GOOGLE OAUTH JA HOCU DOBITI displayName OUT OF THE BOX, ALI KOD EMAIL AUTHENTICATON ATO NIJE SLUCAJ

    // DEFINISACU DA SE TAJ displayName PASS-UJE ALONG, KADA GA KORISNIK PUTT-UJE U FORM

    // DAKLE IMACU BOTH OPTIONS


  //(1) MORAM UZETI U OBZIR MOGUCNOST DA SE OVA FUNKCIJA POZOVE, A DA PRI TOME NE PROSLEDI user OBJEKAT
    // ZAISTA MOZE BITI MOGUCE DA SE TADA POZOVE
    // FUNKCIJA TADA TREBA DA SE RETURN-UJE

    if(!user) return;

    // ONA USTVARI MOZE DA SE POZOVE ON STATE CHANGE, U SLUCAJU GOOGLE SIGN IN-A
    // ODNOSNO ONDA KADA SE KORINIK SIGNUJE OUT (TADA SE NA auth-U PRIMENJUJE signOut METODA)
    // I TO CE TRIGGER-OVATI ON AUTH STATE CHANE
    // PRI KOJEM null BIVA PROSLEDJENO U user


  // (2) SADA SE MORAM UVERITI, DA LI JE DOKUMENTU DATABSE-U
    // ZELI MDA NAJDEM REFERENCU DO TOG MESTA U DATABASE-U

    // DAKLE AKO JE OVAJ KORISNIK IMAO PROFIL U MOM DATABASE-U, MORAM PRONACI, NJEGOV uid

    // AKO SE POSETIM, JA SAM IMAO SNAPSHOTS, KOJI PREDSTAVLJAJU ACTUAL DATA
    // ALI IMAO SAM I REFERENCE

    // A REFERENCE SU SAMO PLACE IN THE DATBASE, SA KOJIM MOGU 'KOMUNICIRATI'

    const userRef = firestore.doc(`users/${user.uid}`)

  // (3) ALI IPAK ZELI MDA VIDIM, DA LI MOGU DOBITI I SNAPSHOT OD POMENUTOGA
    // ODNOSNO

    // ZELIM DA POKUSAM DA FETCH-UJEM DOKUMENT IZ GORNJE LOKACIJE, ODNOSNO REFERENCE

    // FETCH-OVANJE JE ASINHRONA OPERACIJA

    const snapshot = await userRef.get();   // PREDPOSTAVLJAM DA SE Promise RESOLVEUJE SA
                                            //QueryDocumentSnapshot INSTANCOM

    //!!!! AKO SE SECAM OD RANIJE   DocumentSnapshot     INSTANCA MOZE IMATI PROPERTI        exists
    // JASNO MI JE DA JE TO BOOLEAN

    // AKO DATA POSTOJI, ONDA JE true
    // TREBAM OVDE MALO DA 'RAZMISLAJAM U FIRESTORE SMISLU'
    // ODNSNO ONDA DOKUMENT POATOJI

    if(!snapshot.exists){

        // AKO DAKLE NE POSTOJI DOKUMENT, JA GA MORAM KREIRATI

        // !!!! OVDE JEDNO PODSECANJE     ZA         QuerySnapshot       PROPERTI JE         exist (NIJE PLURAL)
        //                                           DocumentSnapshot                        exists     (PLURAL)

        //              POMENUTO NEMA SMISLA U GRAMATICKOM SMISLU, ALI      TAKO JE (VALJDA A BIS E RAZLIKOVALO)


        // SADA CU PRVI PUT KORISTITI             createdAt

        const createdAt = new Date();   // OVO USTVARI NE BI TREBALO DA BUDE OVDE, JER OVO SE OBICNO KREIRA
                                        // NA SERVER STRANI (PREDPOSTAVLJAM DA TREBA SACEKATI ENDPOINT NA 
                                        // SERVER STRANI, ZADATIO cretedAt, I ONDA POHRANITI U DATBASE
                                        // ZAJEDNO SA SVIM OSTALIM)

        // ALI CU TAKODJE DA RETRUKTURIRAM ONAJ user OBJEKAT, KOJI MI JE PROSLEDJEN ON AUTH STAE CHANGE

        const {displayName, email, photoURL} = user;

        // SIGURNO, photoURL CE BITI undefined; AKO SE RADI O EMAIL AUTHENTICATION-U
        // ISTO VAZI I ZA displayName


        // RANIJE, KDA SAM KORISTIO         add     METODU ZA DODAVANJE NOVOG DOKUMANTA
        // TO SAM KORISTIO ZA DODAVANJE DOKUMENTA U 'posts' KOLEKCIJU

        // TADA JE DOCUMENT ID     BIO GENERATED FOR US  (MISLIM DA JE ISTI SLUCAJ I KADA SE
        // KORISTI set METODA NAD DocumentRedference (I TADA ID DOKUMENTA BIVA GENERISAN))

        // JA SADA ZNAM uid KOJI ZELIM

        // SADA NAIME uid KORISNIKA BICE ISTI KAO id DOKUMENTA, KOJI REPREZENTUJE USER-A

      // (4) JA CU SADA POKUSATI DA SETT-UJEM DOKUMENT NA TOJ LOKACIJI NA POMENUTOJ USER REFERENCI

        // ZA DOKUMENT
        // SETT-UJEM PROPERTIJE, ODNOSNO RETRUKTURIRANOG user OBJEKTA, POSLATON ON AUTH STATE CHANGE
        // ALI SETT-UJEM I createdAt
        // A OBJEKAT  additionalData  KOJI JE DRUGI ARGUMENT OVE FUNKCIJE, RESTRUKTURIRACU UZ
        // POMOC SPREAD SINTAKSE, DAKLE SVI PROPERTIJI I VREDNOSTI, TOG OBJEKTA, BICE ZADATI DA BUDU I 
        // PROPERTIJI I VREDNOSTI, NOVOG DOKUMENTA

        try {

            await userRef.set({
                displayName,
                email,
                photoURL,
                ...additionalData
            })

        }catch(error){
            // AKO DODAVANJE NIJE USPELO POZIVAM console.error

            console.error("Error creating user: ", error)
        }

    }

}

window.firebase = firebase;

export default firebase;
```

## MEDJUTIM, OVO NECE RADITI

ZASTO?

AKO SE PODSETIM SECURITY PRAVILA, JA SAM ZABRANIO UNAUTHORIZED KORISNICIMA DA creat-UJU NOVE DOKUMENTE

U JEDNOM OD SLEDECIH MD FAJLOVA, POZABAVICU SE MODIFIKOVANJEM SECURITY PRAVILA

## AKO IMAM DILEMA KADA CU DEFINISATI DA SE POMENUTA KREIRANA FUNKCIJA, USTVARI POZIVA

PA NARAVNO ON AUTH STATE CHANGE

