# this

OVDE ZELIM DA SE POZABAVIM PODSECANJEM NA LEXICAL SCOPE-A

USTVARI ONO STA ZELIM JESTE

:one: ZELIM I DA PONOVO PROVEZBAM bind(), apply() I call() MEDODE Function-OVOG PROTOTIPA

:two: ZELIM I DA SE PODSETIM STA SE TO DESAVA SA FUNKCIJOM, KOJA JE QUEUED, A KOJA JE DEFINISANA TAKO DA KORISTI this

:three: ZELIM DA VIDIM KAKO TO DEFINISANJE FUNKCIJE, TAKO DA BUDE ARROW UTICE NA this, KOJI TA FUNKCIJA KORISTI

## :one: I call I apply MI OMOGUCAVAJU DA PROSLEDIM OBJEKAT ARGUMENT KOJI PREDSTAVLJA VREDNOST this-A, PRI FUNKCIINE INVOKACIJE

*OBE METODE I call I apply DOZVOLJAVAJU DODAVANJE ARGUMENA FUNKCIJI*

>> RAZLIKA IZMEDJU OVE DVE METODE OGLEDA SE U TOME:

**DA call PRIHVATA NEOGRANICEN BROJ ARGUMENTA, PORED ONOG PRVOG ARGUMENT OBJEKTA, KOJI REPREZENTUJE this**

**DA apply PRIHVATA NIZ (CIJI CLANOVI JESU ARGUMENTI FUNKCIJE), PORED ONOG PRVOG ARGUMENT OBJEKTA, KOJI REPREZENTUJE this**

EVO GA TEST

```javascript

// FUNKCIJA
function metoda(x, y){

    console.log(
        {
            objekatThis: this,
            x,
            y
        }
    )

}

// DVA OBJEKTA

let a = {properti: "alpaka"}
let b = {properti: "gvanaka"}


// SADA TESTIRAM    call   I    apply

/// ******************************* DAKLE JEDINA JE RAZLIKA
//* U TOME KAK OIH POZIVAM, A OVE DVE FUNKCIJE CE PROVIDE-OVATI ISTI OUTCOME

metoda.call(a, 1, 2);           // console ---->    {objekatThis: {properti: "alpaka"}, x: 1, y: 2}

metoda.apply(b, [1, 2]);        // console ---->    {objekatThis: {properti: "gvanaka"}, x: 1, y: 2}

```

### POVRATNA VREDNOST bind() METODE JESTE FUNKCIJA, ISTOVETNA FUNKCIJA, NA KOJU JE METODA PRIMENJENA, ALI S JEDNOM RAZLIKOM: this JE SADA PREDEFINED SA OBJEKTOM, KOJI PROVIDE-UJEM

**IMAJ NA UMU DA ORIGINALNA FUNKCIJA NIJE PROMENJENA (DAKEL OUTPUTUJE SE NOVA)**

```javascript
// FUNKCIJA
function metoda(x, y){

    console.log(
        {
            objekatThis: this,
            x,
            y
        }
    )

}

// DVA OBJEKTA
let a = {properti: "alpaka"};
let b = {properti: "gvanaka"};

// *************
// KORISTIM bind, KAKO BI DOBIO FUNKCIJU, CIJE          this        UVEK IMA VREDNOST       OBJEKTA,
//                                                                                       REFERENCED BY
//                                                                                        VARIJABLA  b
//**************
let metoda2 = metoda.bind(b);
//**************

// SADA MOZES UPOTREBITI    call   I    apply     NA OUTPUTED FUNKCIJI

//    A     ARGUMENT CE BITI OBJEKAT        a


//      ONO STA CES VIDETI JESTE DA JE this UVEK        OBJEKAT         b
// ZATO STO SI GA BIND-OVAO ZA   this
metoda2.call(a, 1, 2);           // console ---->    {objekatThis: {properti: "gvasnak"}, x: 1, y: 2}

metoda2.apply(a, [1, 2]);        // console ---->    {objekatThis: {properti: "gvanaka"}, x: 1, y: 2}
```

## :two: FUNKCIJA, KOJA SE SALJE NA MICROTASK QUEUE UZ POMOC PROMISE-A, ILI JE MACROTASKED KORISCENJEM NEKIH 'TIMING METODA', DOBICE NEZELJENU VREDNOST ZA this PRILIKOM FUNKCIJINE INVOKACIJE

**USTVARI VREDNOST this-A PRI FUNKCIJINOJ INVOKACIJI, BICE UVEG GLOBALNO THIS, ODNSONO window OBJEKAT**

*TO JE ZATO STO SE FUNKCIJA POZIVA, ODNSNO STACK-UJE U NOVOM RUN-U THREAD-A, U POTPUNO NOVOM STACKING-U*

```javascript

```
