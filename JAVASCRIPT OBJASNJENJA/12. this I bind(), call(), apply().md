# this

OVDE ZELIM DA SE POZABAVIM PODSECANJEM NA LEXICAL SCOPE-A

USTVARI ONO STA ZELIM JESTE

:one: ZELIM I DA PONOVO PROVEZBAM bind(), apply() I call() MEDODE Function-OVOG PROTOTIPA

:two: ZELIM I DA SE PODSETIM STA SE TO DESAVA SA FUNKCIJOM, KOJA JE QUEUED, A KOJA JE DEFINISANA TAKO DA KORISTI this

:three: ZELIM DA VIDIM KAKO TO DEFINISANJE FUNKCIJE, TAKO DA BUDE ARROW UTICE NA this, KOJI TA FUNKCIJA KORISTI

## :one: I call I apply MI OMOGUCAVAJU DA PROSLEDIM OBJEKAT ARGUMENT KOJI PREDSTAVLJA VREDNOST this-A, PRI FUNKCIINE INVOKACIJE

*OBE METODE I call I apply DOZVOLJAVAJU DODAVANJE ARGUMENA FUNKCIJI*

>> RAZLIKA IZMEDJU OVE DVE METODE OGLEDA SE U TOME:

**DA call PRIHVATA NEOGRANICEN BROJ ARGUMENTA, PORED ONOG PRVOG ARGUMENT OBJEKTA, KOJI REPREZENTUJE this**

**DA apply PRIHVATA NIZ (CIJI CLANOVI JESU ARGUMENTI FUNKCIJE), PORED ONOG PRVOG ARGUMENT OBJEKTA, KOJI REPREZENTUJE this**

EVO GA TEST

```javascript

// FUNKCIJA
function metoda(x, y){

    console.log(
        {
            objekatThis: this,
            x,
            y
        }
    )

}

// DVA OBJEKTA

let a = {properti: "alpaka"}
let b = {properti: "gvanaka"}


// SADA TESTIRAM    call   I    apply

/// ******************************* DAKLE JEDINA JE RAZLIKA
//* U TOME KAK OIH POZIVAM, A OVE DVE FUNKCIJE CE PROVIDE-OVATI ISTI OUTCOME

metoda.call(a, 1, 2);
metoda.apply(b, [1, 2]);

```
