<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta name="theme-color" content="#e24c60;">
        <title>IntersectionObserver</title>
        <!-- <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> -->

        <link rel="stylesheet" type="text/css" href="/styles.css">
    </head>
    <body>

        <div class="parent">
            <div></div>
            <div>
                
            </div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div>
                
            </div>
            <div></div>
        </div>

        <style>
            div.parent {
                border: currentColor solid 1px;
                width: 38vw;
                height: 68vh;
                overflow-y: scroll;
            }

            div.parent div {
                box-sizing: border-box;
                border: 2px tomato solid;
                width: 100%;
                height: 30%;
                margin: 5% 0;
            }

            div.parent:nth-last-of-type(2){
                background-color: tomato;
                outline: olive dashed 58px;
            }

        </style>

        <script defer>
            const options = {
                root: document.querySelector('div.parent'),
                rootMargin: '58px',
                threshold: 0.9
            };

            const inObs = new IntersectionObserver(function(entries, observer){
                if(entries[0].intersectionRatio > 0){
                    // console.log(entries);
                    // console.log(observer);
                }else{
                    // console.log('none');
                    // console.log(entries);
                }
            }, options);

            const item = document.querySelector('div.parent div:nth-last-of-type(2)')

            inObs.observe(item);
            inObs.unobserve(item)
        
        </script>
        
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>
        <br>

        <div class="susedAbso">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
        <div class="ancestor">
            <div></div>
            <div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div></div>
        </div>

        <style>

            div.susedAbso {
                width: 54vw;
                height: 74vh;
                position: relative;
                top: calc(74vh + 4px);
                left: 20%;
                z-index: -1;
            }

            div.susedAbso div {
                height: 10%;
                border: dotted 2px rgb(185, 88, 129);
                box-sizing: border-box;
            }
        
            div.ancestor {
                border: tomato solid 4px;
                width: 54vw;
                height: 74vh;
                margin: auto;
                padding: 0;
                overflow-y: scroll;
                counter-reset: someCounter;
            }

            div.ancestor > div {
                border: currentColor 1px solid;
                height: 42%;
                margin: 10px 34%;
            }

            div.ancestor > div:nth-of-type(2) {
                background-color: olive;
                border-color: aqua;
            }

            div.ancestor > div:nth-last-of-type(2) {
                background-color: crimson;
                border-color: blanchedalmond;
            }

            div.ancestor div div {
                height: 25%;
                border: currentColor 1px dashed;
                box-sizing: border-box;
                position: relative;
            }

            div.ancestor > div:not(:nth-of-type(2)):not(:nth-last-of-type(2)) {
                counter-reset: someCounter;
            }
            
            div.ancestor div div::after {
                content: counter(someCounter) "%";
                counter-increment: someCounter 25;
                position: absolute;
                top: 100%;
                left: -18%;
            }
        
        </style>

        <script>
            const obsOptions = {
                root: document.querySelector('div.ancestor'),
                rootMargin: '-10%',
                threshold: [0.25, 0.50, 0.75, 1]
            }

            const intersectionObserverInstance = new IntersectionObserver(function(entries, observerOb){
                if(entries[0].intersectionRatio > 0){
                    // console.log(entries);
                }else{

                }
            }, obsOptions);

            // console.log(intersectionObserverInstance);

            intersectionObserverInstance.observe(document.querySelector('div.ancestor > div:nth-of-type(2)')) 
            intersectionObserverInstance.observe(document.querySelector('div.ancestor > div:nth-last-of-type(2)')) 
        
        </script>

        <div class="info">Downthere, I'm observing intersection of left parent and one of his children
        <br>
        Also I'm observing intersection of right parent and one of his children
        <br>
        Move scrollbar of both elements, for some time while looking waht is happening
        </div>
        <!-- OVAJ ELEMENT, CE SLUZITI SAMO DA PREKLOPI SLEDECI (TAKO CU GA POZICIONIATI)
        KAKO BI PREDSTAVLJAO NEKAKAV GRID PREKO SLEDCA DVA ELEMENTA -->
        <div class="relPozSusedPreko">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
        <div class="showValues">
            <div>intersectionRatio for olive: <span></span></div>
            <div>intersectionRatio for crimson: <span></span></div>
        </div>
        <!--POSMATRACU INTERSECTION IZMEDJU FATHER-A, DRUGOG CHILDA-->
        <div class="father">
            <div></div>
            <div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
         <!--POSMATRACU INTERSECTION IZMEDJU MOTHER-A, I DRUGOG OD POZADI CHILDA-->
        <div class="mother">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div></div>
            <div>
                <div></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div></div>
        </div>

        <style>

            body, html {
                scroll-behavior: smooth;
            }

            div.info {
                font-size: 2.8em;
            }

            div.showValues {
                height: 60px;
                box-sizing: border-box;
                border: outset rosybrown 10px;
                width: 88vw;
            }

            div.showValues div {
                display: inline-block;
                width: calc(50% - 18px);
                padding-left: 14%;
                box-sizing: border-box;
                font-size: 1.6em;
            }
            
            div.showValues div span {
                color: purple;
            }

            div.relPozSusedPreko {
                width: 88vw;
                height: 74vh;
                position: relative;
                top: calc(74vh + 4px + 60px);
                z-index: -1;
            }

            div.relPozSusedPreko div {
                height: 10%;
                border: dotted 2px transparent;
                box-sizing: border-box;
            }

            div.relPozSusedPreko div:first-child {
                border-bottom-color: rgb(170, 27, 51);
                border-bottom-style: dashed;
            }
            
            div.relPozSusedPreko div:nth-child(2) {
                border-top-style: none;
            }
            div.relPozSusedPreko div:last-child {
                border-top-color: rgb(170, 27, 51);
                border-top-style: dashed;
            }
            
            div.relPozSusedPreko div:nth-last-child(2) {
                border-bottom-style: none;
            }
            
            div.relPozSusedPreko div:nth-child(2)::before,  div.relPozSusedPreko div:nth-last-child(2)::before {
                display: block;
                content: "-10% is rootMargin";
                width: min-content;
                margin-left: 52%;
            }

            div.relPozSusedPreko div:nth-last-child(2)::before {
                margin-top: 80px;
            }


            div.father, div.mother {
                border: tomato solid 4px;
                width: 44vw;
                height: 74vh;
                margin: auto;
                padding: 0;
                overflow-y: scroll;
                counter-reset: someCounter;
                display: inline-block;
            }

            div.father > div, div.mother > div {
                border: orange 4px solid;
                height: 38%;
                margin: 10px 24%;
            }

            div.father > div:nth-of-type(2) {
                background-color: olive;
                border-color: aqua;
                counter-reset: someCounter 100;
            }

            div.mother > div:nth-last-of-type(2) {
                background-color: crimson;
                border-color: blanchedalmond;
                counter-reset: someCounter 0;
            }

            div.father div div,  div.mother div div {
                height: 25%;
                border: currentColor 1px dashed;
                box-sizing: border-box;
                position: relative;
            }
            
            div.father div div::after, div.mother div div::after {
                content: counter(someCounter) "%";
                position: absolute;
                top: 100%;
                left: -18%;
                color: rgb(11, 12, 9);
                font-weight: 800;
                font-size: 1.1em;
            }

            div.father div div::after {
                counter-increment: someCounter -25;
            }

            div.mother div div::after {
                counter-increment: someCounter 25;
            }

            div.father div.almonding {
                background-color: blanchedalmond;

            }
            
            div.mother div.almonding {
                background-color: blanchedalmond;

            }

        </style>

        <script defer>
            setTimeout(function(){ scrollTo(0, document.documentElement.scrollHeight)}, 2000);

            const state = {
                almondedElementOlive: null,
                almondedElementCrimson: null
            };

            const spanOliveRat = document.querySelector('div.showValues div:first-child span');
            const spanCrimsonRat = document.querySelector('div.showValues div:last-child span');
            const olive = document.querySelector('div.father > div:nth-of-type(2)');
            const crimson = document.querySelector('div.mother > div:nth-last-of-type(2)');

            const optionsOlive = {
                root: document.querySelector('div.father'),
                rootMargin: '-10%',
                threshold: [0.25, 0.50, 0.75, 1]
            }
            
            const optionsCrimson = {
                root: document.querySelector('div.mother'),
                rootMargin: '-10%',
                threshold: [0.25, 0.50, 0.75, 1]
            }

            const oliveInObs = new IntersectionObserver(function(entries, observer){

                // console.log(entries[0]);

                spanOliveRat.textContent = entries[0].intersectionRatio.toFixed(2);


                if(entries[0].intersectionRatio > 0 && entries[0].intersectionRatio < 0.25){
                    const deepElement = entries[0].target.querySelector('div:nth-of-type(4)');
                    if(state.almondedElementOlive){
                        state.almondedElementOlive.classList.remove('almonding');
                    }
                    deepElement.classList.add('almonding');
                    state.almondedElementOlive = deepElement;
                }
                if(entries[0].intersectionRatio > 0.25 && entries[0].intersectionRatio < 0.50){
                    const deepElement = entries[0].target.querySelector('div:nth-of-type(3)');
                    if(state.almondedElementOlive){
                        state.almondedElementOlive.classList.remove('almonding');
                    }
                    deepElement.classList.add('almonding');
                    state.almondedElementOlive = deepElement;
                }
                if(entries[0].intersectionRatio > 0.50 && entries[0].intersectionRatio < 0.75){
                    const deepElement = entries[0].target.querySelector('div:nth-of-type(2)');
                    if(state.almondedElementOlive){
                        state.almondedElementOlive.classList.remove('almonding');
                    }
                    deepElement.classList.add('almonding');
                    state.almondedElementOlive = deepElement;
                }
                if(entries[0].intersectionRatio > 0.75 && entries[0].intersectionRatio < 1){
                    const deepElement = entries[0].target.querySelector('div:nth-of-type(1)');
                    if(state.almondedElementOlive){
                        state.almondedElementOlive.classList.remove('almonding');
                    }
                    deepElement.classList.add('almonding');
                    state.almondedElementOlive = deepElement;
                }
            }, optionsOlive);

            const crimsonInObs = new IntersectionObserver(function(entries, observer){

                // console.log(entries[0]);

                spanCrimsonRat.textContent = entries[0].intersectionRatio.toFixed(2);


                if(entries[0].intersectionRatio > 0 && entries[0].intersectionRatio < 0.25){
                    const deepElement = entries[0].target.querySelector('div:nth-of-type(1)');
                    if(state.almondedElementCrimson){
                        state.almondedElementCrimson.classList.remove('almonding');
                    }
                    deepElement.classList.add('almonding');
                    state.almondedElementCrimson = deepElement;
                }
                if(entries[0].intersectionRatio > 0.25 && entries[0].intersectionRatio < 0.50){
                    const deepElement = entries[0].target.querySelector('div:nth-of-type(2)');
                    if(state.almondedElementCrimson){
                        state.almondedElementCrimson.classList.remove('almonding');
                    }
                    deepElement.classList.add('almonding');
                    state.almondedElementCrimson = deepElement;
                }
                if(entries[0].intersectionRatio > 0.50 && entries[0].intersectionRatio < 0.75){
                    const deepElement = entries[0].target.querySelector('div:nth-of-type(3)');
                    if(state.almondedElementCrimson){
                        state.almondedElementCrimson.classList.remove('almonding');
                    }
                    deepElement.classList.add('almonding');
                    state.almondedElementCrimson = deepElement;
                }
                if(entries[0].intersectionRatio > 0.75 && entries[0].intersectionRatio < 1){
                    const deepElement = entries[0].target.querySelector('div:nth-of-type(4)');
                    if(state.almondedElementCrimson){
                        state.almondedElementCrimson.classList.remove('almonding');
                    }
                    deepElement.classList.add('almonding');
                    state.almondedElementCrimson = deepElement;
                }
            }, optionsCrimson);

            oliveInObs.observe(olive);
            crimsonInObs.observe(crimson);

        </script>

        <h1>Naslov neki</h1>
        
        <script>
            
            let CACHE_NAME = 'page-cache-v1';

            let url = '/styles.css';

            /* window.fetch(url)
            .then(function(response){

                window.caches.open(CACHE_NAME)
                .then(function(cache){
                    cache.put(url, response)
                    .then(function(){

                        setTimeout(function(){
                            console.log(cache.keys());
                        }, 3800);

                    })
                })

            }).catch(function(err){
                console.log(err);
            }) */


            


            // OVAKVU INSTANCU ZELIM DA DODELIM KAO SOURCE ARGUMENT (NE PRVI ARGUMENT), Object.assign METODE (PRVI ARGUMENT SE NAZIVA TARGET-OM)

            class Stvari {
                constructor(){
                    // PROPERTIJI
                    this.magla = "toblerone";
                    this.pegla = "bananologija";
                    this.edamer = "nije sir vec polimerna plastika";
                    this.sunka = "toblerone drugi put";
                    this.dembelija = "bila jednom jedna zemlja";
                    this.za_procjedit = "suva drenovina";

                    // OVO SU METODE, KOJE SU 'DIREKTNE METODE' Stvari INSTANCE
                    // OVE METODE NISU METODE 
                    this.cedjenje = function(){
                        console.log(this.za_procjedit);
                    }
                    
                    this.sunkanje = function(){
                        console.log(this.sunka);
                    }
                }

                // OVE METODE SU METODE Stvari-OVOG PROTOTIP OBJEKTA
                // DAKLE METODE     Stvari.prototype 
                // KOJE CE NASLEDITI SVAKA Stvari INSTANCA
                piskaranje(){
                    console.log(this.magla);
                }

                miksovanje(){
                    console.log(this.edamer);
                }

                // ALI OVE DVE METODE SU USTVARI METODE
                // ZATO STO PREDPOSTAVLJAM DA OVAKVO KORISCENJE ARROW FUNKCIJE, USTVARI RADI SLEDECE U
                // PRIKAZANOM GORNJEM KONSTRUKTORU:     this.tetrebovanje = this.tetrebovanje.bind(this)
                // NIJE VAZNO ZA OVO ALI ZASTO SAM KORISTIO bind, PA AKO METODA BUDE PROMENILA CONTEXT 
                // (NARAVNO OVO ZA OVU LEKCIJU NIJE BITNO, ALI CISTO NAPOMINJEM, AKO ZABORAVIM)
                // BITNO JE DA ZNAM DA SU SLEDECE METODE POSTALE DIREKTNE METODEDE INSTANCI
                // ODNOSNO, JOS PRECIZNIJE, U INSTANCINOM PROTOTIPU CE I DALJE POSTOJATI OVE METODE, ALI SU
                // OVE METODE ISTO AUTOMATSKI DEFINISU U INSTANCI, CIME OVERRIDE-UJU PROTOTIPOVE ISTOIMENE
                // METODE
                tetrebovanje = () => {
                    console.log(this.dembelija);
                }

                pregledanje = () => {
                    console.log(this.pegla);
                }
            }

            // OVO JE KLASA OBJEKTA, U CIJU INSTANCU CU, KASNIJE 'UGRADITI MIXIN'
            // MOZDA SAM NEJASAN, KADA U KOLOKVIJALNO KAZEM 'UGRADITI'
            // ONO STO CU USTVARI URADITI, JESTE DA CU METODE I PROPERTIJE SOURCE OBJEKTA, PREKOPIRATI U 
                                                    //  PROTOTIP OBJEKAT Burmut INSTANCE
            class Burmut {
                constructor(){
                    this.edamer = "bar je bolji od gaude, koja je od pvc-a";
                    this.pegla = "baci toblerone, dobices secer";
                    this.sunka = "podrigivanje samo kulturno";
                }

                // NISU MI BITNE NIKAKVE METODE
                // DA IMAM BILO KAKVE METODE, KOJE BIH DEFINISAO
                // AKO SU ISTOIMENE SA ONIMA IZ PROTOTIPA, ILI ONIMA KOJE JE 'UVEO MIXIN'
                // JASNO JE DA BI BILE OVERRIDEN TE METODE CIJEJE POREKLO PROTOTIP ILI MIXIN
                // (PROIZILAZI IZ ODLIKE OBJEKATA I PROTOTYPING-A)
            }

            // INSTATICIZIRANJE, NAKON CEGA CU I POZVATI I Object.assign METODU
            const burmutInstanca = new Burmut(); // OBJEKAT, CIJI CE PROTOTIP BITI TARGET OBJEKAT
                                                 // TARGET OBJEKAT JE PRVI ARGUMENT Object.assign METODE
                                                 // TAJ PROTOTIP OBJEKAT, TREBA DA DOBIJE SVE METODE I PROPERTIJE
                                                 // Stvari INSTANCE, KOJA CE BITI SOURCE OBJEKAT, A TO JE DRUGI ARGUMENT

                                    // NARAVNO, MOZE BITI BILO KOJI BROJ SOURCE OBJEKATA, KOJI OSTAJU NA KRAJU NEPROMENJENI
                                    // SAMO TARGET OBJEKAT MOZE BITI 

                                // KAKO FUNKCIONISE ASSIGN

                                // MOJIM KOLOKVIJALNIM JEZIKOM:
                                            // DESAVA SE LANCANO KOPIRANJE, ODNOSNO OVERWRITE-OVANJE OD POSLEDNJEG ARGUMENT OBJEKTA 
                                            // KA PRVOM

                                            // A NA KRAJU SAMO PRVI ARGUMENT BIVA PROMENJEN, ODNOSNO SAMO NJEGOVI PROPERTIJI I
                                            // METODE BIVAJU PROMENJENI

            let stvariInstanca = new Stvari();
            
            /////////////////////////////////////////////////////////
            // FORMIRANJE MIXIN-A, POZIVANJEM Object.assign METODE
            Object.assign(burmutInstanca.__proto__, stvariInstanca);
            ////////////////////////////////////////////////////////
            
            // PRIMENA METODA NAD Burmut INSTANCI

            // OVO JE METODA Stvari INSTANCE (DIREKTNA METODA)
            burmutInstanca.sunkanje();                                          // --> "podrigivanje samo kulturno"
            // OVO JE METODA SA BINDED this-OM (ISTO METODA Stvari INSTANCE)
            burmutInstanca.pregledanje();                                       // --> "bananologija"

            //burmutInstanca.piskaranje();    // --> ERROR (Burmut INSTANCA NE NASLEDJUJE METODE OD MIXINOVOG PROTOTIPA)
                                                        // (JA MIXIN-OV PROTOTIP NISAM PROSLEDIO)
         ///////////////////////////////////////////////////////////////////////////////////////
            //////// MOJA Object.assign METODA //////////////////
            // SA JEDNOM RAZLIKOM STO SE OVA METODA PRIMENJUJE NA TARGET OBJEKTU, A TARGET NIJE NJEN ARGUMENT
            Object.prototype.myAssign = function(...sources){
                if(typeof this !== 'object'){
                    throw new TypeError("Target ain't an object");
                }else{
                    for(let source of sources){
                        if(typeof source !== 'object'){
                            throw new TypeError("Found non object among source arguments");
                        }else{
                            for(let property in source){
                                this[property] = source[property];
                            }
                        }
                    }
                }
            };
         ///////////////////////////////////////////////////////////////////////////////////////////////////

         // ISKORISTICU ISTE INSTANCE, KAKO BI FORMIRAO MIXIN, ALI OVOG PUTA SA MOJOM METODOM

         const burmutInstanca2 = new Burmut();
         const stvariInstanca2 = new Stvari();

         // PRAVLJENJE MIXIN-A
        burmutInstanca2.__proto__.myAssign(stvariInstanca2);
        
        burmutInstanca2.sunkanje();
        burmutInstanca2.pregledanje();
        //burmutInstanca2.piskaranje();

            let target = {ahmed: 200, ricardo: 800}

            let s1 = {ahmed: 'neka rec', ricardo: 'opet ricy', zemicka: 'iz pekare', pereca: 'iz zlatare'};

            s1.__proto__.stampaj = function(){
                console.log(this.ahmed);
                console.log(this.ricardo);
                console.log(this.zemicka);
                console.log(this.pereca);
            }


           // target.__proto__.myAssign(s1);


            let target2 = {ahmed_johnny: 200, ricardo_bronson: 800}

            let s2 = {ahmed_johnny: 'neka rec', ricardo_bronson: 'opet ricy', zemicka: 'iz pekare', pereca: 'iz zlatare'};


            Object.assign(target2.__proto__, s2);




        </script>

        
        <script src="/main.js"></script>
    </body>
</html>
