# IMPORT-OVANJE I KORISCENJE idb LIBRARY-JA (KOJI SE ZASNIVAN IndexedDb-JU) U ServiceWorkerGlobalScope

## PRE NEGO STO BILO STA KAZEM TREBAO BI SAMO DA SE PODSETIM ONOG DELA IMPLEMENTACIJE PRINCIPA CACHE THEN NETWORK, U SCRIPT-U, KOJI JE POVEZAN SA MOJIM PAGE-OM, U SLUCAJU MOG APP-A

FAJL feed.js

```javascript

const updateUi = function(dataObject){
    destroyOldCards();
    // ZAPAMTI DA JE DATA KOJE STIZE OD SERVERA USTVARI posts OBJEKAT

    for(data in dataObject){

        // NA OVAJ NACIN , POMENUTOJ createCard FUNKCIJI KAO ARGUMENT DODAJEM JEDAN OD POSTOVA

        createCard(dataObject[data]);

        // ZA SLUCAJ first-post, ONO STO SE DODAJE KAO ARGUMENT JESTE posts['first-post']
        // JA CU USTVARI U FIREBASE-U, DODATI, JOS NEKOLIKO POSTOVA
    }

};

let networkRponseIsHere = false;

// OVO JE URL (KREIRAO SAM GA FIREBASE-OM) (I SAV JSON RESPONSE SAM KREIRAO, A TO SAM VEC OBJASNIO)
// (OBJASNJENJE JE U 'FIREBASE' FOLDERU (NALAZI SE KAO PODFOLDER 'IMPORTANT PWA NOTES' FOLDERA))

fetch('https://instapwaclone.firebaseio.com/posts.json')
.then(function(response){
    return response.json()
})
.then(function(data){

    console.log(data);

    networkRponseIsHere = true;
    //POZIVAM NOVU FUNKCIJU, KOJOM MOGU DODATI VISE KARTICA 
    updateUi(data);
})



window.caches.match('https://instapwaclone.firebaseio.com/posts.json')
.then(function(response){

    console.log(response);

    if(response) return response.json();
})
.then(function(data){

    console.log(data);

    if(!networkRponseIsHere && data){      // AKO Response JOS NIJE STIGAO OD NETWORK-A, TRAZIM GA IZ CACHE-A

        // POZIVANJU FUNKCIJE updateUi
        updateUi(data);
    }
})
```

JASNO MI JE DA JE ONO STO SE TREBA ODAVDE UKLONITI JESTE SERVIRANJE IZ CACHE-A, A DA JE ONO STO TREBA PRIMENITI, JESTE SERVIRANJE IZ INDEXIRANE BAZE PODATKA

MEDJUTIM PRVO CU VIDETI, KAKO DA RUKUJEM TOM BAZOM U OBIMI SERVICE WORKER-A, PRILIKOM INTERCEPTION-A NETWORK REQUEST-OVA

## U OBIMU ServiceWorkerGlobalScope-A KORISTIM importScripts, ODNOSNO self.importScripts FUNKCIJU

NA POCETKU SERVICE WORKER CODE-A POZIVAM, POMENUTU FUNKCIJU, KAKO BI UVEZAO JAKE ARCHIBALD PROMISED idb LIBRARY

sw.js FAJL:

```javascript
importScripts('/src/js/idb.js')
```

TAKODJE ZELIM DA CACHE-IRAM POMENUTU BIBLIOTEKAU, KAO STATICKI ASSET

sw.js FAJL:

```javascript

const urls = [
    '/',

    '/index.html',

    '/src/js/app.js',
    '/src/js/material.min.js',

    '/src/js/idb.js',    // EVO GA

    '/src/js/feed.js',

    '/src/css/material.min.css',
    '/src/css/app.css',
    '/src/css/feed.css',

    '/src/css/help.css',

    '/fallback_offline.html',

    '/src/images/mona_lisa.jpg',
    '/manifest.json',
    '/favicon.png',

    'https://fonts.googleapis.com/css?family=Roboto:400,700',

    'https://fonts.googleapis.com/icon?family=Material+Icons',
];
```

## REDEFINISEM CACHING JSON PODATKA, IZ MOG APP-A, KOJI SAM RANIJE CACHE-IRAO U Cache, PO PRINCIPU CACHE THEN NETWORK; ON OSTO ZELIM JESTE DA UMESTO U Cache, JA JSON PODATKE STORE-UJEM U IndexedDB

**RANIJE JE DAKLE onfetch HANDLER IZGLEDAO OVAKO**

```javascript
self.addEventListener('fetch', function(ev) {

    if(ev.request.url.indexOf('https://instapwaclone.firebaseio.com/posts.json') > -1){
        // OVDE SAM ZADAO SAMO U SLUCAJU POMENUTOG URL-A
        // DA SE DINAMICKI CACHIRA RESPONSE, A LI KAO STO SE VIDI, OVDE SE NISTA NE VADI IZ CACHE-A
        // TO SAM DEFINISAO U FAJLU KOJI NIJE SERVICE WORKER
        // OVO JE PO PRISTUPU 'CACHE PA NETWORK'
        ev.respondWith(
            caches.open(DYNAMIC_CACHE)
            .then(function(cache) {
                return fetch(ev.request)
                .then(function(response) {
                    cache.put(ev.request, response.clone());  // KONKRETNO ZELIM DA MENJAM OVAJ RED
                    return response;                          // SVE STO JE ARGUMENT OVOG respondWith-A
                });                                           // JER OVDE KORISTIM CACHE
            })
        );

    }else if(findUrl(ev.request.url)){

        ev.respondWith(
            self.caches.match(ev.request)
        )

    }else{

        ev.respondWith(
            self.caches.match(ev.request)
            .then(function(response){
                if(response){
                    return response;
                }else{
                    return self.fetch(ev.request)
                    .then(function(resp){
                        return self.caches.open(DYNAMIC_CACHE)
                        .then(function(dynamicCache){
                            // trimCache(DYNAMIC_CACHE, 10);
                            dynamicCache.put(ev.request.url, resp.clone());
                            return resp;
                        })
                    })
                    .catch(function(err){

                        if(ev.request.headers.get('accept').includes('text/html')){
                            return caches.open(STATIC_CACHE)
                            .then(function(statCache){
                                return statCache.match('/fallback_offline.html')
                                .then(function(fallbackResp){
                                    return fallbackResp;
                                })
                            })
                        }

                    })
                }
            })
        );

    }

});
```

DAKLE ON OSTO TREBA MENJATI JESTE CACHING, ODNOSNO UMESTO NJEGA KORISTITI IndexedDB

### SADA JE POTREBNO OTVORITI IndexedDB I KREIRATI DATA STORE (KOJI JE U SUSTINI TABELA) U NJOJ

#### ONO STO MORAM OBEZBEDITI JESTE JEDNA VARIJABLA, KOJOJ CU ASSIGN-OVATI idb.open() KAO VREDNOST, A POMENUTOJ METODI, KAO ARGUMENTE DODAJEM ZELJENO IME, KOJE CE PREDSTAVLJATI IME BAZE PODATAKA, I BROJ, KOJI PREDSTAVLJA VERZIJU BAZE PODATAKA, I CALLBAK KAO TRECI ARGUMENT, KOJEM SE PASS-UJE OBJEKAT, KOJI BASIVALLY PREDSTAVLJA, MOJ UBAZU PODATAKA

OVDE VIDIM SLICNOST U METODOLOGIJI, KAO I KOD CACHE-IRANJA

VARIJABLU CU DEFINISATI, ODMAH NAKON oninstall HANDLERA

```javascript
const dbPromise = idb.open('news-store', 1, function(db){

})
```

DAO SAM JOJ IME DA UKAZUJE DA JE TO DATABASE, KOJI CUVA PODATKE ZA NEWS FEED-A, ALI SAM MOGAO ZADATI BILO KOJE IME: 'feed-store', 'posts-store'

#### U OBIMU, POMENUTOG CALLBACK-A, KREIRAM DATA STORE OBJECT, KOJI JE U SUSTINI TABLE; TKO STO POZIVAM db.createObjectStore, SA MOGUCA DVA ARGUMENTA

- PRVI ARGUMENT SE ODNOSI NA IME TABELE (NEKA SE ZOVE 'posts')

- DRUGI ARGUMENT JE OBJEKAT, U KOJEM DEFINISEM KLJUC, UZ POMOC PROPERTIJA keyPath

POMENUTI PROPERTI TREBA DA BUDE KLJUC, UZ POMOC KOJEG SE KASNIJE RETRIEVE THE DATA

DACU MU IME 'id'

PREDPOSTAVLJAM DA JE OVO ZATO, STO SVAKI JSON DATA OBJECKT KOJ ISAM DEFINISAO DA FIREBASE SALJE, USTVARI TAKODJE IMA KARAKTERISTICAN ID (MOZDA GRESIM, ALI PROVERICU)

USTVARI TREBA POGLEDATI MOJE FIREBASE PODATKE KOJI DOLAZE SA SERVERA

U PITANJU JE JEDAN OBJEKAT SA MNOSTVOM PODOBJEKATA U KOJIMA JE DATA

SVAKI OD TIH INDIVIDUALNIH OBJEKATA IMA KARAKTERISTICAN id

**OVO CE DAKLE KREIRATI POMENUTI STORE, ALI ONO STO MI NE TREBA JESTE KREIRANJA STORE-A, SVAKI PUT KADA SE OVAJ SERVICE WORKER THREAD EXECUT-UJE**

POTREBNO JE KREIRANJE STORE-A SAMO JEDNOM I ZATO KREIRAAM USLOVNU IZJAVU, KOJA PROVERAVA DA LI OBJECT STORE POSTOJI, A AKO POSTOJI NECU KREIRATI, TAJ OBJECT STORE

USLOV CE ZAVISITI OD db.objectStoreNames NIZA ,NDA KOJIM MOGU PRIMENITI METODU contains

```javascript
const dbPromise = idb.open('news-store', 1, function(db){

    if(!db.objectStoreNames.contains('posts')){

        db.createObjectStore('posts', {keyPath: 'id'})

    }

})
```

## POSTO SAM OTVORIO IndexedDB I POSTO SAM KREIRAO NOVI STORE OBJECT, MOGU U MOM PROJEKTU ZAMENITI CACHE-IRANJE (CACHE THAN NETWORK PRINCIPOM), SA STORING-OM U INDEKSIRANU BAZU PODATAKA

```javascript
self.addEventListener('fetch', function(ev) {

    if(ev.request.url.indexOf('https://instapwaclone.firebaseio.com/posts.json') > -1){

        ev.respondWith(

            // OVO JE DAKLE ONO STO MI VISE NIJE POTREBNO

            /* caches.open(DYNAMIC_CACHE)
            .then(function(cache) {
                return fetch(ev.request)
                .then(function(response) {

                    cache.put(ev.request, response.clone());
                    return response;

                });
            }) */

        );

    }else if(findUrl(ev.request.url)){

        ev.respondWith(
            self.caches.match(ev.request)
        )

    }else{

        ev.respondWith(
            self.caches.match(ev.request)
            .then(function(response){
                if(response){
                    return response;
                }else{
                    return self.fetch(ev.request)
                    .then(function(resp){
                        return self.caches.open(DYNAMIC_CACHE)
                        .then(function(dynamicCache){
                            // trimCache(DYNAMIC_CACHE, 10);
                            dynamicCache.put(ev.request.url, resp.clone());
                            return resp;
                        })
                    })
                    .catch(function(err){

                        if(ev.request.headers.get('accept').includes('text/html')){
                            return caches.open(STATIC_CACHE)
                            .then(function(statCache){
                                return statCache.match('/fallback_offline.html')
                                .then(function(fallbackResp){
                                    return fallbackResp;
                                })
                            })
                        }

                    })
                }
            })
        );

    }

});
```

### POSTO KORISTIM PRINCIP CACHE THEN NETWORK, POTREBNO JE DA ZAPOCNEM TIME DA CE ARGUMENT respondWith METODE, BITI fetch ZA ISTIM RESURSOM

DAKLE OPET CU CHAIN-OVATI Promise-E

DAKLE CHAIN-UJEM then METODU NA fetch POZIV

#### POTREBNO JE DA U OBIMU then-OVOG CALLBACK-A RETURN-UJEM ORIGINALNI RESPONSE, CIME SU PODACI OD NETWORKA SERVIRANI

#### MEDJUTIM PRE TOGA JE POTREBNO DA KLONIRAM OVAJ RESPONSE, KAKO BIH GA MOGAO KORISTITI, ODNOSNO TRANSFORMISATI, A TAKVE PODATKE JE POTREBNO UBACITI U OBJECT STORE

ZASTO SAM REKAO TRANSFORMISANI?

PA ZATO STO MOGU PULLOVATI OUT, DATA I STORE-OVATI ONE PODATKE KOJE ZELIM

ZATO UPRAVO ND KLONIRANIM RESPONSE-OM PRIMENJUJEM

- json() METODU, KOJA I SAMA RETURN-UJE Promise INSTANCU, ALI STI MSTO JE TA Promise INSTANCA RESOLVED SA JAVASCRIPT OBJEKTOM  U JSON FORMATU, I IZ KOJEG ONDA MOGU EXTRACT-OVATI PODATKE

```javascript
self.addEventListener('fetch', function(ev) {

    // BOLJE DA OVDE IMAM VARIJABLU, KOJA IMA url KAO VREDNOST
    const firebaseUrl = 'https://instapwaclone.firebaseio.com/posts.json';

    if(ev.request.url.indexOf(firebaseUrl) > -1){

        ev.respondWith(
            // OPET FETCH-UJEM
            fetch(firebaseUrl)
            .then(function(response){

                // KLONIRAM RESPONSE, I ZELIM JSON DATA FROM THAT RESPONSE
                response.clone().json()
                .then(function(data){
                    // !!!!! SADA MORAM DA ODLUCIM STA CU SA PODACIMA, ODNOSNO KAKO DA IH STAVIM I STA OD NJIH DA STAVIM U INDEKSIRANU BAZU PODATAKA
                })

                // ORIGINALNI RESPONSE JE SERVIRAN
                return response;
            })

        );

    }else if(findUrl(ev.request.url)){

        ev.respondWith(
            self.caches.match(ev.request)
        )

    }else{

        ev.respondWith(
            self.caches.match(ev.request)
            .then(function(response){
                if(response){
                    return response;
                }else{
                    return self.fetch(ev.request)
                    .then(function(resp){
                        return self.caches.open(DYNAMIC_CACHE)
                        .then(function(dynamicCache){
                            // trimCache(DYNAMIC_CACHE, 10);
                            dynamicCache.put(ev.request.url, resp.clone());
                            return resp;
                        })
                    })
                    .catch(function(err){

                        if(ev.request.headers.get('accept').includes('text/html')){
                            return caches.open(STATIC_CACHE)
                            .then(function(statCache){
                                return statCache.match('/fallback_offline.html')
                                .then(function(fallbackResp){
                                    return fallbackResp;
                                })
                            })
                        }

                    })
                }
            })
        );

    }

});
```

## POSTO SAM OOBEZBEDIO PODATKE, POTREBNO JE DA VIDIM, KAKO TO DA IH STORE-UJEM U INDEKSIRANU BAZU PODATAKA, ODNOSNO KAK ODA IH TRANSFORMISEM, ODNOSNO KAK ODA UZMEM SAMO ONO STO MI JE POTREBNO I STORE-UJEM ILI DA STORE-UJEM SVE

POTREBNO JE DA OPET BACIM POGLED NA CODE feed.js FAJLA

**feed.js**

```javascript

// !!!!!!! OBRATI PAZNJU, ODNOSNO SETI SE DA PODACI, KOJ ISU PARSED (JSON) -----> posts OBJEKAT

// SVAKI OD PROPERTIJA PREDSTAVLJA OBJEKAT KOJI IMA KARAKTERISTICNE PODATKE NAMENJENE ZA
// KARAKTERISTICAN POST, ODNOSNO ARTICLE NA MOJOJ STRANICI
/*
       {
           id: "first-post", 
           image: "https://firebasestorage.googleapis.com/v0/b/ins...",
           location: "In Limassol",
           title: "good time to visit Limassol"
        }
 */

    // I ONO STO JE NAJBITNIJE U OVOM SLUCAJU JESTE POMENUTI id JER SAM UPRAVO ZBOG NJEGA KREIRAO
    // POMENUTI OBJECT STORE U 'news-store' INDEKSIRANOM DATABASE-U

   //    'news-store' DATABASE JE UPRAVO STVOREN DA  STORE-UJE 'posts' OBJEKAT

// OVU FUNKCIJU SAM TACNO DEFINISAO, KAKO BI CONSUME-OVALA JASON PODATKE I KAOKI ONDA TE PODATKE
// PROSLEDILA FUNKCIJI, KOJA PRAVI ELEMENTE, I POPULATE-UJE ELEMENT PODACIMA, BILI ONI POSLATI
// DIREKTNO SA SERVERA ILI IZ CACHE-A, ILI IZ INDEKSIRANE BAZE PODATKA, KOJA MENE TRENUTNO ZANIMA

const updateUi = function(dataObject){
    destroyOldCards();

    // MOZDA JE MALO ZBUNJUJUCA OVA for in LOOP, ZATO STO SLUZI ZA KORACNO PRISTUPANJE
    // PROPERTIJIM NEKOG OBJEKTA, ALI VIDIM DA SE PR

    for(let propName in dataObject){    // NAMERNO SAM VARIAJBLOJ ZADO IME propName , ZATO STO ONA UPRAVO TO I SKLADISTI

        createCard(dataObject[propName]);

        // ZA SLUCAJ first-post, ONO STO SE DODAJE KAO ARGUMENT JESTE posts['first-post']
        // JA CU USTVARI U FIREBASE-U, DODATI, JOS NEKOLIKO POSTOVA
    }

};

let networkRponseIsHere = false;

fetch('https://instapwaclone.firebaseio.com/posts.json')
.then(function(response){
    return response.json()
})
.then(function(data){

    console.log(data);

    networkRponseIsHere = true;
    //POZIVAM NOVU FUNKCIJU, KOJOM MOGU DODATI VISE KARTICA 
    updateUi(data);
})



window.caches.match('https://instapwaclone.firebaseio.com/posts.json')
.then(function(response){

    console.log(response);

    if(response) return response.json();
})
.then(function(data){

    console.log(data);

    if(!networkRponseIsHere && data){      // AKO Response JOS NIJE STIGAO OD NETWORK-A, TRAZIM GA IZ CACHE-A

        // POZIVANJU FUNKCIJE updateUi
        updateUi(data);
    }
})
```

**DOBRO KADA SAM SVE UTVRDIO, MOGU SE VRATITI NA DEFINISANJE STAVLJANJA U INDEKSIRANU BAZU PODATAKA**

## U OBIM then-OVOG CALLBACKA (REC JE O POMENUTOM then-U, KOJI JE CHAINED NA response.json() METODU) STAVICU ISTI ONAKAV for-in LOOP, KAKAKV SAM KORISTIO U GORNJEM CODE-U, I KOJI SAM ZNATNO OBJASNIO; A U TOM LOOP

- NARAVNO SACUVAO SAM Promise, KOJI JE RESOLVED SA INDEKSIRANOM BAZOM PODATAK (REC JE O Promise-U, KOJI REFERENCIRA **dbPromise** VARIJABLA) (TAJ ASSINGMENT SAM IZVRSIO NA POCETKU, ODNOSNO NAKON oninstall HANDLER-A)

KADA IMAM TAJ Promise MOGU CHAINOVATI, NA NJEGA then, KAKO BI U OBIMU NJEGOVOG CALLBACK-A DEFINISAO

```javascript
self.addEventListener('fetch', function(ev) {

    const firebaseUrl = 'https://instapwaclone.firebaseio.com/posts.json';

    if(ev.request.url.indexOf(firebaseUrl) > -1){

        ev.respondWith(

            fetch(firebaseUrl)
            .then(function(response){

                response.clone().json()
                .then(function(data){
                    // NA POMENUTOM Promise-U, KOJI REFERENCIRA dbPromise VARIJABLA PRIMENJUJEM then
                    // A U OBIMU, NJEGOVOG CALLBACK-A, NAD INDEXIRANOM BAZOM, KOJA JE PROSLEDJENA
                    // (DAO SAM JOJ IME 'news-store', PRILIKOM NJENOG OTVARANJA)

                    // NARAVNO, POTREBNO JE OBET PRISTUPATI, SVIM LJUCEVIMA
                    for(let key in data){
                        // DFAKLE, PO JEDAN CHAINING then-A
                        // ZA SVAKI OBJECT STORE
                        dbPromise.then(function(db){

                            // ZA PISANJE PODATKA U BAZU PODATKA MORAM KREIRATI TRANSACTION

                            // REKAO SAM RANIJE DA IndexedDB IMA NESTO STO SE ZOVE

                                    //          TRANSACTIONAL OPERATION MODULE

                            // DAKLE MORAM KORISTITI TRANSACTION DA BI RADIO BILO STA SA DATABASE-OM

                            // TO RADIM PRIMENOM
                                                    //          transaction        METODE NAD BAZOM PODATAKA


                            // POMENUTA METODA ZAHTEVA DVA ARGUMENTA

                                        //   -----        STRING IMENA OBJECT STORE-A
                                        //                (OVIM USTVARI DEFINISEM, KOJI OBJECT STORE ZELIM DA
                                        //                TARGETUJEM SA TRANSACTION-OM)

                                        //   -----        DRUGIM ARGUMENTOM SE DEFINISU TIP TRANZAKCIJE
                                        //                NEKE MOGUCE VREDNOSTI SU: "readonly" ILI
                                        //                "read-write"

                                // NARAVNO JA CU DEFINISATI 'readwrite', JER ZELIM DA DA WRITE-UJEM U
                                // DATABASE, SAM READING BI BIO USELESS

                            let transaction = db.transaction('posts', 'readwrite');

                            // SLEDECE STO MORAM DEFINISATI JESTE STORING

                            // PRIMENJUJEM          objectStore             METODU, NAD TRANSACTION-OM

                                // OVO MALO IZGLEDA CUDNO
                                    // ALI ONO STA RADIM JESTE PRVO KAZEM STA ZELIM DA TARGET-UJEM
                                    // PA ONADA EKSPLICITNO OTVARAM OBJECT STORE

                            let store = transaction.objectStore('posts');

                            // SADA TO MOGU KORISTITI DA STAVIM NESTO U STORE

                            // METODA KOJU MOGU KORISTITI NAD OBJECT STORE-OM JESTE
                            //                                                          put     METODA

                                                                                    // POSTOJE I NEKE DRUGE
                                                                                    // METODE, KIIAO STO SU
                                                                                    //          get
                                                                                    // I JOS NEKE DRUGE
                                                                                    // METODE
                                                                                    // SADA STAVLJAM U BAZU I
                                                                                    // ZATO KORISTIM
                                                                                    //                  put

                            // ONO STO STAVLJAM JESTE KLJUC
                            // OPET POGLEDAJ
                            // KAKVA JE STRUKTURA JSON ODGOVORA SA SERVERA
                                                                                        /*
                            {
                                first-post: {id: "first-post"}
                                second-post {...}
                                ...
                            }

                                                                                        */

                            // VRATI SE GDE SI DEFINISAO KREIRANJE OBJECT STORE, I SETI SE DA SI TAMO
                            // ZADAO       'id'      KAO VREDNOST ZA        keyPath

                            // E TOM        keyPath-U       SAM ZADAO "id" KAO VREDNOST

                            // SADA PROSLEDJUJEM     "id"      KAO VREDNSOT, KAKO BI PRISTUPIO
                            // CURRENT OBJECT-U (KONKRETNOM OBJECTU NUMERACIJE)

                            store.put(data[key]);

                            // NE ZABORAVI DA SI U      for-in          LOOP-U

                            // MORAS SVAKI PUT ZATVORITI TRANZAKCIJU ZA SVAKI OBJECT STORE

                            // TO RADIS TAK OSTO RETURN-UJES            complete
                            //                                                              PROPERTI

                            return transaction.complete;

                            // DAKLE NIJE U PITANJU METODA, VEC JE U PITANJU PROPERTI, KOJI
                            // return-UJEM U OBIMU, then-OVOG CURRENT CALLBACK-A

                        })

                    }

                })

                return response;
            })

        );

    }else if(findUrl(ev.request.url)){

        ev.respondWith(
            self.caches.match(ev.request)
        )

    }else{

        ev.respondWith(
            self.caches.match(ev.request)
            .then(function(response){
                if(response){
                    return response;
                }else{
                    return self.fetch(ev.request)
                    .then(function(resp){
                        return self.caches.open(DYNAMIC_CACHE)
                        .then(function(dynamicCache){
                            // trimCache(DYNAMIC_CACHE, 10);
                            dynamicCache.put(ev.request.url, resp.clone());
                            return resp;
                        })
                    })
                    .catch(function(err){

                        if(ev.request.headers.get('accept').includes('text/html')){
                            return caches.open(STATIC_CACHE)
                            .then(function(statCache){
                                return statCache.match('/fallback_offline.html')
                                .then(function(fallbackResp){
                                    return fallbackResp;
                                })
                            })
                        }

                    })
                }
            })
        );

    }

});
```

## MOGU SADA DA OCISTIM STORAGE, POTPUNO U CHROME DEV TOOLS-U, NAKON STO RUNN-UJEM http-server, PA ONDA MOGU POSMATRATI STA SE DOGADJA SA DATABASE-OM, NARAVNO UZ CELU PROCEDURU KOJA IDE KADA SE UPDATE-UJE ServiceWorker

ALI PRVO DA PRIKAZEM SAV CODE SERVICE WORKERA GDE CU OZNACITI SVE ONO STO IMA VEZE SAD IndexedDB-JEM

```javascript
importScripts('/src/js/idb.js');
// UVEZAO SAM IndexedDB

const STATIC_CACHE = 'page-static-cache-v0';
const DYNAMIC_CACHE = 'page-dynamic-cache-v0';

// OTVARANJE IndexedDb-J I KREIRANJE, NOVOG OBJECT STORE-A
const dbPromise = idb.open('news-store', 1, function(db){

    if(!db.objectStoreNames.contains('posts')){
        // KREIRANJE OBJECT STORE-A
        db.createObjectStore('posts', {keyPath: 'id'})

    }

})

const urls = [
    '/',

    '/index.html',

    '/src/js/app.js',
    '/src/js/material.min.js',
    '/src/js/feed.js',

    '/src/css/material.min.css',

    '/src/js/idb.js',

    '/src/css/app.css',
    '/src/css/feed.css',

    '/src/css/help.css',

    '/fallback_offline.html',

    '/src/images/mona_lisa.jpg',
    '/manifest.json',
    '/favicon.png',

    'https://fonts.googleapis.com/css?family=Roboto:400,700',

    'https://fonts.googleapis.com/icon?family=Material+Icons',
];

const findUrl = function(requestsUrl){

    if(requestsUrl === '/'){return true;}

    const url = new URL(requestsUrl)

    for(let u of urls){
        if(url.pathname === u){
            return true;
        }else{
            continue;
        }
    }

    return false;
}
/////////////////////////////////////////////////////////////////////

/* const trimCache = function(cacheName, max){
    self.caches.open(cacheName)
    .then(function(cache){
        cache.keys()
        .then(function(keys){
            if(keys.length > max){
                // UKLANJAM UVEK PRVI UNOS IZ CACHE-A (ON JE NAJSTARIJI)
                cache.delete(keys[0])
                .then(function(){
                    // REKURZIVNO POZIVAM, JER MOZE BITI, DA CACHE IMA MNOGO VISE UNOSA OD MAKSIMUMA
                    trimCache(cacheName, max);
                })
            }
        })
    })
} */

////////////////////////////////////////////////////////////////////////////////////////////////////////

self.addEventListener('install', function(ev){
    ev.waitUntil(

        self.caches.open(STATIC_CACHE)
        .then(function(cache){
            return urls.map(function(url){

                return self.fetch(url)
                .then(function(response){

                    return cache.put(url, response);

                })

            })
        })
    )
});

self.addEventListener('activate', function(ev){

    ev.waitUntil(
        self.caches.keys()
        .then(function(keys){
            return Promise.all(
                keys.map(function(cacheName){
                    if(cacheName !== STATIC_CACHE && cacheName !== DYNAMIC_CACHE && cacheName !== 'on-demand-cache-v1'){

                        return self.caches.delete(cacheName);
                    }
                })
            )
        })
    );
});

self.addEventListener('fetch', function(ev) {

    const firebaseUrl = 'https://instapwaclone.firebaseio.com/posts.json';

    if(ev.request.url.indexOf(firebaseUrl) > -1){

        ev.respondWith(

            fetch(firebaseUrl)
            .then(function(response){

                response.clone().json()
                .then(function(data){
                    // NA POMENUTOM Promise-U, KOJI REFERENCIRA dbPromise VARIJABLA PRIMENJUJEM then
                    // A U OBIMU, NJEGOVOG CALLBACK-A, NAD INDEXIRANOM BAZOM, KOJA JE PROSLEDJENA
                    // (DAO SAM JOJ IME 'news-store', PRILIKOM NJENOG OTVARANJA)

                    // NARAVNO, POTREBNO JE OBET PRISTUPATI, SVIM LJUCEVIMA
                    for(let key in data){
                        // DAKLE, PO JEDAN CHAINING then-A
                        // ZA SVAKI OD OBJEKAT KOJI SU STIGLI KAO DEO posts OBJEKTA SA SERVERA
                        dbPromise.then(function(db){

                            // ZA PISANJE PODATKA U BAZU PODATKA MORAM KREIRATI TRANSACTION

                            // REKAO SAM RANIJE DA IndexedDB IMA NESTO STO SE ZOVE

                                    //          TRANSACTIONAL OPERATION MODULE

                            // DAKLE MORAM KORISTITI TRANSACTION DA BI RADIO BILO STA SA DATABASE-OM

                            // TO RADIM PRIMENOM
                                                    //          transaction        METODE NAD BAZOM PODATAKA


                            // POMENUTA METODA ZAHTEVA DVA ARGUMENTA

                                        //   -----        STRING IMENA OBJECT STORE-A
                                        //                (OVIM USTVARI DEFINISEM, KOJI OBJECT STORE ZELIM DA
                                        //                TARGETUJEM SA TRANSACTION-OM)

                                        //   -----        DRUGIM ARGUMENTOM SE DEFINISU TIP TRANZAKCIJE
                                        //                NEKE MOGUCE VREDNOSTI SU: "readonly" ILI
                                        //                "read-write"

                                // NARAVNO JA CU DEFINISATI 'readwrite', JER ZELIM DA DA WRITE-UJEM U
                                // DATABASE, SAM READING BI BIO USELESS

                            let transaction = db.transaction('posts', 'readwrite');

                            // SLEDECE STO MORAM DEFINISATI JESTE STORING

                            // PRIMENJUJEM          objectStore             METODU, NAD TRANSACTION-OM

                                // OVO MALO IZGLEDA CUDNO
                                    // ALI ONO STA RADIM JESTE PRVO KAZEM STA ZELIM DA TARGET-UJEM
                                    // PA ONADA EKSPLICITNO OTVARAM OBJECT STORE

                            let store = transaction.objectStore('posts');

                            // SADA TO MOGU KORISTITI DA STAVIM NESTO U STORE

                            // METODA KOJU MOGU KORISTITI NAD OBJECT STORE-OM JESTE
                            //                                                          put     METODA

                                                                                    // POSTOJE I NEKE DRUGE
                                                                                    // METODE, KIIAO STO SU
                                                                                    //          get
                                                                                    // I JOS NEKE DRUGE
                                                                                    // METODE
                                                                                    // SADA STAVLJAM U BAZU I 
                                                                                    // ZATO KORISTIM
                                                                                    //                  put

                            // ONO STO STAVLJAM JESTE KLJUC
                            // OPET POGLEDAJ
                            // KAKVA JE STRUKTURA JSON ODGOVORA SA SERVERA
                                                                                        /*
                            {
                                first-post: {id: "first-post"}
                                second-post {...}
                                ...
                            }

                                                                                        */

                            // VRATI SE GDE SI DEFINISAO KREIRANJE OBJECT STORE, I SETI SE DA SI TAMO
                            // ZADAO       'id'      KAO VREDNOST ZA        keyPath

                            // E TOM        keyPath-U       SAM ZADAO "id" KAO VREDNOST

                            // SADA PROSLEDJUJEM     "id"      KAO VREDNSOT, KAKO BI PRISTUPIO
                            // CURRENT OBJECT-U (KONKRETNOM OBJECTU NUMERACIJE)

                            store.put(data[key]);

                            // NE ZABORAVI DA SI U      for-in          LOOP-U

                            // MORAS SVAKI PUT ZATVORITI TRANZAKCIJU ZA SVAKI OBJECT STORE

                            // TO RADIS TAK OSTO RETURN-UJES            complete
                            //                                                              PROPERTI

                            return transaction.complete;

                            // DAKLE NIJE U PITANJU METODA, VEC JE U PITANJU PROPERTI, KOJI
                            // return-UJEM U OBIMU, then-OVOG CURRENT CALLBACK-A

                        })

                    }

                })

                return response;
            })

        );

    }else if(findUrl(ev.request.url)){

        ev.respondWith(
            self.caches.match(ev.request)
        )

    }else{

        ev.respondWith(
            self.caches.match(ev.request)
            .then(function(response){
                if(response){
                    return response;
                }else{
                    return self.fetch(ev.request)
                    .then(function(resp){
                        return self.caches.open(DYNAMIC_CACHE)
                        .then(function(dynamicCache){
                            // trimCache(DYNAMIC_CACHE, 10);
                            dynamicCache.put(ev.request.url, resp.clone());
                            return resp;
                        })
                    })
                    .catch(function(err){

                        if(ev.request.headers.get('accept').includes('text/html')){
                            return caches.open(STATIC_CACHE)
                            .then(function(statCache){
                                return statCache.match('/fallback_offline.html')
                                .then(function(fallbackResp){
                                    return fallbackResp;
                                })
                            })
                        }

                    })
                }
            })
        );

    }

});

```

**KADA RELOAD-UJEM PAGE, ONDA MOGU, ISTO DA U Aplication TABU, CHROME TOOLS-A, PROVERIM STA IMA U IndexedDB-JU**

**DESNA STRANA Aplication SEKCIJE**: DAKLE TAMO MOGU NACI I OBJECT STORE

**ON JE ZA SADA PRAZAN UPRAVO, ZBOG TOGA STO JE SERVICE WORKER FRESHLY INSTALLED**

**RELOAD-UJEM STRANICU I ONDA MOGU VIDETI**

**DAKLE IMAM STORE I SVI OBJEKTI SU DOSTUPNI, ODNOSNO STORED SU U POMENUTOM STORE-U**

**ALI ZA SADA SE PODACI NE SERVIRAJU IZ INDEKSIRANE BAZE PODATASKA, JER SAM DEFINISAO DA SE PODACI TAMO STAVLJAJU, ALI JOS NISAM DEFINISAO DA SE ONI OTUDA VADE** (DAKLE ZA SADA SAM SAMO NAPISAO LOGIKU, KOJA SLUZI ZA STAVLJANJE U IndexedDB)

## U feed.js FAJLU IMAM LOGIKU, I KORISCENJE CACHE-A, PO PRINCIPU, ODNSON OSTRATEGIJI 'CACHE THEN NETWORK'; DAKLE JA VIDIM IZ Cache-A, A TREBALO BI DA VADIM IZ INDEKSIRANE BAZE PODATKA

MEDJUTIM TREBA MI OTVORENA BAZ PODATAKA, KOJU SAM MALOCAS KORISTIO, ODNOSNO TRBA MI Promise, KOJI JE VREDNOST POMENUTE VARIJABLE dbPromise (I TO JE Promise, KOJI JE POVRATNA VREDNOST, POMENUTE POZVANE open METODE (STO JE BILO PRVO STO SAM URADIO U SERVICE WORKER-U, A TICALO SE IndexedDB-JA))

NAJBOLJE BI BILO DA IZBEGNEM PONOVNO POZIVANJE TE METODE I DA IMAM, POMENUTI PROMISE U ODVOJENOM FAJLU, KOJI BI ONDA KORISTIO I SERVICE WORKER THREAD, ALI I MOJ SCRIPT, KOJI JE INSERTED INTO THE DOM

## DODAJEM NOVI SCRIPT U KOJEM SE NALAZI SAV CODE KOJI SE TICE OTVARANJE NOVE INDEKSIRANE BAZE, I KREIRANJA OBJECT STORE-A, ALI SAV CODE STAVLJANJAU BAZU PODATKA, ZELIM DA BUDE ENCAPSULATED U JEDNOJ FUNKCIJI

KREIRAM utility.js FAJL U src/js/ (NARAVNO, MORAM OVA JSCRIPT INSERT-OVATI U DOM JER KORISTI BIBLIOTEKU (INSERTUJEM GA NAKON ISNSERTING-A BIBLIOTEKE))

```javascript
const dbPromise = idb.open('news-store', 1, function(db){

    if(!db.objectStoreNames.contains('posts')){

        db.createObjectStore('posts', {keyPath: 'id'})

    }

})

// FUNKCIJA CE SE ZVATI writeData

// DODAVACE SVE PARAMETRI BITNE ZA TRANZAKCIJU I STAVLJANJE JEDNOG OBJEKTA U DATA STORE OBJEKAT, IZ BAZE
const writeData = function(storeName, data, key){

    return dbPromise.then(function(db){

        let transaction = db.transaction(storeName, 'readwrite');

        let store = transaction.objectStore(storeName);

        store.put(data[key]);

        return transaction.complete;

    })

}

// IMAJ NA UMU DA JE REC O JEDNOM UNOSU, ODNOSNO O JEDNOM OBJEKTU KOJI SE STAVLJA U STORE OBJECT
// TO ZNACI DA CE SE OVA FUNKCIJA POZIVATI U OBIMO for-in LOOP-A, NAPRAVLJENOG ZA LOOPING PO PROPERTIJIMA OBJEKTA, KOJI STIZE SA SERVERA

```

## DA REDEFINISEM SERVICE WORKER CODE, KOJI SE TICAO INDEXED DB-JA, ODNOSNO DA TAMO IMPLEMENTIRAM CODE KOJI SAM DEFINISAO U sec/js/utility.js FAJLU

- POTREBNO JE writeData FUNKCIJU, KOJ USAM KREIRAO, U POMENUTOM DAJLU, POZVATI U SERVICE WORKER THREADU, I BOLJE DA POKAZEM KAKO

```javascript

importScripts('/src/js/idb.js');            // OVO JE DEPENDANCZ I NE SMEM GA UKLONITI
importScripts('/src/js/utility.js');     // SAD MI OVO TREBA


/* const dbPromise = idb.open('news-store', 1, function(db){    //  OVO MI NE TREBA JER JE DEFINISANO U UVEYENOM SCRIPT-U

    if(!db.objectStoreNames.contains('posts')){

        db.createObjectStore('posts', {keyPath: 'id'})

    }

}) */



self.addEventListener('fetch', function(ev) {

    const firebaseUrl = 'https://instapwaclone.firebaseio.com/posts.json';

    if(ev.request.url.indexOf(firebaseUrl) > -1){

        ev.respondWith(

            fetch(firebaseUrl)
            .then(function(response){

                response.clone().json()
                .then(function(data){

                    for(let key in data){
                        // DAKLE, PO JEDAN CHAINING then-A
                        // ZA SVAKI OD OBJEKAT-A KOJI SU STIGLI KAO DEO posts OBJEKTA SA SERVERA

                        //  MOZDA JE FUNKCIJA MOGLA BITI I DRUGACIJA, ODNOSNO DA JOJ SE KA OARGUMENT DODAJE data[key], ALI NEMA VEZE, OSTAVICU JE OVAKVU ZA SADA

                        writeData('posts', data, key);

                    }

                })

                return response;
            })

        );

    }else if(findUrl(ev.request.url)){

        ev.respondWith(
            self.caches.match(ev.request)
        )

    }else{

        ev.respondWith(
            self.caches.match(ev.request)
            .then(function(response){
                if(response){
                    return response;
                }else{
                    return self.fetch(ev.request)
                    .then(function(resp){
                        return self.caches.open(DYNAMIC_CACHE)
                        .then(function(dynamicCache){
                            // trimCache(DYNAMIC_CACHE, 10);
                            dynamicCache.put(ev.request.url, resp.clone());
                            return resp;
                        })
                    })
                    .catch(function(err){

                        if(ev.request.headers.get('accept').includes('text/html')){
                            return caches.open(STATIC_CACHE)
                            .then(function(statCache){
                                return statCache.match('/fallback_offline.html')
                                .then(function(fallbackResp){
                                    return fallbackResp;
                                })
                            })
                        }

                    })
                }
            })
        );

    }

});
```

## VREME JE DA U feed.js FAJLU DEFINISEM VADJENJE PODATKAKA IZ OBJECT STORE-A, ODNOSNO BOLJE DA SAM REKAO "CITANJE PODATKA IZ OBJECT STORE-A", JER PRAVILNIJE JE TAKO RECE, A KADA GOVORIM O "VADJENJU", TO JE TERMIN REZERVISAN ZA CACHE

OPET U utility.js FAJLU DEFIISEM NOVU FUNKCIJU, KOJA CE SLUZITI ZA CITANJE IZ OBJECT STORE-A (MOZDA UZ TO MOGU DEFINISATI U SERVICE WORKER-U, DA SE OVA JFAJL CACHIRA ,JER SAM TO RANIJE ZABORAVIO)

```javascript
const dbPromise = idb.open('news-store', 1, function(db){

    if(!db.objectStoreNames.contains('posts')){

        db.createObjectStore('posts', {keyPath: 'id'})

    }

})

const writeData = function(storeName, data, key){

    return dbPromise.then(function(db){

        let transaction = db.transaction(storeName, 'readwrite');

        let store = transaction.objectStore(storeName);

        store.put(data[key]);

        return transaction.complete;

    })

}

// NOVA FUNKCIJA CE SE ZVATI readAllData

const readAllData = function(storeName){
    return dbPromise.then(function(db){

        let transaction = db.transaction(storeName, 'readonly');    // readonly JER SAMO CITAM IZ BAZE

        let store = transaction.objectStore(storeName);

        return store.getAll();        // OVOM FUNKCIJOM CE SE PROCITATI CEO STORE OBJECT

        //  NE MORAM RETURN-OVATI transaction.complete, JER AKO NISAM NISTA PROCITAO, BICE RETURNED null
        // GORE JE DRUGACIJA SITUACIJA, JER PRI UPISIVANJU U DATABASE, POTREBNO JE ZNATI DA LI JE TRANSACTION BIO USPESAN

    })
}
```

SADA DA U POTREBIM OVU FUNKCIJU U feed.js FAJLU

```javascript

let networkRponseIsHere = false;

fetch('https://instapwaclone.firebaseio.com/posts.json')
.then(function(response){
    return response.json()
})
.then(function(data){

    console.log(data);

    networkRponseIsHere = true;

    updateUi(data);
})



/* window.caches.match('https://instapwaclone.firebaseio.com/posts.json')    // PODACI VISE NISU U CACHE-U, I NE PRISTUPAM MU
.then(function(response){

    console.log(response);

    if(response) return response.json();
})
.then(function(data){

    console.log(data);

    
}) */


// POCINJEM TAKO STO CU PROVERITI DA LI UOPSTE BROWSER PODRZAVA IndexedDB

if('IndexedDB' in window){    //   DB JE NAPISANO VELIKIM SLOVIMA   !!!!!!!! ZAPAMTI DA JE POCETAK MALIM SLOVOM
                                                                        // DAKLE    indexedDB   POCINJE MALIM SLOVOM

readAllData('posts')            // IME OBJECT STORE-A, JE ARGUMENT

    .then(function(data){

        if(!networkRponseIsHere && data){                                       // KAO STO VIDIM, UPOTREBLJEN JE PRINCIP, ODNOSNO STRATEGIJA 'CACHE THEN NETWORK'
                                                                                // KOJ ISADA MOGU PREIMENOVATI ZA OVAJ SLUCAJ, U 'DATABASE THEN NETWORK'
            console.log(data);

            // POZIVANJU FUNKCIJE updateUi
            updateUi(data);
        }

    })

}

```

## SADA MOGU PONOVITI PROCEDURU, PO KOJOJ, UPDATE-UJEM SERVICE WORKER CACHE VERZIJE, I PO KOJOJ BRISEM CEO STORAGE, (TADA SE BRISE SVE, A TO MOZE DA ZAVISI STA JE STIKLIRANO U Application tab/Clear storage U DEV TOOLS-U (KOD MENE JE STIKLIRAN-O SVE, I CACHE I IndexedDB, A I SERVICE WORKER CE BITI DELETED (TAKO DA NISAM MORAO UOPSTE DA MU UPDATE-UJEM VERZIJE CACHE-A)), PA ONDA RELOAD-UJEM STRANICU PRVI PUT, PA JOS JEDNOM, PA ONDA MOGU UCI U OFFLINE MODE, DA VIDIM DA LI CE PODACI DATABASE-A BITI SERVED

I NARAVNO I OFFLINE, SVE JE SERVED

## ALI SERVED JE JOS NESTO STO MOGU PRIMETITI

TO JE SLIKA KOJA JE DEO POSTA NA STRANICI

ONA JE SERVIRANA IZ CACHE-A, JER JE TA SLIKA DINAMICKI CACHED

**U JSON PODACIMA POSLATIM SA SERVER, JA SAM SLAO URL SLIKE, I KADA SAM ZADAVO URL SLIKE, PREKO updateUi METODE, POSTIGNUTO JE DA SE ZADAVANJE Msrc-A SLIKE POSALJE DODATNI NETWORK REQUEST, I PRI INTERCEPTION-U TOG REQUEST-A, SLIKA JE POSTALA CACHED**

