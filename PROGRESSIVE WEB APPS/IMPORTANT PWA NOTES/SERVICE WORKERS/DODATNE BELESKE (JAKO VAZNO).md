# DODATNE BELESKE VEZANE ZA SERVICE WORKERE I CACHE

## Request I Response INSTANCE

ZNAM OD RANIJE DA JE **Request** ONO STO SE, KAO ARGUMENT DODAJE fetch METODI

A ZNAM DA POVRATNA VREDNOST fetch METODE, JESTE Promise, KOJI MOZE BITI RESOLVED SA **Response** INSTANCOM

KADA SE fetch EXECUTE-UJE, ALI NE MORAM POSMATRATI SAMO fetch, VEC **POSMATRAM SVAKO DEFINISANJE PATH-OVA NA WEB STRANICI, JER SVO TO DEFINISANJE PATHOVA, PREDSTAVLJA PODESAVANJE ZA NEKI FETCHING (BILO DA SU TO SLIKE I LI STILOVI), TO SU NAIME SVE NETWORK REQUEST-OVI, DAKLE, U PITANJU JE SVE FETCHING

A SAV **TAJ FETCHING, JA MOGU INTERCEPT-OVATI, U OBIMU **onfetch** HANDLERA, SERVICE WORKER-A**

I OBICNO U OBIMU TOG HANDLERA, JA MOGU CACHE-OVATI FAJLOVE, KOJI SU FETCHED

PO ONOME STA JA VIDIM, MOGU ZAKLJUCITI I SLEDECE:

**KOLIKO GOD src ATRIBUTA (ILI href AKO JE REC O link TAGOVIMA) U MOM HTML-U, I KOLIKO GOD POZIVANJA fetch() METODA, U MOJIM JAVASCRIPT FAJLOVIMA (KOJI SU UCITANI), TOLIKO CE BITI I TRIGGERING-A fetch EVENT-OVA, KOJE MOGU HVATAI U SERVICE WORKER THREAD-U**

A FetchEvent, S KOJIM MOGU RUKOVATI U **onfetch** HANDLERU, 'DONOSI', I **Request** OBJEKAT

SA Request OBJEKTA, MOGU PROCITATI MNOGE STVARI, ALI MENI JE NAJBITNIJI URL FAJLA, KOJI JE POTENCIJALNI FILE ZA CACHING

## CACHE STORAGE

CACHE STORAGE-U, ILI TI **SKLADISTU CACHE-OVA**, U OBIMU SERVICE WORKERA, PRISTUPA SE GETTER-OM (PREDPOSTAVLJAM DA JE GETTER):

- **self.caches** (INSTANCA **CacheStorage**)

OTVARANJE ZELJENOG CACHEA:

- **self.caches.open('STRING IMENA ZELJENOG CACHE-A')** :ship:

:arrow_right: (POVRATNA VREDNOST) Promise INSTANCA (**RESOLVED SA STRINGOM IMENA CACHE-A**)

UKLANJANJE ZELJENOG CACHE-A:

- **self.caches.delete('STRING IMENA ZELJENOG CACHE-A')** :ship:

:arrow_right: Promise INSTANCA (**RESOLVED SA STRINGOM IMENA CACHE-A**)

PROVERA POSTOJANJA NEKOG CACHEA UCACHE STORAGE-U"

- **self.caches.has('STRING IMENA ZELJENOG CACHE-A')** :ship:

:arrow_right: Promise INSTANCA (**RESOLVED SA BOOLEAN-OM**)

- **self.caches.match(Request_Instanca)** :ship:

:arrow_right: Promise INSTANCA (**RESOLVED SA *Response* INSTSNCOM-OM**) (AKO JE FILE CACHED U NEKOM OD CACHE-OVA, CACHE STORAGE-A)

- **self.caches.keys()** :ship:

:arrow_right: Promise INSTANCA (RESOLVED SA NIZOM) (NIZ SE SASTOJI OD STRINGOVA IMENA, SVAKOG CACHEA, U CACHE STORAGE-U)

- **self.caches.match(Request_Instanca)** :ocean:

:arrow_right: Promise INSTANCA (**RESOLVED SA *Response* INSTSNCOM-OM**) (AKO JE FILE CACHED U NEKOM OD CACHE-OVA, CACHE STORAGE-A) (ODNOSNO, TRAZI SE PRVI CACHE, U KOJEM JE TAJ FILE (MOZE POSTOJATI MOGUCNOST DA JE ISTI FILE CACHED U MULTIPLE CACHE-A, JEDNOG CACHE STORAGE-A))

## CACHE-I

TO SU, NAIME **Cache** INSTANCE

## METODE Cache INSTANCI

### 1. DODAVANJE U CACHE (METODE, KOJE IZISKUJU SAMO URL (STRING) FILE-A, KAO ARGUMENT) :octopus:

- nekiCache.**add()**

ARGUMENT MU JE *SAMO JEDAN URL* FAJLA, KOJEG ZELIM DA CACHE-IRAM

- nekiCache.**addAll()**

ARGUMENT MU JE Array, CIJI SU CLANOVI URL-OVI (DAKLE METODA DODAJE VISE FAJLOVA U CACHE)

**OBE METODE, IMAJU *Promise* KAO POVRATNU UVREDNOST** (RESOLVED SA)

*TAJ PROMISE MOZE BITI RESOLVED SA **RELATED cache-OM** KOJI CE BITI PASSED then CALL-U*

### 3. put METODA

I OVA METODA JESTE METODA ZA CACHING FILE-A

### 4. MATCHING METODE (METODE, KOJE SE POZIVAJU U OBIMU onfetch HANDLER-A) :octopus:

ARGUMENT OVIH METODA JE [**Request** OBJEKAT](https://developer.mozilla.org/en-US/docs/Web/API/Request), KOJEM SE PRISTUPA, OVAKO **FetchEvent.request** (KAO STO REKOH, OVO PRISTUPANJE JE U OBIMU *onfetch* HANDLER-A)

DAKLE, ONO STO JE CILJ DA SE UTVRDI UZ POMOC OVIH METODA, JESTE DA LI CACHED FILE JESTE ONAJ FILE, KOJI JE REQUESTED, I UPRAVO SE ZATO, Request DODAJE KAO ARGUMENT, SLEDECIM METODAMA (USTVARI MOZDA JE BOLJE DA STVARI POSTAVIM OVAKO: **KADA JE FILE REQUESTED, TREBAM DA PRONADJEM DA LI JE TAJ FILE, U NEKOM, MOM CACHE-U**, I UPRAVO ZA TO KORISTIM, SLEDECE METODE)

- nekiCache.**match()**

ARGUMENT JOJ JE, KAO STO REKOH, Request INSTANCA

POVRATNA VREDNOST: [Response INSTANCA](https://developer.mozilla.org/en-US/docs/Web/API/Response), AKO JE MATCHING USPESAN

- nekiCache.**matchAll()**

ARGUMENT JOJ JE Array, CIJE SU CELIJE Request INSTANCE

DAKLE, IMACU MATCH, ODNOSNO POVRATNA VREDNSOT, OVE METODE CE BITI **RESOLVED Promise**(KOJI TREBA DA BUDE RESOLVED SA [NIZOM, CIJE SU CELIJE **Response** INSTANCE](https://developer.mozilla.org/en-US/docs/Web/API/Response)), SAMO AKO IMAM TAJ *POTPUNI MATCHING* (MATCHING SVIH REQUESTOVA, SA SVIM REQUESTED, CACHED FILE-OVIMA)

### 5. ACCESSING 'SADRZAJU', NEKOG CACHE-A :octopus:

**MATCHING METODE SU IMALE POVRATNU VREDNOST Promise INSTANCU, KOJA JE RESOLVED SA Response INSTANCOM, ILI NIZOM Response INSTANCI**

**ALI TAKAV SLUCAJ NIJE SA SLEDCOM METODOM**

- nekiCache.**keys()**

KADA PRIMENIM POMENUTU keys METODU, ONO STO CE PROIZICI JESTE Promise, KOJI TREBA DA BUDE RESOLVED SA NIZOM, CIJE SU CELIJE **Request** INSTANCE SVIH ASSET-OVA, KOJE SAM CACHE-IRAO U MOJ CACHE

Request INSTANCE, SU RETURNED U ISTOM ORDERU, PO KOJEM SU I INSERTED

NAIME, MATCHING METODE, ZAHTEVAJU Request (ILI NIZ Request-OVAO), KAO ARGUMENT, KAKO BIH, KADA SE FETCHUJE FILE (MISLIM NA NETWORK REQUEST), IMAO PODUDARANJE U POGLEDU TOGA, DA LI JE TAJ FILE CACHED U MOJ CACHE

**A ZA *keys* METODU, MENI NISU POTREBNI Request INSTANCE, VEC MOGU DIREKTNO PRISTUPITI INFORMACIJI, KOJI SU TO FILE-OVI CACHED U NEKI MOJ CACHE**

