# DODATNE BELESKE VEZANE ZA SERVICE WORKERE I CACHE, ALI PRVENSTVEN OZA CACHE

PRE NEGO STO SE POZABAVIM  CACHE-OM, POZABAVICU SE PRVO FETCHINGOM FILE-OVA

## Request I Response INSTANCE

ZNAM OD RANIJE DA JE **Request** ONO STO SE, KAO ARGUMENT DODAJE fetch METODI

A ZNAM DA POVRATNA VREDNOST fetch METODE, JESTE Promise, KOJI MOZE BITI RESOLVED SA **Response** INSTANCOM (AKO JE REC O USPESNOM FETCHINGU)

Response , KADA SE TRAZE NEKI PODACI, NOSI TE PODATKE KOJI SU MI POTREBNI, I MOGU IH PROCITATI SA Response OBJEKTA 

KADA SE fetch EXECUTE-UJE, ALI NE MORAM POSMATRATI SAMO fetch, VEC **POSMATRAM SVAKO DEFINISANJE PATH-OVA NA WEB STRANICI, JER SVO TO DEFINISANJE PATHOVA, PREDSTAVLJA PODESAVANJE ZA NEKI FETCHING (BILO DA SU TO SLIKE I LI STILOVI), TO SU NAIME SVE NETWORK REQUEST-OVI, DAKLE, U PITANJU JE SVE FETCHING

A SAV **TAJ FETCHING, JA MOGU INTERCEPT-OVATI, U OBIMU **onfetch** HANDLERA, SERVICE WORKER-A**

JER CE SVAK FETCHING UCINITI, DA SE U OBIM USERVICE WORKER-A, TRIGGER-UJE **fetch** EVENT

**KOLIKO GOD src ATRIBUTA (ILI href AKO JE REC O link TAGOVIMA) U MOM HTML-U, I KOLIKO GOD POZIVANJA fetch() METODA, U MOJIM JAVASCRIPT FAJLOVIMA (KOJI SU UCITANI U HTML), TOLIKO CE BITI I TRIGGERING-A fetch EVENT-OVA, KOJE MOGU HVATAI U SERVICE WORKER THREAD-U**

A FetchEvent, S KOJIM MOGU RUKOVATI U **onfetch** HANDLERU, 'DONOSI', I **Request** OBJEKAT

SA Request OBJEKTA, MOGU PROCITATI MNOGE STVARI, ALI MENI JE NAJBITNIJI URL FAJLA, KOJI JE POTENCIJALNI FILE ZA CACHING

## KAKO SE, UVEK OBAVLJA CACHING? BEZ OBZIRA NA TO DA LI SE OBAVLJA U SERVICE WORKER SCRIPT-U, ILI MAIN SCRIPTU

OBRATI PAZNJU NA SLEDECE, JER MISLIM DA JE OVO VEOMA VAZNO:

**DA BI FAJL CACHE-IRAO, BUKVALNO SE MORAJU URADITI SLEDECI KORACI**

- INSTANTICIZIRATI Request KLASU, KAK OBI KREIRAO JEDNU Request INSTANCU

- TA Requestt INSTANCU SE KAO ARGUMENT, DODAJE fetch() FUNKCIJI

- POVRATNA VREDNOST fetch FUNKCIJE JESTE Promise, KOJI, AKO JESTE RESOLVED, ON JE RESOLVED SA **Response** INSTANCOM

>>>> **NORMALNO KADA JE REC O JSON PODACIMA, KOJI SE POTRAZUJU, ONI SE OBICNO NALAZE U Response-U, ALI OVDE SE RADI O CELIM FAJLOVIMA, KOJI SE TREBAJU CACHE-IRTI U NEKOM CACHE-U BROWSER-A**

ARGUMENTI, PRILIKOM CACHEING-A, NEKOG FAJLA TREBAJU DA BUE key/value PAR:

1. **Request** INSTANCA (PREDSTAVLJA **KEY**)

2. **Response** INSTANCA (PREDSTAVLJA **VALUE**)

A ZASTO SU POTREBNA OVE DVE INSTANCE, ZA USPESAN CACHING, I ZASTO BAS U PAROVIMA key/value?

PREDPOSTAVLJAM, KADA GOVORIM O FAJLOVIMA, SVAKI KARAKTERISTICNI Request, TREBA DA IMA KARAKTERISTICNI Response

A AKO POSTOJI VALIDAN Response, TO ZNACI DA JE FILE FETCHED

**JER KADA JE NEKI FILE LINKED SA, MOJIM HTML FAJLOM (NA PRIMER, SCRIPT, ILI STIL), TIME JE POKRENUTO INSTATICIZIRANJE Request-A, A Response CE USLEDITI, KADA FILE, USPESNO POSTANE FETCHED**

KAKO ONDA IZGLEDA JEDAN CACHING

```JAVASCRIPT

let CACHE_NAME = 'page_cache_v1';

fetch(reguest)
.then(function(response){

    if(!response.ok){
        throw new TypeError("Response is not successfull (status is not in range from 200 to 299 )");
    }

    window.caches.open(CAHE_NAME)
    .then(function(cache){
        cache.put(request, response);
    })

})
```

****

:small_red_triangle:

fetch() METODI SE CESTO DODAJE, SAMO URL KAO ARGUMENT VREDNOST, DAKLE NE DEFINISE SE CEO Request

ONO STO TREBA DA ZNAM JESTE DA TADA U ZAHTEVU ZA ASSET-OM, UCESTVUJE I Request INSTANCA, KOJA JE TADA FORMIRANA, UNDER THE HOOD OF fetch-A (SIGURNO NEKA DEFAULT INSTANCA Request-A (INSTANCA SA NEKIM DEFAULT POSTAVKAMA O KOJIAM NECU GOVORITI SADA))

ISTA STVAR JE I SA METODOM:

- put() &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (METODA Cache-OVOG PROTOTIPA)

DAKLE, OVOJ METODI SE, KAO ARGUMENTI DODAJU **Request** I **Response** OBJEKAT

*ALI KAO ARGUMENTE, JE MOGUCE DODATI **url**(DO ZELJENOG FAJLA) I **Response** OBJEKAT*

DAKLE, I U SLUCAJU OVE METODE, Request CE BITI FORMIRAN, IZA 'KULISA' METODE, PRI NJENOM IZVRSENJU

****

## CACHE STORAGE (SKLADISTE CACHE-OVA, BROWSER-A)

INSTANCI **CaheStorage**-A, BROWSER-A, ILI TI **SKLADISTU CACHE-OVA**, U MAIN THREAD-U SE PRISTUPA OVAKO:

- **winow.caches** ILI **self.caches** ILI SAMO **caches**

A U THRED-U BILO KOJEG WORKER-A, CAHE STORAGE-U SE PRISTUPA, OVAKO:

**self.caches** IL ISAMO **caches**

## OTVARANJE ZELJENOG CACHE-A

- **self.caches.open('STRING IMENA ZELJENOG CACHE-A')** :ship:

:arrow_right: (POVRATNA VREDNOST) Promise INSTANCA (**RESOLVED SA STRINGOM IMENA CACHE-A**)

KAO STO VIDIM REC JE O METODI CacheStorage-OVOG PROTOTIPA

## CACHIRANJE FILE-OVA

:mount_fuji: 1. **put()** METODA, Cache-OVOG PROTOTIPA, KOJA CACHE-IRA FAJL :mount_fuji:

KADA SE NESTO CACHE-IRA U NEKI CACHE, ONO STA JE POTREBNO JESTE Request OBJEKAT, ALI AKO NEMAM Request OBJEKAT, MOZE POSLUZITI SAMO url STRING

DAKLE, KORISTIM SLEDECU METODU:

- nekiCache.**put()**

DAKLE, PRVI ARGUMENT METODE, MOZE BITI **url** ILI **Request** INSTANCA

A DRUGI ARGUMENT JESTE Response OBJEKAT

POKAZACU UPRAVO CACHING, JEDNOG CSS FAJLA, PUTEM PRIMERA

NEKI MAIN SCRIPT:

```JAVASCRIPT

// IME CACHE-A, KOJI CU ISKORISTITI ZA CASHING, MOG CSS FAJLA
let CACHE_NAME = 'page-cache-v1';

// RELATIVNI PATH DO MOG CSS FAJLA, ODNOSNO url
let url = '/styles.css';

// SADA CU PRVO INICIJALIZOVATI FETCH-OVANJE, POMENUTOG CSS FAJLA
window.fetch(url)
.then(function(response){ //AKO JE FETCH USPESAN, ONDA JE Response INSTANCA DOSTUPAN U OBIMU then-OVOG CALLBACK-A

    window.caches.open(CACHE_NAME) // OTVARAM CACHE
    .then(function(cache){         // KADA SE OTVORI CACHE, POZIVAM put METODU
        cache.put(url, response)    // ARGUMENTI SU JOJ url STRING I Response OBJEKAT
        .then(function(){

            setTimeout(function(){              // NAKON, OKO TRI SEKUNDE CU PRISTUPITI SVIM KLJUCEVIMA CACHE-A
                console.log(cache.keys());      // JEDINI KLJUC U RETURNED Array-U, BICE Request ZA, POMENUTIM CSS FAJLOM
            }, 3800);

        })
    })

}).catch(function(err){
    console.log(err);
})
```

:arrow_right: POVRATNA VREDNOST put METODE JE Promise, **RESOLVED SA void-OM (ODNOSNO RESOLVED BEZ VREDNOSTI)**

****

:elephant::elephant::elephant::elephant::elephant::elephant:

**SERVICE WORKER RELATED**

KAKO MOGU DOBITI NEKI Response, KOJI BI ONDA BIO ARGUMENT, POMENUTE METODE?

PA **self.respondWith** METODA, IMA Promise POVRATNU VREDNOST, KOJI JE RESOLVED SA Response-OM

A **SVE MATCHING METODE Cache-OVOG PROTOTIPA**, IMAJU POVRATNU VREDNOST Promise, KOJI JE RESOLVED ILI SA JEDNIM Response-OM, ILI NIZOM Response-A, STO ZAVISI OD MATCHING METODE, KOJU KORISTIM

:elephant::elephant::elephant::elephant::elephant::elephant:

****

## CACHE-I

TO SU, NAIME **Cache** INSTANCE

SA Cache INSTANCOM JE RESOLVED Promise, KOJI JE POVRATNA VREDNOST, SLEDECEG POZIVANJA:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **self.caches.open('IME ZELJENOG CACHE-A')**

Cache INSTANCA NEMA NI JEDAN PROPERTI, KOLIKO SAM VIDEO KADA SAM JE KORISTIO, ALI ZATO SE NA NJOJ PRIMNJUJU METODE Cache-OVOG PROTOTIPA

## METODE Cache-OVOG PROTOTIPA, ODNOSNO METODE, KOJE SE PRIMENJUJU NA  Cache INSTANCAMA

**DAKLE, ONO STO SE POHRANJUJE U CACHE, JESTE *Response* OBJEKAT, A TOME STA JE POHRANJENO SE MOZE PRISTUPITI, UZ POMOC ODGOVARAJUCEG Request OBJEKTA, KOJI PREDSTAVLJA KLJUC (ODNOSNO KEY DO ODGOVARAJUCEG Response-A, KOJ IPREDSTASVLJA VALUE)**

### 1. DRUGE METODE ZA DODAVANJE U CACHE (SHORTHAND METODE, POMENUTE put() METODE) :octopus:

- nekiCache.**add()** (SHORTHAND put METODE)

ARGUMENT MU JE *SAMO JEDAN URL* FAJLA, KOJEG ZELIM DA CACHE-IRAM

```javascript

let url = '/images/image1.jpg';
let CACHE_NAME = "image-cache-v1";

//********************************************
fetch(url)
.then(function(response){
    self.caches.open(CAHE_NAME)
    .then(function(cache){
        cache.put(url, response);
    });
});
//********************************************

//  DAKLE, SVE OVO GORE, SE MOZE ZAMENITI SLEDECIM

self.caches.open(CAHE_NAME)
.then(function(cache){
    cache.add(url);
});

// DAKLE, ON OSTO JE SAKRIVENO UNDER THE HOOD OF cache.add JESTE fetch() POZIVANJE
```

- nekiCache.**addAll()** (ISTO SHORTHAND put METODE)

ARGUMENT MU JE *Array, CIJI SU CLANOVI URL-OVI* (DAKLE METODA DODAJE VISE FAJLOVA U CACHE)

```JAVASCRIPT

let urls = [
    '/images/image1.jpg',
    '/images/image2.jpg',
    '/images/image3.jpg',
    '/images/image4.jpg',
    '/images/image5.jpg',
    '/images/image6.jpg'
];
let CACHE_NAME = "image-cache-v1";

//********************************************
for(let url in urls){
    fetch(url)
    .then(function(response){
        caches.open(CACHE_NAME)
        .then(function(cache){
            cache.put(url, response);
        })
    })
}
//********************************************
//  DAKLE, SVE OVO GORE, SE MOZE ZAMENITI SLEDECIM

caches.open(CAHE_NAME)
.then(function(cache){
    cache.addAll(urls);
    // ALI MOZE S SAMO DEFISNISATI I IME FOLDERA 
    cache.addAll('/images/'); // TAKO DA MI CA KI NE TREBA NI NIZ url-OVA
})

// DAKLE, ON OSTO JE SAKRIVENO UNDER THE HOOD OF cache.add JESTE fetch() POZIVANJE, ALI I for LOOP
```

**OBE METODE, IMAJU *Promise* KAO POVRATNU UVREDNOST, A Promise JE RESOLVED SA void**

### 2. MATCHING METODE :octopus:

**NIJIH ARGUMENT JE Request INSTANCA, ILI URL STRING**

**PO SLOBODNOJ INTERPRETACIJI, MOGU RECI DA SU OVE METODE, UPRAVO METODE TRAZENJA Response-A IZ Cache-A**

DAKLE KADA SE U onfetch HANDLERU, DOGODI INTERCEPTION NETWORK REQUEST-A, ONO CEMU MOGU DA PRISTUPIM, JESTE:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FetchEvent.request (**Request** INSTANCA)

KOJEM SE PRISTUPA, OVAKO **FetchEvent.request** (KAO STO REKOH, OVO PRISTUPANJE JE U OBIMU *onfetch* HANDLER-A)

ARGUMENT OVIH METODA JE [**Request** OBJEKAT](https://developer.mozilla.org/en-US/docs/Web/API/Request) (ILI NIZ Request OBJEKATA), ILI JOS BOLJE RECENO, TAJ OBJEKAT JE Request KEY, KOJIM MOGU PRISTUPITI Response VALUE-U

**KADA JE FILE REQUESTED, TREBAM DA PRONADJEM DA LI JE Response, TOG FILE-A, U NEKOM, MOM CACHE-U**, I UPRAVO ZA TO KORISTIM, SLEDECE METODE)

- nekiCache.**match()**

ARGUMENT JOJ JE Request INSTANCA, ILI url STRING

POVRATNA VREDNOST: Promise INSTANCA, KOJA JE RESOLVED SA [Response INSTANC-OM](https://developer.mozilla.org/en-US/docs/Web/API/Response), AKO JE MATCHING USPESAN

- nekiCache.**matchAll()**

ARGUMENT JOJ JE Array, CIJE SU CELIJE Request INSTANCE, ILI CIJE SU CELIJE url STRING-OVI, ALI **ARGUMENT MOZE BITI I PATH CELOG FOLDERA**

DAKLE, IMACU MATCH, ODNOSNO POVRATNA VREDNSOT, OVE METODE CE BITI **RESOLVED Promise**(KOJI TREBA DA BUDE RESOLVED SA [NIZOM, CIJE SU CELIJE **Response** INSTANCE](https://developer.mozilla.org/en-US/docs/Web/API/Response)), SAMO AKO IMAM TAJ *POTPUNI MATCHING* (MATCHING SVIH REQUESTOVA, SA SVIM REQUESTED, CACHED FILE-OVIMA)

### 5. ACCESSING KEY-OVIMA (Request INSTANCAMA), NEKOG CACHE-A :octopus:

- nekiCache.**keys()**

KADA PRIMENIM POMENUTU keys METODU, ONO STO CE PROIZICI JESTE Promise, KOJI TREBA DA BUDE RESOLVED SA NIZOM, CIJE SU CELIJE **Request** INSTANCE SVIH ASSET-OVA, KOJE SAM CACHE-IRAO U MOJ CACHE

Request INSTANCE, SU RETURNED U ISTOM ORDERU, PO KOJEM SU I INSERTED Response INSTANCE U CACHE


















## OSTALE METODE CacheStorage-OVOG PROTOTIPA

UKLANJANJE ZELJENOG CACHE-A:

- **self.caches.delete('STRING IMENA ZELJENOG CACHE-A')** :ship:

:arrow_right: Promise INSTANCA (**RESOLVED SA STRINGOM IMENA CACHE-A**)

PROVERA POSTOJANJA NEKOG CACHEA UCACHE STORAGE-U"

- **self.caches.has('STRING IMENA ZELJENOG CACHE-A')** :ship:

:arrow_right: Promise INSTANCA (**RESOLVED SA BOOLEAN-OM**)

- **self.caches.match(Request_Instanca)** :ship:

:arrow_right: Promise INSTANCA (**RESOLVED SA *Response* INSTSNCOM-OM**) (AKO JE FILE CACHED U NEKOM OD CACHE-OVA, CACHE STORAGE-A)

- **self.caches.keys()** :ship:

:arrow_right: Promise INSTANCA (RESOLVED SA NIZOM) (NIZ SE SASTOJI OD STRINGOVA IMENA, SVAKOG CACHEA, U CACHE STORAGE-U)

- **self.caches.match(Request_Instanca)** :ocean:

:arrow_right: Promise INSTANCA (**RESOLVED SA *Response* INSTSNCOM-OM**) (AKO JE FILE CACHED U NEKOM OD CACHE-OVA, CACHE STORAGE-A) (ODNOSNO, TRAZI SE PRVI CACHE, U KOJEM JE TAJ FILE (MOZE POSTOJATI MOGUCNOST DA JE ISTI FILE CACHED U MULTIPLE CACHE-A, JEDNOG CACHE STORAGE-A))

