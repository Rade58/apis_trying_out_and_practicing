# Respopnse.clone() I Request.clone()

>>> **A request is a stream and can only be consumed once. Since we are consuming this once by cache and once by the browser for fetch, we need to clone the response.**

OVA RECENICA MI JE NAROCITO INTERESANTNA A KOPIRAO SAM JE IZ JEDNOG OD STACK OVERFLOW ODGOVORA

NIJE U POTPUNOSTI TACNA, JER ONO STO JESTE **ReadableStream** INSTANCA, JESTE [Body](https://developer.mozilla.org/en-US/docs/Web/API/Body), KOJI JE [MIXIN](https://javascript.info/mixins), fetch API-A

>>> Body is implemented by both Request and Response. This provides these objects with an associated body (**a stream**), a used flag (initially unset), and a MIME type (initially the empty byte sequence).

body PROPERTI Response I Request INSTANCI, SKLADISTI (ODNOSNO REFERENCIRA) ReadableStream INSTANCU

## ReadableStream

>> Streaming involves breaking a resource that you want to receive over a network down into small chunks, then processing it bit by bit. This is something browsers do anyway when receiving assets to be shown on webpages â€” videos buffer and more is gradually available to play, and sometimes you'll see images display gradually as more is loaded.

[SLEDECE STVARI MORAS PROUCITI], KAKO BI NA NAJBOLJI NACIN RAZUMEO STREAM-OVE  

[Streams API concepts](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Concepts)

[Using readable streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams)

[Using writable streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_writable_streams)

## DODATNO O Cache.match() METODI (JER PONEKAD MOGU ZABORAVITI)

ZNAM DA SE, OVOM METODOM, TRAZI, ILI BOLJE RECENO ZAHTEVA Response IZ CACHE-A, U ODNOSU NA Request ARGUMENT, KOJI SE DODAJE OVOJ METODI

**ZNAM DA JE POVRATNA VREDNOST, POMENUTE METODE UPRAVO Promise OBJEKAT**

:small_red_triangle: ALI MOGU UPASTI U ZABLUDU, PONEKAD AKO DOBRO NE RAZMISLIM, KOJE SU TO VREDNOSTI SA KOJIMA JE TAJ Promise RESELOVED ILI SA KOJIMA JE REJECTED

- AKO JE ASSET (ODNOSNO Response) U CACHE-U Promise CE BITI RESOLVED SA Response INSTANCOM

- AKO NIJE U CACHE-U, Promise CE OPET BITI RESOLVED, ALI SA undefined VREDNOSCU

:small_red_triangle_down: **MISLIM DA PONEKAD MOGU DOCI U ZABLUDU PA POMISLITI DA AKO ASSET NIJE PRONADJEN, DA CE, POMENUTI Promise BITI REJECTED (BAR JEDNOM MI SE TO DESILO)**

:small_orange_diamond: **E PA TREBAM DA ZNAM DA JE Promise, KOJI JE RETURNED OD STRANE POMENUTE METODE, JEDINO REJECTED AKO ARGUMENT, KOJI PROSLEDIM METODI NIJE Request INSTANCA ILI URL STRING**

## A ONO STO TREBAM DA ZAPAMTIM KADA KORISTIM fetch API I ServiceWorker-E, A ODNOSI SE NA STREAM-OVE, OBJASNICU U NASTAVKU

NAIME, POSMATRACU SLEDECI CODE SERVICE WORKER-A:

```javascript
////////////////////////////////////////////////////////////////////////////////////////////////
// NE OBRACJA PAZNJU NA OVAJ, IMPORTED SCRIPT (NEMA VEZE SA ONIM STA TREBAM DA OBJASNIM )
// (OVO JE SAMO PODSETNIK DA TREBAM DA NAUCIM WORKBOX)
importScripts('https://storage.googleapis.com/workbox-cdn/releases/4.2.0/workbox-sw.js');

if(workbox){
    console.log('Workbox is loaded');
}else{
    console.log("workbox didn't load")
}

// U BUDUCNOSTI CES KORISTITI WORKBOX ZA PRECACHING
//(PODSETNIK DA TREBAM NAUCITI TAJ ALAT, KOJI SE ZESTOKO OSLANJA NA RegExp, KOJI TAKODJE MORAM TEMELJNO PONOVITI)
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////



// DAKLE ODAVDE KRECE CODE, POTREBAN DA POSMATRAM, DA LAKSE SHVATIM POMENUTA KLONIRANJA
// MEDJUTIM JA CU KOMENTARISATI I NEKE STVARI KOJE CU DODATNO ISPITIVATI
// A ONO STA CU OBJASNITI U VEZI KLONIRANJA NALZICE SE DOLE U onfetch HANDLER-U

const cacheWhitelist = ['page-static-cache-v1'];
const urls = [
    '/', // ZASTO SE SAMO JEDAN SLASH KORISTI, MORAM DODATNO ISPITATI
    '/index.html',
    /*'/src/js/app.js',*/           // app.js FAJL, JE BIO FAJL, U KOJEM SAM REGISTRVAO SERVICE WORKER-A
                                    // POSTO U NJEMU NEMA NISTA DRUGO OSIM REGISTRACIJE MISLIM DA GA NE
                                    // MORAM CACHE-OVATI ZA OFFLINE USE (OVO CU JOS PROVERITI)

    '/src/js/material.min.js',
    '/src/js/feed.js',



    '/src/css/material.min.css',
    '/src/css/app.css',
    '/src/css/feed.css',
    '/src/css/help.css',


    '/help/index.html',


    // '/src/images/mona_lisa.jpg',   // OVO RADIM, RADI PROVERE (OVAJ FAJL KADA BUDE REQUESTED NECE BITI
                                      // SERVED IZ CACHE-A, JER GA NECU STAVITI U CACHE
                                      // DAKLE ONLINE, ON TREBA DA BUDE DOSTUPAN, DOK OFFLINE ON NECE BITI 
                                      // DOSTUPAN  
    '/manifest.json',
    '/favicon.png',



    'https://fonts.googleapis.com/css?family=Roboto:400,700',

    'https://fonts.googleapis.com/icon?family=Material+Icons',

];

// ZELIM DA CACHE-IRAM, SVE FAJLOVE, CIJI SU URL-OVI, CLANOVI PEDHODNOG NIZA

self.addEventListener('install', function(ev){
    ev.waitUntil(
        self.caches.open('page-static-cache-v1')
        .then(function(cache){
            return urls.map(function(url){

                // HAJDE DA EKSPLICITNO KREIRAM Request INSTANCU (TO NEMA NEKE VELIKE VEZE SA OBJASNJENJE
                // ALI HAJDE DA TO IPAK URADIM KAKO NE BIH OSTAVLJAO TO METODAMA (KONKRETNO put METODA JE U // PITANJU) DA TO URADE ZA MENE) (MISLIM DA TAKO BOLJE UCIM STRUKTURU SVEGA)

                let request = new Request(url);
                
                return self.fetch(request)
                .then(function(response){

                    return cache.put(request, response);

                    // HAJDE DA OVDE OBRATIM PAZNJU NA Request
                    // 1. KAO STO VIDIM Request JE OVDE KONZUMIRAN OD STRANE fetch-A JEDNOM
                    // 2. KAO STO VIDIM, KONZUMIRAN JE I OD STRANE CACHE-A, DRUGI PUT

                    // DAKLE OVDE JE NJEGOV BODY, KOJI JE STREAM, KONZUMIRAN DVA PUTA

                })
            })
        })
    )
});


self.addEventListener('activate', function(ev){
    // CISCENJE SVIH STARIJIH CACHE-A, KOJI SE NE KORISTE
    // ODNOSNO CISTIM SVE CACHE-OVE, CIJI STRINGOVI IMENA NISU CLANOVI NIZA KOJEG SKLADISTI
    //                                                                          cacheWhitelist     VARIJABLA

    ev.waitUntil(
        self.caches.keys()
        .then(function(keys){
            return Promise.all(
                keys.map(function(cacheName){
                    if(!cacheWhitelist.includes(cacheName)){
                        return self.caches.delete(cacheName);
                    }
                })
            )
        })
    );
});


self.addEventListener('fetch', function(ev){

    // NECU OVOG PUTA KREIRATI URL INSTANCU
    // const url = new URL(ev.request.url);
    //  DA JE JESAM KREIRAO, NJU BIH MOGAO KORISTITI KAO ARGUMENT Cache.match METODE, ILI fetch METODE


    ev.respondWith(
        self.caches.open('page-static-cache-v1')
        .then(function(cache){
            // PROVERAVAM PRVO CACHE, I SERVIRAM Response IZ CACHE-A, AKO JE DOSTUPAN U CACHE-U
            return cache.match(ev.request)
            .then(function(response){
                // DAKLE, AKO RESPONSE POSTOJI U CACHE-U, BICE RETURNED
                return response;
                // U SUPROTNOM ERROR CE BITI CACHED OD STRANE catch METODE

            })
            .catch(function(err){
                // AKO NE POSTOJI RESPONSE, NISU CACHED ASSET-I, KOJI SU ZATRAZENI
                // I POTREBNO JE FETCH-OVATI FAJL SA DRUGOG MESTA (JER FAJL NIJE CACHED)

                return self.fetch(ev.request)
                .then(function(response){
                    return response;
                })
            })
        })
    )

});

```