# PRE NEGO STA BILO KAZEM OVDE, MORAM RECI DA SE FAJL MOZE UPLOAD-OVATI IZ MOJE APLIAKCIJE I TAKO STAVITI U FIREBASE STORAGE, STO SAM RADIO U, DRUGOM PROJEKTU; A formidable PAKET, KOJI JE SLUZIO ZA EXTAHOVANJE DATA-E IZ FormData INSTANCE, KOJU SALJEM

TO SAM VEC RADIO U ONOJ REACT APLIKACIJI; TAK ODA U BUDUCNOST KORISCENJE FormData NECE DOLAZITI U OBZIR

JER FIREBASE, PRETRPEO PROMENE I NE MOZE SE VISE KORISTITI formidable PAKET

>>>> [Node.js doesn't have a built-in multipart/form-data parsing library.](https://cloud.google.com/functions/docs/writing/http#multipart_data)
>>>>  Instead, we can use the ['busboy'](https://www.npmjs.com/package/busboy) library from NPM to parse these requests.

DAKLE PAKET, KOJI BI TREBALO DA RADI JESTE busboy PAKET

## OVDE CU DAKLE POPRAVITI CODE MOJE CLOUD FUNKCIJE, KOJA JE TREBALA DA RECEIVE-UJE FORM DATA; A PROBLEMI SU NASTALI ZBOG KORISCENJA PAKETA formidable; ON SE NAIME VISE NE MOZE KORISTITI, JER JE FIREBASE PRETRPEO NEKE PROMENE

RECENO JE DA formidable NE RADI VISE ZA GOOGLE CLOUD FUNCTIONS IZ ISTOG RAZLOGA ZASTO NE RADI I [multer](https://www.npmjs.com/package/multer) PAKET

*ZASTO NE RADI POMENUTI PAKET, NE MOGU NIGDE NACI ODGOVOR, ALI U REDU JE JER MI I NETREBA (DAKLE ODGOVOR ZASTO NE RADI formidable MORAM NACI NEGDE DRUGDE (ALI NIJE NI BITNO JER ZNAM ZA PAKET KOJI FUNKCIONISE))*

PRE SVEGA JA CU OVDE OSTAVITI NEKE VALIDNE INFORMACIJE, KOJE SE TICU, KORISCENJA STORAGE-A

ALI OBRATICU PAZNJU I NA NEKE PROMENE, KOJE SU SE DESILE U FIREBASE-U

OVDE CES DO ODREDJENOG NIVO KORISTITI I ODREDJENE Node.js FEATURE-E, ODNOSNO API-EVE

ALI GOTOVO SVA OBJASNJENJA ZA ON OSTO CU KORISTITI MOZES NACI U [DOKUMENTACIJI ZA API-JEVE Node.js-A](https://nodejs.org/api/)

## :exclamation::exclamation::exclamation::exclamation: POSTO CE SE U MOM APP KORISTITI PAKET @google-cloud/storage, NA SLEDECEM LINKU, :exclamation: POGRESNO JE OBJASNJENA :exclamation: INTEGRACIJA GOOGLE CLOUD PLATFORME SA FIREBASE-OM; ZATO STO OBJASNJENJE VAZI ZA STARI API :exclamation::exclamation::exclamation::exclamation:

:exclamation::exclamation:[Integrate with Google Cloud Platform (NECE FUNKCIONISATI (FIREBASE MORA DA UPDATE-UJE SVOJU DOKUMENTACIJU))](https://firebase.google.com/docs/storage/gcp-integration):exclamation::exclamation:

## :white_check_mark::white_check_mark::white_check_mark: OBJASNJENJE NA SLEDECEM LINKU CE ZAISTA OBJASINTI PODESAVANJE CREDENTIAL VEZANOG ZA @google-cloud/storage; OVO OBJASNJENJE MOGU KORISTITI I AKO JE REC O INTEGRACIJI, KOJA SE TICE NEKE DRUGE PLATFORME, A NE FIREBASE; ONO STO CES VIDETI JESTE DA JE FIREBASE DOSTA STVARI URADIO ZA TEBE U OVOM POGLEDU, ZATO STO JE FIREBASE IPAK GOOGLE-OVA PLATFORMA :white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark:

[google cloud storage CREDENTIALS](https://cloud.google.com/docs/authentication/production#auth-cloud-explicit-nodejs)

ONO STO BI TE ZANIMALO NA OVOJ STRANICI JESTE NASLOV `Obtaining and providing service account credentials manually`

**U SUSTINI POTREBNO JE GENERIJANJE json FAJLA NA KOME SU CREDENTIALS**

**E PA FIREBASE JE TO VEC URADIO ZA TEBE**

**TAJ JSON FAJL SE VEC NALAZI U functions FOLDERU, POD IMENOM**

:arrow_right: *instaclone-fb-key.json*

*TAK ODA **NE MORAS OPET GENERISATI TAJ FAJL** (ALI AKO GA GENERISES NISTA NISI POGRESIO, I TVOJ PROJEKAT CE IMATI OPET DODATNI SET CREDENTIAL INFORMACIJA (TOKENA I OSTALIH STVARI))*

## STA SE TU MOZE ZAKLJUCITI: PA KADA IMAS FIREBASE PROJEKAT, ON JE KREIRAN KROZ 'GOOGLE CLOUD INFRASTRUKTURU', JER KAD ODES NA GOOGLE DEVELOPER CONSOLE, SVE PROJEKTE, KOJE SI KREIRAO KROZ FIREBASE, MOZES NACI I TAMO U GOOGLE DEVELOPER KONZOLI, KOJA IMA SJAJNE MOGUCNOSTI

[OVAJ CLANAK IMA DOSTA DOBRIH INFORMACIJA O TOME](https://medium.com/google-developers/whats-the-relationship-between-firebase-and-google-cloud-57e268a7ff6f)

PA RECIMO TAMO GDE SAM ZA MOJ PROJEKAT MOGAO [PODESAVATI CREDENTIALS]; TAM OJE USTVARI CELA KONZOLA GOOGLE OPCIJA KOJE MOGU PODESAVATI

NA PRIMER U [GOOGLE DEVELOPER KONZOLI](https://console.developers.google.com/apis) **MOGU SEARCH-OVATI GOOGLE API-EVE I SERVISE, KOJE ONDA MOGU ENABLE-OVATI ZA MOJ APP**

**SECAS SE DA SI NA TOM MESTU ENABLE-OVAO I [OAuth](https://github.com/Rade58/apis_trying_out_and_practicing/blob/master/FIREBASE%20AND%20AWS/FIREBASE%20I%20REACT%20%28KROZ%20PROJEKAT%29/PROJEKAT/I%29%20AUTHENTICATION/3.%20OAuth%20Sign%20In%20SA%20GOOGLE-OM.md#star2star2star2star2-uspeo-sam-da-popravim-gore-pomenuto-tako-sto-sam-upload-ovao-logo-u-oauth-consent-screen-tab-u-localhost-nije-bio-problem-star2star2star2star2)**

## MISLIM DA SAM JA U OVOM PROJEKTU KORISTIO FIREBASE NA STARI NACIN, A ONO STO NISAM URADIO JESTE INICIJALIZACIJA FIREBASE APP-A DIREKTNO U MOM PROJEKTU, CIME 'POVEZUJEM' MOJ APP SA FIREBASE-OM; STO MI OMOGUCAVA LAKSE KORISCENJE FIREBASE FEATURE-A U MOM APP, I LAKSE HANDLE-OVANJE NETWORK REQUEST-OVA U CLOUD FUNKCIJAMA, KOJE STIZU IZ MOG APP

KADA REGISTRUJEM MOJ APP KAO FIREBASE APP, NA PLATFORMI TO MI OLAKSAVA POSAO, JER SE NE MORAM BAVITI DODATNIM PROBLEMIMA

TO JE NAIME 'TWO WAY STREET' STO SE TICE CLOUD FUNKCIJA

IDEM U FIREBASE KONZOLU I BIRAM SETTING-SE (MALI ZUPCANIK)

ODATLE MOGU REGISTROVATI MOJ APP KAO FIREBASE WEB APLIKACIJU (MOGUCE SU OPCIJE I ZA NATIVE APP ITD)

U SUSTINI SVE MI JE PROVIDED

A TO STO JE PROVIDED POTREBNO JE EMBED-OVATI U MOJ PAGE

DAKLE KOPIRAM SLEDECE STVARI U MOJ PAGE, PRI DNU body ELEMENTA, PRE NEGO SE U BILO KOJIM SCRIPT-OVIMA MOJE APLIKACIJE, BUDE KOORISTIO FIREBASE

```HTML
<!-- The core Firebase JS SDK is always required and must be listed first -->
<script src="https://www.gstatic.com/firebasejs/6.3.5/firebase-app.js"></script>

<!-- KADA MOJ APP CODE-IRAM UZ POMOC BUNDLER-A KAO STO JE WEBPACK, JASNO JE DA 
CU PREDHODNI SCRIPT UVOZITI KAO MODUL, ALI TO SAM OBJASNIO VEC U DRUGOM PROJEKTU
ZNAS VEC KOJEM -->

<!-- TODO: Add SDKs for Firebase products that you want to use
     https://firebase.google.com/docs/web/setup#config-web-app -->

<script>
  // Your web app's Firebase configuration
  var firebaseConfig = {                                // OVDE SU BILE INFORMCIJE
                                                        // ALI NECU IH PRIKAZATI
                                                        // IAKO TO NISTA I NE ZNACI
                                                        // SMEJU DA BUDU PUBLIC

                                                        // ALI IPAK NAJBOLJE JE KADA KORISTIM NEKI 
                                                        // BUILD SISTEM KAO STO JE WEBPACK
                                                        // DA OVU KONFIGURACIJU UVEZEM KAO JSON
    apiKey: "AIzaSyB76KSNqmgZIJrzSd9QQis-ls",
    authDomain: "instapwBLAH.firebap.com",
    databaseURL: "https://instaBLAHne.firebaseio.com",
    projectId: "insta-pwa-clone",
    storageBucket: "insta-pwa-clone.appspot.com",
    messagingSenderId: "693903166",
    appId: "1:69379966:web:733c23ca6bdba"
  };
  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
</script>

<!-- OVDE SU MOJI OSTAL ISCRIPT-OVI IZ MOG PROJEKTA, A NEKI OD NJIH KORISTE FIREBASE -->
<!-- USTVARI SAMO SALJU REQUEST-OVE DO ENDPOINTA, ODNOSNO DO CLOUD FUNKCIJA -->

<script src="/src/js/material.min.js"></script>
<script src="/src/js/idb.js"></script>
<script src="/src/js/utility.js"></script>
<script src="/src/js/feed.js"></script>
<script src="/src/js/app.js"></script>

<!-- KRAJ body TAGA -->

```

## SADA ONO STO BI TREBALO DA BUDE LAKSE NA STRANI CLOUD FUNKCIJA, JESTE LAKSE HANDLE-OVANJE NEKIH REQUEST-OVA, KONKRETNO MISLIM DA NE MORAM KORISTITI @google-cloud/storage PAKET

NAIME DA NISAM UVEZAO GORNJU KONFIGURACIJU, MORAO BI NA PRIMER U CLOUD FUNKCI DEFINISATI CONFIG FAJL, DIREKTNO NAMENJEN TOM PAKETU

**MORAO BI KORISTITI NEKE DOWNLOAD TOKENE** (uuid)

E PA TO SE SADA OBAVLJA IZA KULISA (KORISCENJEM POMENUTIH config INFORMACIJA) (MISLIM DA SAM TO NAPOMENUO I U DRUGOM PROJEKTU)

**NARAVNO POTREBNO JE INICJALIZOVATI APP I U functions/index.js FAJLU, ALI TO JE ZNATNO JEDNOSTAVNIJE** (USTVARI UPRAVO CE OVO RESITI PROBLEM TOKENA KOJI SE SALJU U SLUCAJU STORAGE-A, BAR PREDPOSTAVLJAM)

I NECU MORATI KORISTITI POMENUTI GOOGLE STORAGE PAKET

## POCECU OD POCETKA, NAIME REDEFINISACU CEO functions/index.js FAJL, JER ZELIM DA UVEZEM TACNO ONE STVARI, KOJE CU KORISTITI, ZATIM CU SVE DEFINISATI I U SKLADU SA MODERNOM SINTAKSOM

>>> KADA DEPLOY-UJEM FUNKCIJE A NE KORISTIM MODERNU SINTAKSU, FIREBASE MI POKAZUJE WARNING-E
>>> PROVERI TAKODJE DA LI JE Node.js 8 U UPOTREBI ZA TVOJ PROJEKAT
>>> AKO NIJE UPDATE-UJ, ONAKO KAKO SAM TO POKAZAO U DRUGOM PROJEKTU

**MEDJUTIM HAJDE DA PRVO URADIM INSTALIRANJE I UPDAT-OVANJE PAKETA** (OVO MOGU RADITI U MOM package.json FAJLU) (NE ZNA MDA LI JE OVO ZATO STO SE ONI KORISTE NA CLIENT-U (NE SECAM SE DA LI SE KORTISTE NA CLIENT STRAN IAL ICU SAZNATI KASNIJE))

**NEKA URADICU TO I U MOM functions/package.json FAJLU, ALI I ONOM functions/package.json**

TAKODJE OVE PAKETE BI TREBAL ODA IMAM GLOBALNO (NE ZNAM ZASTO, ALI ZA SADA IH NECU INSTALIRATI GLOBALNO JER IH VEC IMAM), A UVEK ZELI MDA IH INSTALIRAM NA LATEST VERZIJU

DAKLE INSTALIRAM IH LOKALNO (MISLIM DA IH MOGU INSTALIRATI SAMO U package.json FAJLU)

ALI INSTALIRACU IH I U functions.package.json ,JER SU OD RANIJE TAMO INSTALIRANI, A JA ZELIM LATEST VERZIJU

- npm install firebase-functions@latest firebase-admin@latest --save

(ALI IPAK MISLIM DA SU POTRENE INSTALACIJE NA DVA MESTA, AKO ZELIM DA KORISTIM TE PAKETE LOKALNO ALI I ZA CLOUD-U (FUNCTIONS))

**TAKODJE CU U functions INSTALIRATI I [busboy](https://www.npmjs.com/package/busboy) PAKET**

- npm install --save busboy

**formidable MOZES UKLONITI**

- npm uninstall formidable --save

**PAKETE fs, os, path DOLAZE SA Node-OM, I NJIH SAMO UVOZIM**

**MOZES OPET DA UPDATE-UJE cors PAKET (functions FOLDER) (`npm install --save cors`)**

**OD RANIJE SI IMAO PAKETE web-push I TAKODE I uuid-v4 (TAJ PAKET BI TREBALO DA BUDE KORISCEN ZAJEDNO SA @google-cloud/storage PAKETOM, KOJ ISAM ODLUCIO DA NE KORISTIM) (uuid-v4 PAKET NIGDE NIJE REGITROVAN (NECU GA ISNTALIRATI NITI UPDATE-OVATI ((POSTOJE TAKODJE MNOGI DRUGI PAKETI ZA uuid, ALI NJMA CU SE POZABAVITI NA NEKO MDRUGOM PROJEKTU))))**

SADA DA KONACNO POCNEM SA REDEFINISANJEM

functions/index.js FAJL:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
// dakle uveza osam dva pomenuta paketa

// SADA MOGU INICIJALIZOVATI APP I NA CLOUD STRANI, BAS KAO STO SAM OBECAO
admin.initializeApp(functions.config().firebase)


// HAJDE DA ODMAH UZEMEM STORAGE, NA KORISCENJE, I TO MOGU URADITI TAKO STO PRIMENIM storage
// FUNKCIJU NAD admin-OM
const storage = admin.storage();

// INSTALIRAO SAM RANIJE busboy (UKLONIO SAM formidable, ON MI NAIME NECE TREBATI)
// SAD GA UVOZIM
const Busboy = require('busboy');

// TREBACE MI I PAKETI KOJI SU VEC NATIVNI ZA Node.js
const file_system = require('fs')
const os = require('os');
const path = require('path');

// NARAVNO, KORISTICU cors
const cors = require('cors')({origin: true})

const UUID = require('uuid-v4');            // IMAM OSECAJ DA OVAJ PAKET NESTO NE VALJA, AL IVIDECU (MEDJUTIM MISLIM DA GA I NECU KORISTITI)
                                            // OVAJ PAKET SE KORISTI ZAJEDNO SA '@google-cloud/storage' PAKETOM

// OVO SU PAKETI KOJI SU NEOPHODNI ZA PUSH, AL ITO SAM OBJASNJAVAO RANIJE
const webpush = require('web-push');

// TU SU I VAPID KLJUCEVI
const privateVapidKey = "oC8DBLahIEEzbmom6BtrF6z7_rVY";
const publicVapidKey = "BMfwPHbn5_YXc0wZZu5xEIIhs40w8CDWGnf2HSq-v-vS_m122NEFkIgcDWDRgFzvr";
// NARAVNO KLUCEVI NISU PRAVI, JER NECU DA IH PRIKAZUJEM U md FAJLOVIMA 

// OVDE CU STATI SA DEFINISANJEM, JER ZELIM DA DEFINISEM SECURITY RULES ZA STORAGE
```

## DEFINISANJE SECURITY PRAVILA SA STORAGE

EVO KAKVA PRAVILA ZELIM DA DEFINISEM:

```javascript
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    
    match /photos/{photoURL} {
        
        allow read;

        allow write;

    }
  
  }
}
```

DAKLE DOZVOLIO SAM READ I WRITE U SPECIFICIRANOM FOLDERU

**OBRATI PAZNJU DA SAM DEFINISAO PRAVILA ZA**

- photos FOLDER U, JEDINOM DEFAULT BUCKETU

- {photoURL} JE VARIJABLA I PREDSTAVLJA URL FAJLA (TACNIJE IME FAJLA U photos FOLDERU)

*TO IMAJ U VIDU JER CE TI TREBATI, KADA BUDES DEFINISAO UPLOAD FAJLA*

## STO SE TICE CLIENT SIDE CODE-A, JA SAM DEFINISAO DA SE PODACI SALJU KROZ indexedDB (OBJECT STORE 'sync-posts'); A IZ SERVICE WORKER-A, ON sync PODACI SE PROSLEDJUJU DO CLOUD FUNKCIJE; STO ZNACI DA SE 'POST' REQUEST OBAVLJA U OBIMU POMENUTOG ON sync HANDLER-A, GDE SE UZIMA DATA IZ OBJECT STORE-A, I PRAVI SE S NJIAM 'POST' REQUEST, ALI UZ KORISCENJE FormData INTERFACE-A

HAJDE DA OPET POGLEDAM CODE public/src/js/feed.js

ZELIM DA VIDIM CODE KOJI SE ODNOSI NA STAVLJANJE DATE U indexedDB U 'sync-posts' OBJECT STORE

```javascript
const sendData = function(){    // FALLBACK FUNKCIJA, KOJA SE POZIVA AKO BROWSER NE PODRZAVA BACKGROUND SYNC

    /* const dataObject = {
        id: new Date().toISOString(),
        title: titleInput.value,
        location: locationInput.value,
        image: 'https://firebasestorage.googleapis.com/v0/b/instapwaclone.appspot.com/o/burgers_food.jpeg?alt=media&token=001349ec-8c02-4c16-87df-9db24b252256'
    } */

    // POMENUTI OBJEKAT MI DAKLE VISE NIJE POTREBAN, JER CU UMESTO NJEGA KORISTITI FormData

    const postData = new FormData();   // INSTANTICIZIRAO SAM GA

    // APPENDUJEM MU PRVO SVE PODATKE IZ TEKSTUALNIH INPUT-A (NARAVNO I id)

    postData.append('id', new Date().toISOString());
    postData.append('title', titleInput.value);
    postData.append('location', locationInput.value);

    // A SADA APPEND-UJEM I Blob (SKALDISTI GA picture GLOBALBNA VARIJABLA, KAO STO JE POZNATO);

    // 1. ARGUMENT JE KLJUC, A KLJUC KOJI CE BITI NJEGOV (Blob-OV), U FORM DATA-U, NEKA SE ZOVE file, POSTO TAJ Blob REPREREZENTUJE FILE SLIKE
    // A MOGA OSAM ZADATI BILO KOJI KLJUC

    // 2. ARGUMENT, JESTE Blob INSTANCA naravno

    // 3. ARGUMENT JE IME KOJE ZELIM DA IMA, FAJL, KOJI POMENUTI BLOB REPREZENTUJE 

                // NEKA TO IME BUDE FORMIRANO OD ONIH PODATKAK KOJE SU FORMIARALI id

                // PLUS MIME TYPE FAJLA, KOJEG REPREZENTUJE Blob (OVO SE ODNOSI NA FORMAT SLIKE (jpg, jpeg, png..))

    postData.append(
        'file',
        picture,
        postData.get('id') + "." + picture.type.match(/^(image\/)([a-z]+)/)[2]
    )


    fetch('https://us-central1-instapwaclone.cloudfunctions.net/storePostData', {
        method: "POST",
        /* body: JSON.stringify(dataObject), */   // OVO DAKLE VISE NECU KORISTITI OVDE

        // U BODY-JU, TREBA DA BUDE         FormData        INSTANCA

        body: postData,

        /* headers: {                                // OVO HEADERS-I MI VISE NE TREBAJU
            "Content-Type": "application/json",      // JER NE SALJEM JSON STRING
            "Accept": "application/json"
        } */

        // STO SE TICE HEADERS-A, ONI POSTOJE ZA FormData

        //  "Content-Type": "application/x-www-form-urlencoded"        // ALI NECU KORISTITI

    })
    .then(resp => {
        console.log("Send Data: ", resp);
        // updateUI(dataObject)                // OVDE VIDIM GRESKU, JER UI UPDATE-UJEM PODACIMA, KOJIH VISE NEMA
                                         // REDEFINISACU OVO KASNIJE
        // PREDPOSTAVLJAM DA SE UI MOZE UPDAT-OVATI SA
        // PODACIMA OPET VRACENIM SA SERVERA, AKO JE REQUEST BIO USPESAN
    }) 

    // ALI UPAMTI DA JE OVAJ FALLBACK DEFINISAN OVAKO, A CLOUD FUNCTION NIJE REDEFINISANA DA RECEIVE-UJE FormData

    // ZATO OVO NECE FUNKCIONISATI, AKO BUDE POZVANO

    // REKAO SAM VEC RANIJE, ZASTO SAM OVO ~~~NAMERNO~~~~ UERADIO


};


const titleInput = document.querySelector('input#title');
const locationInput = document.querySelector('input#location');
const form = document.querySelector('div#create-post form');

form.addEventListener('submit', ev => {

    ev.preventDefault();


    if(titleInput.value.trim() === "" || locationInput.value.trim() === ""){
        alert("Please enter valid data!");

        return;
    }

    closeCreatingPostModal();   // RANIJE DEFINISANA FUNKCIJA U ISTOM FAJLU
                                // KADA SE SUBMITT-UJE FORMUALR, ODMAH SE SKALNJA MODAL NA KOJEM JE FORMULAR


    if('serviceWorker' in window.navigator && 'SyncManager' in window){    // AKO OVO NIJE ISPUNJENO, DOLE SE POZIVA
                                                                            // POMENUTI FALLBACK
        // OVDE CU POSLATI I SLIKU, ZAJEDNO SA OSTALIM PODACIMA

        navigator.serviceWorker.ready
        .then(swr => {
            
            // PODACI PUNE sync-posts OBJECT STORE, I TEK CE SE VADITI IZ SERVICE WORKER-A I TEK CE SE ONDA
            // NAKON INSTANTICIZIRANJA FormData INSTANCE, DEFINISATI KACENJE (TO JEST TO SAM VEC TAMO I DEFINISAO)
            // append METODOM, PODATKAK NA FormData INSTANCU, KOJA CE BITI POSLATA DO CLOUD FUNKCIJE (ENDPOINT-A)

            let post = {
                id: new Date().toISOString(),
                title: titleInput.value,
                location: locationInput.value,

                slika: picture    // DAKLE I blob INSATANCA SNAPSHOTA // (OVA INSTANCA JE RANIJE PROCITNAN SA CANVASA
                                  // KOJI JE CAPTURE-OVAO STREAM KAMERE)
                                  // BITI POSLATA U indexedDB
            }

                                // TO SAM URADIO ZBOG ONOG STO SAM VEC MNOGO PUTA OBJASNIO
                                // ALI RECI CU OPET
                                // ZELIM DA ISTATICIZIRAM       FormData    SA OVIM PODACIMA
                                // ALI U SERVICE WORKERU (ON sync HANDLER)

            writeData('sync-posts', post)

            .then(() => {
                
                // OVDE CU NAMERNO STAMPATI         picture
                // JER ZEIM DA SE POIGRAVAM, ODNOSNO DA ISPITUJEM POMENUTI Blob
                // U KONZOLI (MOGU DA GA NAINIM VREDNOSU temp VARIJABLE I TAK OSE POIGRAVAM)

                console.log("OVO JE BLOB SLIKE; IGRAJ SE S NJIM BLAH:", picture);

                return swr.sync.register('sync-new-post');
            })

            .then((syncRegistration) => {

                let snackbarContainer = document.querySelector('#confirmation-toast');
                let data = {message: "Your post was saved for synching!"};

                snackbarContainer.MaterialSnackbar.showSnackbar(data)

            })
            .catch(err => {
                console.log(
                    err, "STORING POST IN IndexedDb WAS UNSUCCESSFUL!, OR REGISTRATION OF SYNC TASK"
                );
            })

        })

    }else{

        sendData();         // KAO STO SAM REKAO POZIVA SE FALLBACK
    }

})
```

PRIKAZUJEM SAV BACKGROUND SYNC CODE SERVICE WORKERA, JER SE TAMO PODACI VADE IZ indexedDB-JA I PRAVI SE NETWORK REQUEST KA END POINT-U ('POST' REQUEST NARAVNO)

public/sw.js FAJL:

```javascript
self.addEventListener('sync', function(ev){

    console.log('--+---+-- SyncEvent --+---+--+---+-   ', ev);

    if(ev.tag === 'sync-new-post'){  // NARAVNO, AKO JE TRIGGER-OVAN sync EVENT, RELATED SA POMENUTOM REGISTRACIJOM
                                     // MOGU OVAJ STRING NAZVATI I REGISTRATION TAG-OM, TU JE DOSTUPAN, DA BIH ZNAO
                                     // STA DA VADIM IZ indexedDB-JA (SVE OBJASNJENO RANIJE)

        ev.waitUntil(                       // SERVICE WORKER DAKLE CEKA DOK SE SLEDECE NE IZVRSI (SVE OBJASNJENO VEC)

            readAllData('sync-posts')      // CITAM ONE PODATKE, KOJI SU POTREBNI ZA SLANJE SERVER-U (OBJASNJENO RANIJE)

            .then(dataArray => {            // DAKLE POSTOJI MOGUCNOST DA JE VISE OBJEKATA UBACENO U OBJECT STORE       'sync-posts'
                                            // A JA OVDE SALJEM POST REQUEST, ZA SVAKI POJEDINACNI OBJEKAT IZ OBJECT STORE-A
                                            // JER SAM ACCESS-OVAO SVIM OBJEKTIMA IZ OBJECT STORE-A

                for(let data of dataArray){


                    // REKAO SAM RANIJE DA CU OVDE INSTATICIZIRATI I FormData INSTANCU, ALI JE NECU SLATI SERVERU

                    const postData = new FormData();   // INSTANTICIZIRAO SAM GA (USTVARI BICE INSTATICIZIRAN U SVAKOJ ITERACIJI)
                                                       // ZA SVAKI EXTRACTED OBJECT IZ OBJECT STORE-A

                    // SADA IZ ODREDJENOG OBJEKTA (ODNOSNO OBJEKTA TRENUTNE ITERACIJE), KOJE JE OBJECT, OBJECT STORE-A  sync-posts
                    // EXTAHUJEM PODATKE

                    // FormData-I , PRVO APPEND-UJEM SVE PODATKE IZ TEKSTUALNIH INPUT-A (NARAVNO I id)

                    postData.append('id', data.id);
                    postData.append('title', data.title);
                    postData.append('location', data.location);

                    // A SADA APPEND-UJEM I Blob

                    // 1. ARGUMENT JE KLJUC, A KLJUC KOJI CE BITI NJEGOV (Blob-OV), U FORM DATA-U, NEKA SE ZOVE file, POSTO TAJ Blob REPREREZENTUJE FILE SLIKE
                    // A MOGA OSAM ZADATI BILO KOJI KLJUC (MEDJUTIM, POSTO SAM 'file' ZDAO I U FALLBACK-U, ONDA TO RADIM I OVDE (NE SME BITI RAZLIKE))

                    // 2. ARGUMENT, JESTE Blob INSTANCA naravno

                    // 3. ARGUMENT JE IME KOJE ZELIM DA IMA, FAJL, KOJI POMENUTI BLOB REPREZENTUJE

                                // NEKA TO IME BUDE FORMIRANO OD ONIH PODATKAK KOJE SU FORMIARALI id

                                // PLUS MIME TYPE FAJLA, KOJEG REPREZENTUJE Blob (OVO SE ODNOSI NA FORMAT SLIKE (jpg, jpeg, png..))

                    postData.append(
                        'file',

                        data.slika,          // ~~~~~~  U SVAKOM OBJEKTU, IZ, POMENUTOG OBJECT STORE-A,
                                             //         Blob     JE STORED KAO U PROPERTIJU slika ~~~~~~
                                             // TO SMA OBJASNIO (URADIO) GORE U on submit HANDLERU (feed.js FAJL)

                        postData.get('id') + "." + data.slika.type.match(/^(image\/)([a-z]+)/)[2]
                    )

                    // ~~~~~~~~~~~~~~~~~~~ DAKLE NECU GORNJI OBJEKAT (postData) SLATI NA SERVER,
                    // ~~~~~~~~~~~~~~~~~~~ ALI CU GA STAMPATI DA VIDIM OD CEGA SE SASTOJI
                    // ~~~~~~~~~~~~~~~~~~~ ODNOSNO PRIMENJIVACU METODE FormData-INOG PROTOTIPA NA NJEMU
                    // ~~~~~~~~~~~~~~~~~~~ GET-OVACU IZ NJEGA Blob   MOJE CAPTURED SLIKE (SNAPSHOT-A), UZ POMOC KLJUCA     file
                    // ~~~~~~~~~~~~~~~~~~~ PA CU NAD Blob INSTANCOM PRIMENJIVATI NEKE METODE

                                            // SVE CE TO BITI MOGUCE U CHROME KONZOLI, ZATO STO U CHROME KONZOLI
                                            // JA MOGU DESNIM CLICK-OM IZABRATI DA SE ZELENI ODSTAMPANI OBJEKAT
                                            // STORE-UJE U TRENUTNOJ VARIJABLI

                    //-----------------------------------------------------------
                            // DAKLE STAMPAM        FormData        INSTANCU
                    // console.log(postData);

                    //              

                    // STAMPACU GETTED      Blob        FROM FORM DATA
                    // console.log("-*-*-*-*-*-*-*", postData.get('file'), "-*-*-*-*-*-*-*-*-");

                    //-----------------------------------------------------------


                    fetch('https://us-central1-instapwaclone.cloudfunctions.net/storePostData', {
                        method: "POST",
                        /* body: JSON.stringify({             // !!!! DAKLE OVO JE ONO STO CU MENJATI (ALI NE SADA, VEC TEK KAD DEFINISEM SERVER SIDE CODE)
                            id: data.id,                   // !!!! POSTO ZELIM DA PODATKE SALJEM KROZ FormData INSTANCA (DAKLE, ZELIM DA ONA BUDE U BODY-JU)
                            title: data.title,             // !!!! JA NE ZELIM STRINGIFIED OBJEKAT, KOJI JE SADA OVDE
                            location: data.location,       // !!!! ZAELI FormData INSTANCU, SA ONIM BLOB-OM, KAO SASTAVNIM DELOM

                                                           // ~~~~~~~  ALI JA CU OVO TEK MENJATI ONDA KADA BUDEM SREDIO SERVER SIDE CODE

                            image: 'https://firebasestorage.googleapis.com/v0/b/instapwaclone.appspot.com/o/burgers_food.jpeg?alt=media&token=001349ec-8c02-4c16-87df-9db24b252256'

                            // OVO JE BIO DUMMY IMAGE I ZATO JE OVO HARD CODED URL, KAKO GA NAZIVAJU
                        }),
                        headers: {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        } */

                        body: postData
                    })
                    .then(resp => {
                        console.log("Send Data: ", resp);

                        if(resp.ok){

                            deleteItemFromData('sync-posts', data.id)     // KADA SU PODACI USPESNO POSLATI DO CLOUD FUNKCIJE,
                                                                          // ONI VISE NISU POTREBNI U indexedDB-JU  (OBJASNIO VEC RANIJE)
                        }


                    })
                    .catch(function(err){
                        console.log('Error, while sending data', err)
                    })

                }
            })
        );
    }
})
```

## :arrow_upper_right: MALO CU DA GOVORIM O MODULIMA os, fs I path, KOJE SAM UVEZAO U MOJ SERVER SIDE CODE

TI MODULI SU MODULI KOJI DOLAZE ZAJEDNO SA Node.js-OM

RECI CU NESTO O NJIMA I ZASTA CU IH UPOTREBLJAVATI U MOM PROJEKTU

:one: ['os'](https://nodejs.org/api/os.html#os_os) PAKET MOZE PRUZITI INFORMACIJE O OPERATIVNOM SISTEMU KOJI JE U UPOTREBI (MISLI SE NA OPERATIVNI SISTEM SERVERA, PREDPOSTAVLJAM)

[ako ne verujes pogledaj ovaj primer](https://www.w3schools.com/nodejs/shownodejs_cmd.asp?filename=demo_ref_os)

MENI IZ OVOG PAKETA ZANIMA MOGUCNOST DA PRISTUPIM INFORMACIJAM TEMPORARY STORAGE-A OPERATIVNOG SISTEMA

**UPRAVO KADA blob STIGNE DO SERVER-A, PREDPOSTAVLJAM DA JE NJEGOV RELATED FAJL, SMESTEN U TEMP DIREKTORIJUM**

E PA MOGU KORISTITI os PAKET, TACNIJE [os.tmpdir()](https://nodejs.org/api/os.html#os_os_tmpdir), KAKO BI PRISTUPIO TEMPORARY DIREKTORIJUMU

ZAPAMTI DA SE TAMO NALAZI TVOJ FAJL

**AKO ZNAS IME FAJLA I AKO SI PRISTUPIO, POMENUTOM DIREKTORIJUMU, MOZES INICIRATI UPLOAD FAJAL U WritableStream**

MISLIM DA CE MI OVO BITI JASNIJE, KADA VIDIM STA CE TO USTVARI URADITI, PRI KORISCENJU SA busboy

JER BUSBOY CE EXTRAHOVATI NEKE PODATKE O Blobu, KAO STO SU fieldname, file, filename, encoding, mimetype

**ALI MEDJU TIM PODACIMA NECE BITI INFO O TEMP DIREKTORIJUMU WINDOWS-A, U KOJEM JE MOJ FILE (IMAGE FILE)**

I UPRAVO ZBOG POMENUTE METODE OS JA CU ZNATI PATH TEMP DIREKTORIJUMA

:two: ['path'](https://nodejs.org/api/path.html#path_path) 

>>> The path module provides utilities for working with file and directory paths. It can be accessed using:

OVAJ MODUL IMA NOGO METODA A MENE ZANIMA TRENUTNO SAMO [join()](https://nodejs.org/api/path.html#path_path_join_paths) METODA

```javascript
path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');
// Returns: '/foo/bar/baz/asdf'
```

TI ZAKLJUCI CEMU SLUZI, PREDHODNA METODA

:three: 'fs' ODNOSNO [File System](https://nodejs.org/api/fs.html)

>>> The fs module provides an API for interacting with the file system in a manner closely modeled around standard POSIX functions (NE ZNAM STA JS [POSIX](https://www.php.net/manual/en/ref.posix.php))

PREDPOSTAVLJAM POSIX ZNACI: ' Process Control Functions'

OD OVOG PAKETA CU KORISTITI [createWriteStream()](https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options) FUNKCIJU

**IZ ONOGA STO SAM SAZNAO, SHVATIO SAM DA OVA FUNKCIJA PRAVI *WritableStream* INSTASNCU** (ONO STO JA ZNAM JESTE DA JE BODY, NEKOG REQUEST, UVEK ReadableStream)

NAIME U MOM SLUCAJU JA CU FUNKCIJI DODATI *PATH* **(SASTAVLJEN OD FOLDERA U TEMP FOLDERU SERVERA (GDE SE FAJL NALAZI, NAKON STIZANJA DO SERVERA), I IMENA FAJLA)**

I S TIM CU KREIRATI WritableStream INSTANCU

[WritableStream](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream) JE ABSTRAKCIJA ZA UPISIVANJE STREAMING PODATAKA U DESTINACIJU

PREDPOSTAVLJAM DA JE OVO FINAL COG U PROCESU UPLOADING-A: WRITING U WRITABLE STREAM, KOJI KASNIJE MOGU KORISTITI KAKO BI UPLOAD-OVAO FAJL NA ZELENO MESTO (FIREBASE STORAGE U MOM SLUCAJU)

KASNIJE SE NA SAMOM FAJLU, PRIMENJUJE pipe METODA;

>>>> Calling the [stream.pipe()](https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options) method to send the data to a Writable

ONA SE USTVARI PRIMENJUJE NA [ReadableStream](https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options)-U, KOJI CE MI BITI DOSTUPAN PRI KORISCENJU BUSBOY-A

## :dash::dash::dash::dash: SADA MOGU ODPOCETI SA DEFINISANJEM UPLOADING-A FAJLA I ZADAVANJA NJEGOVOG URL-A, DA BUDE DEO RELATED POST-A U REALTIME DATABASE-U; ALI IMA JEDAN PROBLEM, JER SAM MISLIO DA MOGU UPLOAD-OVATI FAJL BEZ KORISCENJA '@google-cloud/storage' PAKETA :dash::dash::dash::dash:

SASVIM JE JASNO IZ CODE, MOG APP-A DA ONO STA SE SALJE CLOUD FUNKCIJI JESTE FormData INSTANCA

SADA TREBAM UPOTREBITI busboy PAKET KAKO BI HANDLE-OVAO TAJ DATA, A POSEBNO Blob INSTANCU, KOJU SALJEM EMBEDED INSIDE FormData INSTANCE

**NAIME TU Blob INSTANCU NE MOGU KORISTITI NA SERVER STRANI**

**ONO STA MOGU KORISTITI JESTE PATH FAJLA U TEMP FOLDERU CLOUD-OVOG OPERATIVNOG SISTEM-A (TAMO JE SMESTEN FAJL POS STIZANJU DO CLOUD FUNKCIJE)**

:point_right: PROBLEM: *FIREBASE storage API NE MOZE KORISTITI, POMENUTI PATH KAO ARGUMENT*

ODNOSNO **storage.Reference.put()** KAO ARGUMENTE MOZE IMATI SLEDECE TIPOVE VREDNOSTI

- Blob | Uint8Array | ArrayBuffer

- NIAKO **TO NE MOZE BITI PATH DO FAJLA U TEMP FOLDERU**, OPERATIVNOG SISTEMA CLOUD-A

**ZATO MORAM INSTALIRATI @google-cloud/storage PAKET, U MOM functions FOLDERU**

- npm install '@google-cloud/storage'@latest --save

DA SADA KRENEM SA DEFINISANJEM U:

functions/index.js FAJLU

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');

// admin.initializeApp(functions.config().firebase)     // OVDE SAM RANIJE DEFINISAO DA SE APP INICIJALIZUJE

// MEDJUTIM VIDEO SAM DA SE I OVAKO INICIJALIZUJE APP
// KORISCENJEM
// serviceAccount TO JE NAIME ONAJ JSON OBJEKAT, KOJI SE NALZAI U finctions FOLDERU
// U IMENEU IMA          fb-key         ODREDNICU
// U TOM FAJLU SE NALAZE RAZNE INFORMACIJE, KEY-EVI, TOKENI, INFO O ADMIN-U (MOZES I SAM POGLEDATI)
// MISLIM DA JE OVO INFO O MOM ACCOUNT-U (DEVELOPER-OVOM  ACCOUNT-U)
const serviceAccount = require('./instaclone-fb-key.json')

// JA PREDPSOTAVLJAM DA JE MOJE, GORNJE, INICIJALIZOVANJE, KOJE SAM SADA COMMENTED OUT
// USTVARI UNDER THE HOOD, ODREADILO  SVE OVO RUCNO

// !!! ILI ZELIM DA INICIJALIZUJEM APP, TEK KADA, TEK KADA KONFIGURIRAM GOOGLE STORAGE 


// ****************** OVO JE POTREBNO ZA KORISCENJE GOOGLE CLOUD STORAGE-A
// NAIME PREKO GOOGLE CLOUD STORAGE-A JA MOGU PRISTUPITI MOM BUCKETU U FIREBASE-U
// MEDJUTIM KAKO BI TO OMOGUCIO MORAM KONFIGURIRATI GOOGLE STORAGE

// ZA TO MI TREBA MOJ               projectId       I      keyFilename      

//       projectID    MOGU PRONACI U FIREBASE KONZOLI U SETTINGS(MALI ZUPCANIK) u General TAB-U

//       keyFilename  JE POMENUTI JSON FAJL, KOJ ISAM GORE UVEZAO KAO serviceAccount (MENI TREBA SAMO IME FAJLA)

//  ps.      projectId SI MOGAO PRONACI U, POMENUTOM JSON FAJLU (TAMO JE POBROJAN I PROJECT ID IZMEDJU OSTALIH INFO)

const gcsConfig = {keyFilename: 'instaclone-fb-key.json', projectId: 'instapwaclone'}


const UUID = require('uuid-v4');            // OVO SE KORISTI UZ '@google-cloud/storage' TAKODJE, STO CEU KORISTITI
                                            // PRI UPLOAD-U

// SADA DA UVEZEM I KONFIGURIRAM GOOGLE-CLOUD STORAGE (ODNOSNO POZIVAM UVEZENU FUNKCIJU SA KONFIGURACIJSKIM OBJEKTOM)

const gcs = require('@google-cloud/storage')(gcsConfig);

// SADA DA INICIJALIZUJEM APP, TAK OSTO CU PRVO DEFINISATI credential
// TO CU DEFINISATI TAKO STO CU  admin.credentials.cert     POZVATI SA ONIM JSON-OM (serviceAccount VARIJABLA)

// OSTALE PROPERTIJE MOGU PREKOPIRATI SA FIREBASE CONSOLE/ Settings(zupcanik)/ General/YourApps 

admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
    //
    apiKey: "AIzaSyB76KSNqmgZIJrzSd9QQ8kyL1DX8Qis-ls",
    authDomain: "instapwaclone.firebaseapp.com",
    databaseURL: "https://instapwaclone.firebaseio.com",
    projectId: "instapwaclone",
    storageBucket: "instapwaclone.appspot.com",
    messagingSenderId: "693799903166",
    appId: "1:693799903166:web:733c23cb06a6bdba"
})


// OPET NAPOMINJEM DA JE        admin.initializeApp(functions.config().firebase)            MOZDA, SVE POMENUTO
//                                                                                      DEFINISALA UNDER THE HOOD

//****************************************************************************************************** */                                            

const storage = admin.storage(); // STORAGE JE SADA OVDE VISAK, ALI NEKA GA, IAKO GA NECU KORISTITI
                                    // ON DAKLE NEMA MOGUCNOSTI DA IZ TEMP FOLDERA SERVER, UPLOAD-UJE FAJL
                                    // PATH SE NE MOZE, KAO RAGUMENT DODATI PRIMENI  put()-A, NA REFERENCI BUCKET-A
// ALI ONO STO HOCU KORISTITI
// A STO SAM MOZDA PREVIDEO, JESTE FIREBASE-OV REALTIME DATABASE
// KAKO BI NAKON STO UPLOAD-UJEM FILE, JA USTVARI SVE FILED-OVE I FAJL-OV (ODNOSNO IMAGE-OV) URL
// DODAO KAO NOVI 'posts' OBJEKAT U REAL TIME DATBASE-U

const database = admin.database();

// ************************************************************************************************************
const Busboy = require('busboy');

const file_system = require('fs')
const os = require('os');
const path = require('path');

const cors = require('cors')({origin: true})



//***************PROMENI NA LAZNE */
const privateVapidKey = "oC8DBLahIEnXF6z7_p7JerU6rVY";
const publicVapidKey = "BMfwPHbn5_YXc0wZZu5xEIIDWGnf2HSq-vAGVOZMLhgcDSM";
//******************************** */


// DAKLE SADA KREIRAM ENDPOINT, ODNOSNO KREIRAM CLOUD FUNKCIJU storePostData

// PRE NEGO STO KRENES TRBA DA ZNAS DA ZELIS DA SLIKU UPLOAD-UJES OVDE:

//                          /photos/{photoURL}

// JER SAM ZA TO MESTO DOZVOLIO UPLOAD (KORISCENJEM SECURITY PRAVILA)

//                  
// A IME FOTOGRAFIJE, ODNOSNO VARIAJBLA U GORNJEM PATH-U, BICE FORMIRANA OD ID-JA, KOJEG SALJEM SA FormData
// TO CU DEFINISATI PRI SAMOM UPLOAD-U

exports.storePostData = functions.https.onRequest((request, response) => {

    // I POSTO KORISTIM cors (ODMAH CE GORNJI PARAMETRI BITI ARGUMENTI cors-A)

    cors(request, response, async () => {   // NEKA CALLBACK BUDE async FUNKCIJA

        const uuid = UUID();     // OVO CE MI IPAK BITI POTREBNO
        
        // INSTATICIZIRAM Busboy, SA HEADER-SIMA PRISTIGLIM SA REQUEST-OVIM HEADERS-IMA
        // NE BRINI SE PRAVI HEADDER JE POSLAT ZA FormData, IAKO NISAM SPECIFICIRAO
        // BROWSER GA OBEZBEDJUJE PO DEFAULTU 

        const busboy = new Busboy({headers: request.headers})

        // !!!!!!!!!!!!!! KASNIJE ODLUCIO DA NE KORISTIM!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // HAJDE DA UZMEM REFERENCU FOLDERA, U KOJI ZELIM DA STAVIM SLIKU, ODNONS GDE ZELI MDA JE UPLOAD-UJEM
        const folder = storage.ref('photos')   // JA SAM POKAZAO U JEDNOM DRUGOM PROJEKTU GDE SE OVDE
                                                // BILO VISE FOLDERA (ZA SVAKOG USERA PO JOS FOLDER)
                                                // TO MISLIM DA AKO POSMATRAJUCI ARGUMENT POMISLIM NESTO
                                                // DA JE NESTO DRUGO DODATO (DODAT JE PATH)
                                                // TO JE PATH DO FOLDERA U BUCKET-U
                                                // POSTOJI JEDAN JEDINI DEFAULT BUCKET
                                                // KAO STO SAMO POSTOJI JEDAN DEFAULT REALTIME DATABASE
                                                // ILI FIRESTORE
        // (POMENUTO SAM ODLUCIO DA KASNIJE I NE KORISTIM, JER KAO STO SAM REKAO VRSICU UPLOAD
        // PREKO GOOGLE-CLOUD STORAGE-A (JER MI POMENUTI FIREBASE-OVA API NE DOZVOLJAVA, KORISCENJE
        // PATH-A DO TEMP FAJL-A)
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    
        // SLEDECA VARIJABLA TREBA DA SKLADISTI JEDAN OBJEKAT (ODNOSNO DA GA REFERENCIRA)
        // KASNIJE TOM OPBJEKTU CU DODATI
        //                              -    PATH DO TEMP FOLDERA, KORISNIKOVOG OPERATIVNOG SISTEMA

        //                              -    I MIME TYPE, FAJLA

        const upload = {tempFilePath: "", mimeType: ""};

        // SLEDECA VARIJABL, KOJU CU DEKLARISATI, TREBA DA 'PRIKUPI' SVE FIELDNAME-OVE, SA NJIHOVIM VREDNSOTIMA
        // TO JE ONO STO SAM DODAO KAO KEY VALUE PAROVE ZA FormData (POTICE OD TITLE-A I CONTENTA POST-A)

        const fields = {};


        // SADA REGISTRUJEM BUSBOY-OV EVENT HANDLER, U CIJEM OBIMU TREBAM DOBITI INFO O FAJLU, KOJI JE POSLAT,
        // KAO BLOB
        // CALLABCK JE INVOKATED ZA SVAKI FILE KOJI JE DETECTED

        // I ON ZAPOCINJE USTVARI SAVING

        busboy.on('file', (fieldName, fileStream, fileName, encoding, mimeType) => {

            // KREIRAM PRVO POTPUNI PATH FAJLA NA NJEGOVOM TEMP MESTU (U FOLDERU OPERATIVNOG SISTEMA SERVER-A)
            // ON JE NAIME STAVLJEN U TAJ DIREKTORIJUMU NAKON STIZANJA DO MOG CLOUD FUNCTIONA
            const tempFilePath = path.join(os.tmpdir(), fileName);

            // SADA ZADAJEM DA TEMPORARY PATH BUDE VREDNSOT, JEDNOG PROPERTIJA ONOG upload OBJEKTA
            // A DODAJEM I mimeType, TOM OBJEKTU
            
            upload.tempFilePath = tempFilePath;     // OVO JE MOGLO LEPSE UZ SKARACENU OBJECT SINTAKSU ES6
            upload.mimeType = mimeType;             // (TADA upload NE SME BITI KONSTANTA, A I NE MORA)
                                                    // ALI NEKA SE SVE OVAKO LEPO VIDI

            // POTREBNO JE READBALE STREAM 'PIPE-OVATI' U WRITABLE STREAM ZA MOJ IAMGE
            
            fileStream.pipe(file_system.createWriteStream(tempFilePath));

            // OVDE MOGU STAMPATI I SVE ARGUMENTE (POKUSACU DA MOJ CLOUD FUNCTION RUNN-UJEM LOKALNO
            // MOZDA MI USPE PA SAM ONDA U MOGUCNOSTI DA SAGLEDA MSVE OVE ARGUMENTE, OD CEGA SE SASTOJE)
            console.log({fieldName, fileStream, fileName, encoding, mimeType})

        })

        // DAKLE IU PREDHODNOM CALLBACK-U DEFINISAO SAM UPISIVANJE FAJLA U WRITABLE STREAM


        // SLEDECI CALLBACK, KOJI ZELIM DA REGISTRUJEM, TREBALO BI DA SE INVOCIRA NA SVAKI DETECTION
        // FIELD-A EXTRACTED IZ FormData-E

        busboy.on('field', (fieldName, value, fieldNameTruncated, valTruncated, encoding, mimeType) => {
            // fieldNameTruncated PARAMETAR (BOOLEAN) (TO ZNACI SKRACNO IME FIELD-A)

            // PRI SVAKOJ ENVOKACIJI, ODNOSNO PRI SVAKOJ DETEKCIJI FIELD-A
            // FIELD I NJEGOVA VREDNOST, TRBALI BI DA POSTANU KEY VALUE PAR
            // fields OBJEKTA, KOJI SAM DEKLARISAO IZVAN OVOG HANDLERA, GORE

            fields[fieldName] = value;

        })

        // SECAS SE DA SI INICIRAO WRITING TVOG FAJLA U WRITABLE STREAM
        // U SLEDECEM CALLBACK-U, ODNOSNO HANDLERU, KOJI CE SE INVOCIRATI, ONDA KADA
        // SE FAJL BUDE POTPUNO UPISAO U WRITABLE STREAM
        // JA MOGU ISKORISTITI, TAJ WRITABLE STREAM KAKO BI UPLOAD-OVAO FAJL

        busboy.on('finish', () => {
            // DAKLE, KAO STO SAM REKAO, KADA SE ZAVRSI UPLOUD U TEMP FOLDER
            // PREDPOSTAVLJAM KADA SE ZAVRSI I GORNJE CITANJE FIELD-OVA

            // TREBA DA SE TRIGGER-UJE OVAJ CALLBACK

            // SADA MOGU DA DEFINISEM UPLOAD, TAK OSTO CU
            // IZMEDJU OSTALOG NAVESTI, GDE SE FAJLA SADA NALAZI
            // (TO RADIM U OKVIRU GOOGLE CLOUD STORAGE API-A)

            // PRISTUPICU MOM FIREBASE DEAFULT BUCKETU (DEFAULT BUCKET ZA MOJ PROJEKAT)
            // ALI TO RADIM KAO STO REKOH PREKO GOOGLE CLOUD API-A

            const bucket = gcs.bucket('instapwaclone.appspot.com'); // KAO ARGUMENT SAM DODAO URL MOG BUCKETA
                                            // STO MOGU NACI U Storage SKCIJI FIREBASE KONZOLE
                                            // ALI IMAM GA I GORE U CODE-U
            
            // SADA DEFINISEM UPLOAD
            // OD ARGUMENTA CU KORITITI;

            //                                          -     PATH FAJLA GDE SE ON NALAZI U TEMP FOLDERU
            //
            //                                          -     ZATIM OBJEKAT, U KOJEM CU IZMEDJU OSTALOG
            //                                                  DEFINISATI NOVO IME FAJLA, ALI I METADATA
            //                                                  U OKVIRU TOG OBJEKTA DODAJEM I uuid

            //                                          -     CALLBACK KOJI SE IZVRSAVA AKO JE
            //                                                  FILE USPESNO UPLOADED ILI NIJE
            
            // HAJDE DA PRVO KREIRAM OPTIONS OBJEKAT

            const uploadOptions = {
                destination: `photos/${fields.id}.${upload.mimeType}`, // SECAS SE DA SI SECURITY PRAVILA DEFINISAO
                                            // TAKO DA DOZVOLJAVAS WRITE I READ FAJLA SAMO U
                                            // photos FOLDERU TOVOG BUCKET-A
                uploadType: 'media',
                metadata:{
                    metadata: {
                        contentType: upload.mimeType,
                        firebaseStorageDownloadTokens: uuid       
                    }
                }
            }
            
            // SADA UPLOAD-UJEM

            bucket.upload(
                upload.tempFilePath,     // OVO JE PATH FAJLA GDE JE ON SADA
                
                uploadOptions,

                async (error, uploadedFile) => {   // CALLBACK KOJI SE IZVRSAVA, NAKON USPESNOG ILI NEUSPESNOG DOWNLOAD-A
                                             // I DEFINISAO SAM DA TO BUDE async FUNKCIJA
                                             // MISLIM DA CU LAKSE S NJOM SVE DEFINISATI
                    if(error){
                        
                        console.log(error)
                        return `Error: ${error} FAJL NIJE UPLOADED`;

                    }else{

                        // UZIMAM REFERENCU, MOG OBJECT STORE-A 'posts' U REALTIME DATBASE-U
                        const postsRef = database.ref('posts')

                        // !!!!!!!!!!!!!!!!!!!!!!!!    OVO JE VAZNO   !!!!!!!!!!!!!!!!!!!!!!
                        // TVOJE IME SLIKE JE FORMIRANO OD          id-JA       POST-A
                        // TVOJE IME POST-A JE FORMIRANO OD         new Date().toISOString()
                        // 
                                //          OVO ZNACI DA SE SPECIJALNI KARAKTERI MOGU NACI
                                //          U IMENU FAJLA

                                // KADA BUDES IME FAJLA KORISTIO U URL-U
                                // MORACES ENCODE-OVATI TE SPECIJALNE KARAKTERE


                                // SECAS SE KADA SI NA GITHUBU ZADAVAO URL-OVE, SA SPECIJALNIM
                                // KARAKTETRIMA, KAO STO SU ZAGRADE ( , SECAS SE DA NISI MOGAO
                                // KORISTIURL SA SPECIJALNIM KARAKTERIMA, DOK NISI DEFINSIAO ENCODING
                                // ZAGRADA U URL-U, JE MORALA BITI '%24' I SLICNO

                                // E PA TAKAV id, ODNOSNO IME FAJLA JE POTREBNO ENCODE-OVATI JEDNOM FUNKCIJOM
                                //      encodeURIComponent()

                                // TA FUNKCIJA SE MOZE KORISTITI ODMAH U Node.js-U

                        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                        // SADA STAVLJAM SVE PODATKE U DATABASE, U POMENUTI OBJECT STORE

                        await postsRef.push(        // SADA KORISTIM SVE POMENUTE EXTRAHOVANE FIELD-OVE
                                                    // I NJIHOVE VREDNOSTI
                                                    // A UPLOADED FAJL MI JE DOSTUPAN DA SA NJEGA CITAM
                                                    // NJEGOO IME
                            {
                                id: fields.id,
                                title: fields.title,
                                location: fields.location,
                                // IMAGE URL MORAM FORMIRATI OD 'PARCIJALNIH' INFORMACIJA
                                // DA SAM NA PRIMER KORISTIO admin.storage()
                                image: 'https://firebasestorage.googleapis.com/v0/b/' + 
                                        bucket.name +
                                        '/o/' + encodeURIComponent(uploadedFile) +
                                        "?alt=media&token=" + uuid
                                // DAKEL NA KRAJU KORISTIM uuid KOJI SAM KORISTIO, PRI UPLAOD-U
                                // TAKODJE, KAK OBI FORMIRAO OSTATAK URL-A

                            }
                        )

                        // ODAVDE BI ISAO CODE KOJI JE REZERVISAN ZA PUSH (PODESAVANJE VAPID KLJUCEVA ITD)
                        // ALI TO CU DEFINISATI, TEK KADA DEPLOY-UJEM MOJE CLOUD FUNKCIJE
                        // I VIDIM DA LI MOJ CODE FUNKCIONISE
                        
                        
                        return "File is uploaded";

                    }

                }
            )

        })


    })

})


```

STO SE TICE URL ENCODINGA, KOJI SAM GORE POMENUO ,TREBA DA TI BUDE JASNO DA SI KORISTIO [encodeURIComponent()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) FUNKCIJU, KOJA SE MOZRE KORISTITI U NODE-U, IAKO SAM JOJ JA NASO DOKUMENTACIJU SAMO VEZAN OZA CLIENT, ALI I Node.js IMA TU FUNKCIJU

## DEPLOY-OVACU SADA MOJE CLOUD FUNKCIJE

- firebase deploy --only functions

I MOJA storePostData FUNKCIJA BI SADA TREBALA DA BUDE UPDATED



```javascript
// UVOZIM POMENUTA DVA PAKETA


/* const functions = require('firebase-functions');

const admin = require('firebase-admin');
const cors = require('cors')({
    origin: true
});

const serviceAccount = require("./instaclone-fb-key.json");

const webpush = require('web-push');

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
  databaseURL: "https://instapwaclone.firebaseio.com/"
});

exports.storePostData = functions.https.onRequest(function (request, response) {
	  
	cors(request, response, function () {
    	admin.database().ref('posts').push({
      		id: request.body.id,
      		title: request.body.title,
      		location: request.body.location,
      		image: request.body.image
    	})
		.then(function () {
			webpush.setVapidDetails(
				"mailto:bajic.rade2@gmail.com",
				publicVapidKey,
				privateVapidKey
			);
			return admin.database().ref('subscriptions').once('value');
		})
		.then(function (subscriptions) {
			subscriptions.forEach(function (sub) {
				var pushConfig = {
					endpoint: sub.val().endpoint,
					keys: {
						auth: sub.val().keys.auth,
						p256dh: sub.val().keys.p256dh
					}
				};

				webpush.sendNotification(
					pushConfig,
					JSON.stringify({
                        title: 'New Post',
                        content: 'New Post added!',

                        // DAKLE OVAJ OBJEKAT CE JOS IMATI I       openUrl    PROPERTI
                        // ZADACU RELATIVNI PATH ZA help/index.html PAGE, KOJ JE HOSTED NA ISTOM SERVERU

                        openUrl: '/help'    // NIJE POTREBNO NAVODITI I index.html JER TO JE ONO
                                            // STO SE PO DEFAULTU MORA OTVORITI NA PATH-U
                    })
                )
				.catch(function(err) {
					console.log(err);
				})

			});
			
			return response.status(201).json({message: 'Data stored', id: request.body.id});
		})
		.catch(function (err) {
			response.status(500).json({error: err});
		});
  
	});
}); */






















/* 
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const cors = require('cors')({
    origin: true
});
const serviceAccount = require("./instaclone-fb-key.json");
const webpush = require('web-push');

// *****************************************************

const formidable = require('formidable');

const gcconfig = {
    projectId: 'instapwaclone',
    keyFilename: 'instaclone-fb-key.json'
}

const gcs = require('@google-cloud/storage')(gcconfig);  // OVO JE POGRESNO KORISCENJE PAKETE
                                                         // ILI JE OUTDATED
                                                         // ZBOG POMENUTE STVARI, NECE BITI MOGUC NI DEPLOYMENT
const file_system = require('fs');

const UUID = require('uuid-v4');


const privateVapidKey = "oC8DBLahIEnXnAMEzbmom6BtrF6z7_p7Je3jarU6rVY";
const publicVapidKey = "BMfwPHbn5_YXc0wZZu5xEIIhs40w8CDWGnf2HSq-vAGVOZMLh-vS_m122NEFkIgcDWDRgFzvrBCChNxX_spJoSM";



// ******************************************************


admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
  databaseURL: "https://instapwaclone.firebaseio.com/"
});

exports.storePostData = functions.https.onRequest(function (request, response) {

    cors(request, response, function () {

        // **************************************************

        const formData = new formidable.IncomingForm();   // OBRATI PANJU DA JE OVDE I KARAKTER NAPISAN VELIKIM

        const uuid = UUID();

        formData.parse(request, function(error, fields, files){             // PITANJE JE I DA LI SAM PRAVILNO KORISTIO formidable PAKET

            if(!error){

                admin.database().ref('posts').push({

                    id: fields.id,
                    title: fields.title,
                    location: fields.location,


                    image: 'https://firebasestorage.googleapis.com/v0/b/' + bucket.name + '/o/' +
                            file.name + '?alt=media&token=' + uuid

                })
                .then(function () {
                    webpush.setVapidDetails(
                        "mailto:bajic.rade2@gmail.com",
                        publicVapidKey,
                        privateVapidKey
                    );
                    return admin.database().ref('subscriptions').once('value');
                })
                .then(function (subscriptions) {
                    subscriptions.forEach(function (sub) {
                        var pushConfig = {
                            endpoint: sub.val().endpoint,
                            keys: {
                                auth: sub.val().keys.auth,
                                p256dh: sub.val().keys.p256dh
                            }
                        };

                        webpush.sendNotification(
                            pushConfig,
                            JSON.stringify({title: 'New Post', content: 'New Post added!', openUrl: '/help'}
                        ))
                        .catch(function(err) {
                            console.log(err);
                        })

                    });

                    return response.status(201).json({message: 'Data stored', id: fields.id});
                })
                .catch(function (err) {
                    response.status(500).json({error: err});
                });

            }else{
                console.log(error)
            }


        })

    });
}); */





```