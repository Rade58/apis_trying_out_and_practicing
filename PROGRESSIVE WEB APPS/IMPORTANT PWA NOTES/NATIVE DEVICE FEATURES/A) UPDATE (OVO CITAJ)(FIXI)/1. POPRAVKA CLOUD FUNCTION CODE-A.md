# PRE NEGO STA BILO KAZEM OVDE, MORAM RECI DA SE FAJL MOZE UPLOAD-OVATI IZ MOJE APLIAKCIJE, KORISCENJEM firebase.storage API-A I TAKO STAVITI U FIREBASE STORAGE, STO SAM RADIO U, DRUGOM PROJEKTU, GDE NISAM SLAO FAJL APPENDED NA FormData INSTANCU, STO OVDE SADA, PLANIRAM DA URADIM, ALI TAKODJE CU SE POZABAVITI TIME, KAKO DA KORISTIM OBJEKTE, ODNOSNO BINARY DATA, JER SU ArrayBuffer I Uint8Array VALIDNE INSTANCE, KOJE MOGU BITI UPLOADED U GOOGLE STORAGE

firebase.storage SAM KORISTIO U REACT APLIKACIJI, NA CLENT-U;, PA ZASTO UOPSTE SLATI Blob DO ENDPOINT-A (KAKO BI SE OD TAMO OBAVIO UPLOAD), KADA SE UPLOAD, MOZE INICIRATI DIREKTNO SA CLIENT-A, PRI KORISCENJU FIREBASE-A; KORISCENJE FormData NECE DOLAZITI U OBZIR, JER JE TEZI NACIN, A VIDECU I ZASTO

FIREBASE, JE NA PRIMER PRETRPEO I VELIKE PROMENE, I NE MOZE SE VISE KORISTITI formidable PAKET (PAKET KOJI HANDLE-UJE FormData)

>>>> [Node.js doesn't have a built-in multipart/form-data parsing library.](https://cloud.google.com/functions/docs/writing/http#multipart_data)
>>>>  Instead, we can use the ['busboy'](https://www.npmjs.com/package/busboy) library from NPM to parse these requests.

DAKLE PAKET, KOJI BI TREBALO DA RADI JESTE busboy PAKET (**ALI PRI KARAJU OVOG TEKSTA, VIDECES DA MI NI ON NIJE RADIO (DESILO SE DA FUNKCIJA ODE U TIMEOUT, POSTO SE ODREDJENI EVENT NIJE TRIGGER-OVAO VEZAN ZA BUSBOY)**)

RECENO JE DA formidable NE RADI VISE ZA GOOGLE CLOUD FUNCTIONS IZ ISTOG RAZLOGA ZASTO NE RADI I [multer](https://www.npmjs.com/package/multer) PAKET

*ZASTO NE RADI POMENUTI PAKET, NE MOGU NIGDE NACI ODGOVOR, ALI U REDU JE JER MI I NE TREBA (DAKLE ODGOVOR ZASTO NE RADI formidable MORAM NACI NEGDE DRUGDE (ALI NIJE NI BITNO JER ZNAM ZA PAKET KOJI FUNKCIONISE))*

**A ZASTO BUSBOY NIJE RADIO, JA U NMORU PITANJA NA STACKOVERFLOW-U, NE MOGU NACI ODGOVOR**

PRE SVEGA JA CU OVDE OSTAVITI NEKE VALIDNE INFORMACIJE, KOJE SE TICU, KORISCENJA STORAGE-A

ALI OBRATICU PAZNJU I NA NEKE PROMENE, KOJE SU SE DESILE U FIREBASE-U

OVDE CES DO ODREDJENOG NIVOA KORISTITI I ODREDJENE Node.js FEATURE-E, ODNOSNO API-EVE

ALI GOTOVO SVA OBJASNJENJA ZA ONO STO CU KORISTITI MOZES NACI U [DOKUMENTACIJI ZA API-JEVE Node.js-A](https://nodejs.org/api/)

DA SAZNAM NESTO VISE O FIREBASE PALTFORMI, MOGU CITATI I POSTOVE [Doug-a Stevenson-A](https://medium.com/@CodingDoug) (SAZNAO SAM NEKE VAZNE INFORMACIJE, UPRAVO TAMO)

****

STO SE TICE GOOGLE-CLOUD STORAGE DOKUMENTACIJE, **MISLIM DA SAM OTKRIO NAJBOLJU DOKUMENTACIJU VEZANU ZA Node.js** I AKO ZELIM DA SE NA NAJBOLJI NACIN UPOZNAM SA PAKETOM NAJBOLJE JE CITATI OVU [ZVANICNU DOKUMENTACIJU ZA GOOGLE CLOUD STORAGE Node.js](https://googleapis.dev/nodejs/storage/latest/index.html)

****

## IZ POMENUTE NOVOOTKRIVENE DOKUMENTACIJE O GOOGLE CLOUD STORAGE PAKETU, SAZNAO SAM DA JE IPAK MOGUCE JE KORISTITI INSTANCU SLICNU blobu, KAKO BI SE NA CLOUD STRANI INICIRAO UPLOADING FAJLA

[NKANADNO SAM SAZNAO JESTE DA JE MOGUCE KORISTII](https://github.com/Rade58/apis_trying_out_and_practicing/blob/master/PROGRESSIVE%20WEB%20APPS/IMPORTANT%20PWA%20NOTES/NATIVE%20DEVICE%20FEATURES/A%29%20UPDATE%20%28OVO%20CITAJ%29%28FIXI%29/1.%20POPRAVKA%20CLOUD%20FUNCTION%20CODE-A.md#runningrunningrunningrunning-u-medjuvremenu-otkrio-sam-nesto-sto-je-da-je-uploading-blob-a-na-cloud-strani-moguce-postici-uz-pomoc-google-cloud-storage-api-koriscenjem-jedne-druge-metode-runningrunningrunningrunning), STORAGE-OV [File OBJEKAT](https://googleapis.dev/nodejs/storage/latest/File.html), KAKO BI SE 'BLOB' MOGAO KORISTITI (FILE OBJEKAT SE DOBIJA KADA NA BUCKETU PRIMENIM [file()](https://googleapis.dev/nodejs/storage/latest/Bucket.html#file) METODU)

**TAK ODA GDE GOD SAM SPOMENUO DA POMENUTO NIJE MOGUCE U NASTAVKU TEKSTA, SADA MOGU TO OPOVRGNUTI I RECI DA TO NIJE TACNO I DA POSTOJI METODA GOOGLE CLOUD STORAGE-A, SA KOJOM MOGU HANDLE-OVATI FAJL NA CLOUD STRANI**

*I OPET I U TOM SMISLU GOOGLE CLOUD STORAGE PAKET UNDER THE HOOD RADI MNOGE STVARI ZA MENE*

## NAIME JA CU U MOM PROJEKTU KORISTITI @google-cloud/storage PAKET (KOJI I NE MORAS UVOZITI, VIDECES ZASTO; A ZASTO KORISTITI DRUGI PAKET, AKO IMAM PRISTUP STORAGE-U KROZ FIREBASE-OV storage API? PA NEMAN NA CLOUDU PRISTUP firebase.storage LIBRARY-JU; ON JE NAIME SAMO CLIENT LIBRARY; JER KADA UZMEM storage, PREKO admin-A NA CLOUD-U (admin.storage()) ONO STO SE USTVARI KORISTI JESTE @google-cloud/storage PAKET

NACIN KOJI MAXIMILAN SHVARTZMILER KORISTI: (OVO MENI NIJE FUNKCIONISALKO ZBOG NEKOLIKO PAKETAM, KOJE JE KORISTIO, I KOJI ZA MENE NISU FUNKCIONISALI)

ON JE NAIME AUTOR POJEKTA, I ON JE ODLUCIO DA DEFINISE SLANJE FormData DO ENDPOINT-A, A NA FormData INSTANCI TREBA DA BUDE APPENDED IMAGE FILE (Blob); PORED PROBLEMA STO CLOUD NEMA NACINA DA HANDLE-UJE FormData

GOOGLE CLOUD STORAGE API PRIHVATA PATH ARGUMENT; KOJI BI BIO PATH DO FAJLA, KOJI BI SE NAKON STIZANJA DO CLOUD FUNKCIJE, UPLOAD-OVAO U TEMPORARRY FOLDERU CLOUD OS-A

>> 'BLOB' STAVLJAM POD NAVODNIKE, JER TO I NIJE USTVARI BLOB U KLASICNOM SMISLU (PREDPOSTAVLJAM)

OVO ZNACI DA JE ACTUAL FAJL, PO STIZANJU DO CLOUD-A, SMESTEN USTVARI U TEMPORARY FOLDER-U, CLOUD-OVOG OPERATIVNOG SISTEMA

E TU BUSBOY STUPA NA SCENU KOJI CE PARSE-OVATI FormData, I NA KRAJU TREBALO BI DA DODJEM DO PATH-A FAJLA  U TEMP FOLDER-U (U TOME CE UCESTVOVATI API-JEVI Node.js-A, O KOJIM ACU GOVORITI)

@google-cloud/storage API JE NESTO KOMPLIKOVANIJI ZBOG KORISCENJA UUID PAKETA (KORISCENJA TOKEN-A ZA UPLOAD I FORMIRANJE URL-A`)

**SADA NESTO O firebase.storage LIBRARY-JU, KOJI SE KORISTI NA CLIENT-U**

NAIME KADA SE UPLOAD-UJU FAJLOVI, POMOCU firebase.storage API-A, MOGU SE KORISTITI SLEDECE TIPOVE VREDNOSTI ZA FAJL:

- Blob  ([put](https://firebase.google.com/docs/reference/js/firebase.storage.Reference.html#put) METODA)

- Uint8Array (ISTA METODA KAO GORE)

- ArrayBuffer (ISTA -||-)

- Base64 STRING ([putString](https://firebase.google.com/docs/reference/js/firebase.storage.Reference.html#put-string) METODA))

A NE MOZE PRIHVATATI, SAMO PATH DO LOKACIJE U KOJOJ BI FAJL BIO TEMPORARY ,KAO STO TO RADI @google-cloud/storage

## :exclamation::exclamation::exclamation::exclamation: POSTO CE SE U MOM APP KORISTITI PAKET @google-cloud/storage, NA SLEDECEM LINKU, :exclamation: POGRESNO JE OBJASNJENA :exclamation: INTEGRACIJA GOOGLE CLOUD STORAGE-A SA FIREBASE-OM; ZATO STO OBJASNJENJE VAZI ZA STARI API :exclamation::exclamation::exclamation::exclamation: MEDJUTIM SVEJEDNO JE, JER NECU INSTALIRATI, POMENUTI PAKET, JER GA VEC IMAM KROZ admin.storage() NA CLOUD-U

**ALI AKO U NEKOM PROJEKTU KORISTIM google-cloud/storage** (NA PRIMER NEKI PROJEKAT, KOJI NECE BITI CONNECTED TO FIREBASE), ZNAM DA OVO NE VALJA (BAR NIJE VALJALO NA OVOM LINKU, U AVGUSTU 2019. GODINE)

:exclamation::exclamation:[Integrate with Google Cloud Platform (NECE FUNKCIONISATI (FIREBASE MORA DA UPDATE-UJE SVOJU DOKUMENTACIJU))](https://firebase.google.com/docs/storage/gcp-integration):exclamation::exclamation:

## :white_check_mark::white_check_mark::white_check_mark: OBJASNJENJE NA SLEDECEM LINKU CE ZAISTA OBJASINTI PODESAVANJE CREDENTIAL VEZANOG ZA @google-cloud/storage; OVO OBJASNJENJE MOGU KORISTITI I AKO JE REC O INTEGRACIJI, KOJA SE TICE NEKE DRUGE PLATFORME, A NE FIREBASE; ONO STO CES VIDETI JESTE DA JE FIREBASE DOSTA STVARI URADIO ZA TEBE U OVOM POGLEDU, ZATO STO JE FIREBASE IPAK GOOGLE-OVA PLATFORMA :white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark:

[google cloud storage CREDENTIALS](https://cloud.google.com/docs/authentication/production#auth-cloud-explicit-nodejs)

ONO STO BI TE ZANIMALO NA OVOJ STRANICI JESTE NASLOV `Obtaining and providing service account credentials manually`

**U SUSTINI POTREBNO JE GENERIJANJE json FAJLA NA KOME SU CREDENTIALS**

**E PA FIREBASE JE TO VEC URADIO ZA TEBE**

**TAJ JSON FAJL SE VEC NALAZI U functions FOLDERU, POD IMENOM**

:arrow_right: *instaclone-fb-key.json*

*TAK ODA **NE MORAS OPET GENERISATI TAJ FAJL** (ALI AKO GA GENERISES NISTA NISI POGRESIO, I TVOJ PROJEKAT CE IMATI OPET DODATNI SET CREDENTIAL INFORMACIJA (TOKENA I OSTALIH STVARI))*

## STA SE TU MOZE ZAKLJUCITI: PA KADA IMAS FIREBASE PROJEKAT, ON JE KREIRAN KROZ 'GOOGLE CLOUD INFRASTRUKTURU', JER KAD ODES NA GOOGLE DEVELOPER CONSOLE, SVE PROJEKTE, KOJE SI KREIRAO KROZ FIREBASE, MOZES NACI I TAMO U GOOGLE DEVELOPER KONZOLI, KOJA IMA SJAJNE MOGUCNOSTI; A STO SE TICE @google-cloud/storage PAKETA, OPET PONAVLJAM DA GA NA CLOUD-U IMAS KROZ admin.storage()

[OVAJ CLANAK IMA DOSTA DOBRIH INFORMACIJA O VEZI IZMEDJU GOOGLE CLOUD-A I FIREBASE-A](https://medium.com/google-developers/whats-the-relationship-between-firebase-and-google-cloud-57e268a7ff6f)

PA RECIMO TAMO GDE SAM ZA MOJ PROJEKAT MOGAO [PODESAVATI CREDENTIALS]((https://cloud.google.com/docs/authentication/production#auth-cloud-explicit-nodejs)); TAMO JE USTVARI CELA KONZOLA GOOGLE OPCIJA KOJE MOGU PODESAVATI

NA PRIMER U [GOOGLE DEVELOPER KONZOLI](https://console.developers.google.com/apis) **MOGU SEARCH-OVATI GOOGLE API-EVE I SERVISE, KOJE ONDA MOGU ENABLE-OVATI ZA MOJ APP**

**SECAS SE DA SI NA TOM MESTU ENABLE-OVAO I [OAuth](https://github.com/Rade58/apis_trying_out_and_practicing/blob/master/FIREBASE%20AND%20AWS/FIREBASE%20I%20REACT%20%28KROZ%20PROJEKAT%29/PROJEKAT/I%29%20AUTHENTICATION/3.%20OAuth%20Sign%20In%20SA%20GOOGLE-OM.md#star2star2star2star2-uspeo-sam-da-popravim-gore-pomenuto-tako-sto-sam-upload-ovao-logo-u-oauth-consent-screen-tab-u-localhost-nije-bio-problem-star2star2star2star2)**

## MISLIM DA SAM JA U OVOM PROJEKTU, PRE NEGO STO SAM SE DOVOLJNO DOBRO UPOZNAO SA FIREBASE-OM, UPRAVO KORISTIO FIREBASE NA STARI NACIN, A ONO STO NISAM URADIO JESTE INICIJALIZACIJA FIREBASE APP-A DIREKTNO U MOM PROJEKTU, CIME 'POVEZUJEM' MOJ APP SA FIREBASE-OM; STO MI OMOGUCAVA LAKSE KORISCENJE FIREBASE LIBRARY-JA (MORAM NJIH POSEBNO UVESTI) U MOM APP-U, I LAKSE HANDLE-OVANJE NETWORK REQUEST-OVA U CLOUD FUNKCIJAMA, KOJE STIZU IZ MOG APP, KADA KORISTIM LIBRARY NA CLIENT STRANI, PREKO CIJIH METODA, MOGU SLATI REQUEST-OVE

KADA REGISTRUJEM MOJ APP KAO FIREBASE APP, NA PLATFORMI, TO MI OLAKSAVA POSAO, JER SE NE MORAM BAVITI DODATNIM PROBLEMIMA

TO JE NAIME 'TWO WAY STREET' STO SE TICE CLOUD FUNKCIJA

IDEM U FIREBASE KONZOLU I BIRAM SETTING-SE (MALI ZUPCANIK)

ODATLE MOGU REGISTROVATI MOJ APP KAO FIREBASE WEB APLIKACIJU (MOGUCE SU OPCIJE I ZA NATIVE APP ITD)

U SUSTINI SVE MI JE PROVIDED

A TO STO JE PROVIDED POTREBNO JE EMBED-OVATI U MOJ PAGE

DAKLE KOPIRAM SLEDECE STVARI U MOJ PAGE, PRI DNU body ELEMENTA, PRE NEGO SE U BILO KOJIM SCRIPT-OVIMA MOJE APLIKACIJE, BUDE KOORISTIO FIREBASE

```HTML
    <!-- The core Firebase JS SDK is always required and must be listed first -->

<script src="https://www.gstatic.com/firebasejs/6.3.5/firebase-app.js"></script>

    
    <!-- KADA MOJ APP CODE-IRAM UZ POMOC BUNDLER-A KAO STO JE WEBPACK, JASNO JE DA 
    CU PREDHODNI SCRIPT UVOZITI KAO MODUL, ALI TO SAM OBJASNIO VEC U DRUGOM PROJEKTU
    ZNAS VEC KOJEM (REACT) -->

    <!-- TODO: Add SDKs for Firebase products that you want to use
        https://firebase.google.com/docs/web/setup#config-web-app -->



<script>
  // Your web app's Firebase configuration
  var firebaseConfig = {
      // NEMA VEZE STO PRIKAZUJEM OVAJ INFO, OVE
      // ALI IPAK BI BILO BOLJE OVAJ OBJEKAT UVOZITI KAO JSON (ALI TO MOGU RADITI, KADA APP PRAVIM UZ POMOC 
      // BUILD SYSTEMA, KAO STO JE WEBPACK, GDE MOGU KORISTITI ESM)

    //  !!!!!!!!!!!!!!!!|||||||||||||||||!!!!!!!!!!!!!!!!!!!||||||||||

    //        USTVARI UVEK OVAJ OBJEKAT UVOZI KAO JSON; TO NAIME MALICIOZNOM KORISNIKU NECE OTEZATI DA
    //        DA OVO PRONADJE JER JE MOJ CODEBASE NA IZVOLITE ALI, MIISLIM DA CE OTEZTI STVARI

    //          OVO SAM UVIDEO JER JE MOGUCE SA LOCALHOT-A SLATI DATA U STORAGE PUTEM storage LIBRARY-JA
    //           ILI KORISTITI FIRESTORE, PREKO firestore DATBASE-A
    //
    //          AKO MALICIOZNI KORISNIK IMA OVAJ OBJEKAT, ON MOZE SA LOCALHOST-A RADITI RAZNE STVARI
    //          MOM DATBASE-U, FIRESTORE-U, STORAGE-U
    //
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!///////////////////////********

    apiKey: "AIzaSyB76KSNqmgZIJrzSd9QQis-ls",
    authDomain: "instapwBLAH.firebap.com",
    databaseURL: "https://instaBLAHne.firebaseio.com",
    projectId: "insta-pwa-clone",
    storageBucket: "insta-pwa-clone.appspot.com",
    messagingSenderId: "693903166",
    appId: "1:69379966:web:733c23ca6bdba"
  };
  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
</script>


<!-- SECAS SE DA SI TI NA CLIENT STRANI, U ONOM REACT-OVOM PROJEKTU, USTVARI KORISTIO LIBRARY-JE FIREBASE-A
 KAO STO SU storage ILI firestore-->

<!--   !!!!!     KADA NE KORISTIM BUNDLER, GDE SU MI DOSTUPNI ESM MODULI (KAO STO JE WEBPACK)
            JA MORAM DODAVATI script TAGOVE, SA KOJIH UCITAVAM LIBRARY CODE     !!!!!!!!       -->

<!-- EVO UVESCU U MOJ PROJEKAT, NEKE FIREBASE LIBRARY-JE -->

                    <!-- storage -->
<script src="https://www.gstatic.com/firebasejs/6.4.0/firebase-storage.js"></script>
                    <!-- firestore -->
<script src="https://www.gstatic.com/firebasejs/6.4.0/firebase-firestore.js"></script>
                    <!-- realtime datbase -->
<script src="https://www.gstatic.com/firebasejs/6.4.0/firebase-database.js"></script>


<!-- GDE DA NADJEM URL-OVE OSTALIH, FIREBASE-OVIH LIBRARY-JA, POKAZAO SAM U TEKSTU POSLE CODE-A -->


<!-- OVDE SU MOJI OSTAL ISCRIPT-OVI IZ MOG PROJEKTA, A NEKI OD NJIH KORISTE FIREBASE -->
<!-- USTVARI SAMO SALJU REQUEST-OVE DO ENDPOINTA, ODNOSNO DO CLOUD FUNKCIJA -->
<!-- A IMA I SLUCAJEVA, KADA PRAVIM HTTP REQUEST-OVE KA REALTIME DATABASE-U -->

<script src="/src/js/material.min.js"></script>
<script src="/src/js/idb.js"></script>
<script src="/src/js/utility.js"></script>
<script src="/src/js/feed.js"></script>
<script src="/src/js/app.js"></script>

<!-- KRAJ body TAGA -->

```

**POMENUTE LINKOVI SA KOJIH, POMOCU SCRIPT TAGOVA, U MOJOJ APLIKACIJI (DAKLE NA CLIENT-U) MOGU UCITATI FIREBASE-OVE LIBRARY-JE** (POPUT database, storage, firestore, functions)

NALAZE SE [NA OVOJ STRANICI](https://firebase.google.com/docs/web/setup#libraries_CDN)

**URL-OVI, POMENUTIH SCRIPT TAGOVA, SU USTVARI URL-OVI SA KOJIH UCITAVAM LIBRARY, A SCRIPT-OVI SE NALAZE NA SYSTEMU SERVER-A, KOJ ISE JOS NAZIVA I [*`CDN`* (*CONTENT-DELIVERY-NETWORK*)](https://www.webopedia.com/TERM/C/CDN.html)** (TO SAM NAVEO DA ZNAM ZA UBUDUCE)

U POMENUTOM [FIREBASE-OVOM GUIDE-U](https://firebase.google.com/docs/web/setup#namespace), OBJASNJENI SU I DRUGI NACINI UVOZA LIBRARY-JA, A TO SU ONI NACINI KADA IH KORISTIM NA STRANI CLIENTA, ONDA KADA KORISTIM BUILD SYSTEM KAO STO JE WEBPACK (ESM MODULI)

ILI KAKO IH UVOZIM U CLOUD FUNCTIONS (CommonJS MODULI)

OBJASNJENI SU I NEKI DRUGI NACINI (NA PRIMER, JA MOGU DOWNLOAD-OVATI LIBRARY I HOST-OVATI GA SA SVOGA DOMENA (PREDPOSTAVLJAM DA JE OVO TACNO))

****

**NARAVNO POTREBNO JE INICJALIZOVATI APP I U functions/index.js FAJLU, ALI TO JE ZNATNO JEDNOSTAVNIJE** 

****

## STO SE TICE INICIJALIZACIJE APP, NA STRANI CLOUD FUNKCIJA, I TO SE ISTO TREBA URADITI; I TU POSTOJI TEZI NACIN (VISE MANUELAN); A I DRUGI 'FIREBASE NACIN', KOJI JE JEDNOSTAVNIJI, JER JE I TO FIREBASE OLAKSAO

```javascript
// EVO GA MANUELNI NACIN

// (1) UVEZEM ONAJ FAJL O KOJEM SAM VEC GOVORIO         instaclone-fb-key.json

// (2) KOPIRAM SVE PROPERTIJE IZ ONOG, GORE POMENUTOG firebaseConfig OBJEKTA, KOJEG SAM KORISTIO
//      ZA INICIJALIZACIJU NA CLIENT STRANI

// I SA TIME INICIJALIZUJEM APP

const serviceAccount = require('./instaclone-fb-key.json');

admin.initializeApp({
    credential: serviceAccount,
    //
    apiKey: "AIzaSyB76KSNqmgZIJrzSd9QQis-ls",
    authDomain: "instapwBLAH.firebap.com",
    databaseURL: "https://instaBLAHne.firebaseio.com",
    projectId: "insta-pwa-clone",
    storageBucket: "insta-pwa-clone.appspot.com",
    messagingSenderId: "693903166",
    appId: "1:69379966:web:733c23ca6bdba"
})

```

OVO SLEDECE BI BIO ONAJ **JEDNOSTAVNI NACIN, PO KOJEM CE firebase INICIJALIZOVATI APP, SA POMENUTIM STVARIMA, STO CE SE OBAVITI UNDER THE HOOD**

```javascript
admin.initializeApp(functions.config().firebase);
```

*KAO STO VIDIM, ZNATNO MANJE CODE-A*

## MISLIM DA IMA JOS JEDAN DOKAZ DA SE ONAJ FIREBASE STORAGE LIBRARY (KOJEG SAM KORISTIO NA CLIENT-U) NE MOZE KORISTITI NA CLOUD STRANI

POGLEDAO SAM [TABELU](https://firebase.google.com/docs/web/setup#namespace) NA OVOM LINK-U

NA TOJ TABELI PRIKAZANO JE KAO DA SE Node.JS NE MOZE KORISTI SA firebase storage-OM

A KADA GLEDAS [REFERENCE DOCUMENTATION](https://firebase.google.com/docs/reference); TI USTVARI U LEVOM MENU-U, MOZES POGLEDATI, KOJE TO API-JEVE MOZES KORISTITI ZA JavaScript (ZA BROWSER) I ZA Node.js (ZA CLOUD)

## CORS PROBLEM VEZAN ZA HTTP REQUESTS

TI SI NAUCIO KAKO DA KORISTIS CLOUD FUNKCIJE NA SLEDECE NACINE

- [onCall](https://github.com/Rade58/apis_trying_out_and_practicing/blob/master/FIREBASE%20AND%20AWS/FIREBASE%20I%20REACT%20%28KROZ%20PROJEKAT%29/PROJEKAT/VIIII%29%20CLOUD%20FUNCTIONS/!!!!%20CORS%20PROBLEM.md#ovde-cu-uggrabiti-priliku-da-upotrebim-jedan-noviji-firebase-ov-cloud-functions-api) (ON ZAHTEVA DA UVEZEM firebase.functions NA CLIENT STRANI I DA KORISTIM API ZA SLANJE REQUEST-OVA, (DAKLE TU SE NE KORISTI fetch-API)) (*VOLIM OVO ZBOG JEDNOSTAVNOSTI*)

- onWrite (OnCreate, onUpdate, onDelete) SE INVOCIRAJU, KADA SE DESI PROMENA U FIRESTORE-U

ALI IMAO SI PROBLEMA ZA **onRequest** I SA [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin)

JER SI TADA SLAO REQUEST-OVE SA RAZLICITIH ORIGIN-A (TVOJE CLOUD FUNKCIJE SU DEPLOYED NA JEDNOM URL-U, A TVOJ APP JE DEPLOYED NA DRUGOM)

MEDJUTIM  I ZA TO POSTOJI **RESENJE** A **NE ZAHTEVA KORISCENJE THIRD PARTY PAKETA, KAO STO JE [cors](https://www.npmjs.com/package/cors)**

U OSTALOM MENI cors PAKET UOPSTE NIJE FUNKCIONISAO, NE ZNAM ZASTO (MOZDA SAM POMISLIO DA SAMO NE FUNKCIONISE, ZBOG MOG LOSEG CODE-A (JEDINO ZNAM DA SAM GA JEDNOM KORISTIO, BEZ PROBLEMAM, A NAKON NEKOG VREMENA NIJE FUNKCIONISAO))

## RESENJE CORS PROBLEMA, KOJE SE OGLEDA U TOME DA SE SAMO TREBA DEFINISATI PAR OPCIJA, U FAJLU firebase.json; I POTPUNE PROMENE URL ZA KOJI SALJEM REQUEST (U SUSTINI TO JE DEFINISANJE REDIRECT-INGA, UNDER THE HOOD, VIDECES I KAKO)

DA POKAZEM TO PREKO PRIMERA

IMAM JEDNU CLOUD FUNKCIJU

```javascript
exports.testFunction = functions.https.onRequest((request, response) => {

    response.status(200).send({podatak: "podatak neki"})

})
```

POKUSACU DA POSALJEM HTTP REQUEST

ZA KOJI ENDPOINT, ODNOSNO NA KOJI URL?

PA NA SLEDECI URL:

**TAMO GDE SU DEPLOYED MOJE FUNKCIJE (TAJ URL NALAZIM U Fuctions TABU FIREBASE KONZLE)**

*PLUS* KROZ(**/**) *PLUS*

**IME MOJE FUNKCIJE (`testFunction`)**

```javascript
// LUPIO SAM OVAKAV URL:           'https://firebase-functions-blah.net'


fetch('https://firebase-functions-blah.net/testFunction')
.then((resp => { console.log(resp.json()) }))

// OVO SALJEM SA CLENT MESTA, ODNOSNO MESTA ODAKLE JE DEPLOYED MOJ APP (DAKLE URL MOJE APLIKACIJE)
// NA PRIMER 'https://moja_aplikacija.com'
```

ONO STO CU DOBITI JESTE ERROR STATUS 500

:x::x::x::x:*No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin '…' is therefore not allowed access...*:x::x::x::x:

I NAPOMINJE ME DA MOGU KORISTI, **mode: *'no-cors'*** DA BI DOBIO **OPAQUE** RESPONSE

:page_with_curl::page_with_curl::page_with_curl::page_with_curl: **RESENJE SE DAKLE OGLEDA U SAMOM DEFINISANJU, NOVIH OPCIJA ZA *firebase.json* FAJLA, I SLANJA REQUESTA NA URL, KOJ IBI SE SASTOJAO OD SLEDECEG** :page_with_curl::page_with_curl::page_with_curl::page_with_curl:

- `URL GDE JE MOJ APP DEPLOYED` **+** `/` **+** `IME FUNKCIJE`

:one: REDEFINISEM *firebase.json* TAK OSTO U **"hosting"** OBJEKTU, U NJEGOVOM **"rewrites"** NIZU, DODAM NOVOG CLANA, A TO JE OBJEKAT SA PROPERTIJIMA *"source"* I *"function"*

- ZA "source" ZADAJEM PATH ZA FUNKCIJU, NA PRIMER OVAKO: **"/testFunction"**

- ZA "function" ZADAJEM IME FUNKCIJE, NA PRIMER OVAKO: **"testFunction"**

```javascript
// firebase.json FAJL

{
  "functions": {
    "predeploy": [
      "npm --prefix \"$RESOURCE_DIR\" run lint"
    ]
  },
  "hosting": {
    "public": "public",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [ {    // OVDE DAKLE
      "source": "/testFunction",
      "function": "testFunction"
    }]
  }
}

```

:two: SADA REQUEST SALJEM NA URL KOJI SE SASSTOJI OD PAGE GDE JE DEPLOYED MOJ APP I IMENA CLOUD FUNKCIJE

OVAKO

```javascript
// MOJ APP JE DEPLOYED NA       'https://moja_aplikacija.com'

// IME FUNKCIJE JESTE           testFunction


fetch('https://moja_aplikacija.com/testFunction')   // VIDIS PROMENJENI URL
.then((resp => { console.log(resp.json()) }))

```

**SADA CE ZAHTEV BITI USPESAN I U KONZOLI CE BITI STAMPANO**    `{podatak: "podatak neki"}`

## NAIME REDEFINISACU CEO functions/index.js FAJL, JER ZELIM DA UVEZEM TACNO ONE STVARI, KOJE CU KORISTITI, ZATIM CU SVE DEFINISATI I U SKLADU SA MODERNOM SINTAKSOM (ZELIM DA KORISTIM ES6, ZA MOJE FUNKCIJE) (STO SE TICE MODULA, KORISTICU CommonJs SINTAKSU, JER JE PODRAZANA, A DA NE RIZIKUJEM SA ESM MODULIMA)

>>> KADA DEPLOY-UJEM FUNKCIJE A NE KORISTIM MODERNU SINTAKSU, FIREBASE MI POKAZUJE WARNING-E, KROZ SVOJ CLI (COMMAND LINE INTERFACE) (ALI NE ZATO STO KORISTIM CommonJs MODULE, VEC ZATO STO NE KORISTIM ARROW FUNKCIJE I ZATO STO MOZDA EMBED-UJEM JEDAN PROMISE U DRUGI, UMESTO DA VRSIM CHAINING)
>>> PROVERI TAKODJE DA LI JE Node.js 8 I VISE U UPOTREBI ZA TVOJ PROJEKAT
>>> AKO NIJE UPDATE-UJ, ONAKO KAKO SAM TO POKAZAO U DRUGOM PROJEKTU, JER UPRAVO TO OMOGUCUJE DA MOGU KORISTITI MODERNU SINTAKSU JAVASCRIPT-A

**MEDJUTIM HAJDE DA PRVO URADIM INSTALIRANJE I UPDAT-OVANJE, NEKIH PAKETA**

**URADICU TO PRETEZNO U MOM functions/package.json FAJLU**

PRVI PAKETI KOJE ZELIM DA INSTALIRAM SU

- firebase-admin

- firebase-functions

**U REACT PROJEKTU, OVE PAKETE SAM KORISTIO I NA CLIENT-U I NA SERVER-U** (ZATO SAM IH TAMO INSTALIRAO I ZA package.json, ALI I ZA functions/package.json)

TAKODJE **OVE PAKETE BI TREBALO DA IMAM GLOBALNO** (MOZDA SAMO IPAK ADMIN-A (ALI INSTALIRAJ OBA)) I UVEK ZELIM DA IH INSTALIRAM NA LATEST VERZIJU

DAKLE INSTALIRAM IH I LOKALNO, NA OBA POMENUTA MESTA

I ON OSTO ZELIM JESU LATEST VERZIJE

- npm install firebase-functions@latest firebase-admin@latest --save

**ADMIN PAKET BI MI TREBAO GLOBALNO ZBOG CLI-A KOJI DONOSI** (DAKLE BICE MI OMOGUCENO DA EXECUTE-UJE U COMMAND LINE-U, STVARI KA OSTO SU DEPLOYMENT ITD.)

(AKO ZELIM functions PAKET LOKALNO MISLIM DA MORAM [DODATI SCRIPT](https://firebase.google.com/docs/web/setup#libraries_CDN))

**TAKODJE CU U functions INSTALIRATI I [busboy](https://www.npmjs.com/package/busboy) PAKET**

- npm install --save busboy

**formidable MOZES UKLONITI**

- npm uninstall formidable --save

**PAKETE fs, os, path DOLAZE SA Node-OM, I NJIH SAMO UVOZIM**

**MOZES DA UKLONIS cors PAKET (functions FOLDER) (`npm uninstall --save cors`)** (NECE TI TREBATI, KAO STO SAM REKAO)

OD RANIJE SI IMAO I PAKETE:

- web-push (ON OSTAJE)

- uuid-v4 (uuid-v4 PAKET NIGDE NIJE REGITROVAN (NECU GA UKLANJATI NITI UPDATE-OVATI) (ALI NECU GA NI KORISTITI) (TO JE PAKET ZA GENERISANJE TOKENA ZA UPLOAD I DOWNLOAD (NE MESAJ IH SA VAPID KLJUCEVIMA))

POSTOJE TAKODJE MNOGI DRUGI PAKETI ZA **uuid**

JA CU KORISTIT OVAJ:

- npm install **uuid** --save

KADA GA BUDES UVOZIO, KORISTI CETVRTU VERZIJU, OVAKO **require('uuid/v4')**

SADA DA KONACNO POCNEM SA REDEFINISANJEM

functions/index.js FAJL:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
// dakle uveza osam dva pomenuta paketa

// SADA MOGU INICIJALIZOVATI APP I NA CLOUD STRANI, BAS KAO STO SAM OBECAO
admin.initializeApp(functions.config().firebase)

// !!!! OVDE SAM INICIJALIZOVAO KORISCENJE firebase.storage-A
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// MOZES OPET POGRESNO POMISLITI DA JE TO ISTI API, KOJI SE KORISTI NA CLIENT-U, ALI ON TO ZAISTA NIJE

//!!!!!!!!!!!**********************ZAPAMTI DA JE OVO        @google-cloud/storage       API   ~~~~~~~~~~~~~~~~~~

const storage = admin.storage();   // !!!! NAMERNO CU GA KORISTITI DA BI GA ISPIATAO
                                   // !!!! DA VIDIM DA LI JE REC O @google-cloud/storage PAKET-U
                                   // !!!! KOJEG CU TAKODJE UVESTI U OVOM PROJEKT, CISTO DA NAUCIM, KAKO
                                   // !!!! AUTORIZOVATI DA GA SMEM KORISTITI, KADA NA PRIMER NE BI
                                   // !!!!!!! DEFINISAO FIREBASE APP, VEC OBICAN PROJEKAT


// NASTAVLJAM SAD DALJE

// INSTALIRAO SAM RANIJE busboy (UKLONIO SAM formidable, ON MI NAIME NECE TREBATI)
// SAD UVOZIM busboy-A
const Busboy = require('busboy');

// TREBACE MI I PAKETI KOJI SU VEC NATIVNI ZA Node.js (NISAM IH TREBAO INSTALIRATI)
const file_system = require('fs')
const os = require('os');
const path = require('path');

const UUID = require('uuid/v4');        // UVOZIM PAKET ZA GENERISANJE UPLOAD/DOWNLOAD TOKENA

// OVO SU PAKETI KOJI SU NEOPHODNI ZA PUSH, AL ITO SAM OBJASNJAVAO RANIJE
// ****************************************************************************
const webpush = require('web-push');

// TU SU I VAPID KLJUCEVI
const privateVapidKey = "oC8DBLahIEEzbmom6BtrF6z7_rVY";
const publicVapidKey = "BMfwPHbn5_YXc0wZZu5xEIIhs40w8CDWGnf2HSq-v-vS_m122gcDWDRgFzvr";
// NARAVNO KLUCEVI NISU PRAVI, JER NECU DA IH PRIKAZUJEM U md FAJLOVIMA 
// *******************************************************************************
// OVDE CU STATI SA DEFINISANJEM CODE CLOUD FUNKCIJA, JER ZELIM DA DEFINISEM SECURITY RULES ZA STORAGE
```

## DEFINISANJE SECURITY PRAVILA SA STORAGE

EVO KAKVA PRAVILA ZELIM DA DEFINISEM:

```javascript
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    
    match /photos/{photoURL} {
        
        allow read;

        allow write;

    }
  
  }
}
```

DAKLE DOZVOLIO SAM READ I WRITE U SPECIFICIRANOM FOLDERU

**OBRATI PAZNJU DA SAM DEFINISAO PRAVILA ZA**

- photos FOLDER U, JEDINOM DEFAULT BUCKETU

- {photoURL} JE VARIJABLA I PREDSTAVLJA URL FAJLA (TACNIJE IME FAJLA U photos FOLDERU)

*TO IMAJ U VIDU JER CE TI TREBATI, KADA BUDES DEFINISAO UPLOAD FAJLA, JER ZELIS DA SLIKE IPAK STAVLJAS U SPECIFICAN FOLDER A NE DIREKTNO U BUCKET*

*BOLJE JE STAVLJATI U FOLDER BUCKETA, JER AKO BUDEM NA PRIMER U APLIKACIJI DODAVAO FAJLOVE, KOJI NISU SLIKE, ZASTO DA ONI BUDU NA ISTOM NIVO, ZASTO NE BI RAZLICITI TIPOVI FAJLOVA IMALI RAZLICITE FOLDERE U KOJE SU SMESTENI* (JOS AKO BIH IMAO ATHENTICATION, MORAO BI TU UVESTI I PO FOLDER ZA SVAKOG KORISNIKA)

## STO SE TICE TVOJE CLOUD FUNKCIJE, ONA CE SE ZVATI storePostData; OMOGUCI CORS ZA NJU

firebase.json FAJL:

```javascript
{
  "functions": {
    "predeploy": [
      "npm --prefix \"$RESOURCE_DIR\" run lint"
    ]
  },
  "hosting": {
    "public": "public",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [ {
      "source": "/storePostData",   //      OMOGUCENO
      "function": "storePostData"   //
    },
    {       // NE OBRACAJ PAZNJU NA OVE DVE, IGRAO SAM SE NESTO PA SAM IH DODAO
      "source": "/testingPost",
      "function": "testingPost"
    }, 
    {
      "source": "/testGoogleStorage",
      "function": "testGoogleStorage"
    }]
  }
}

```

## STO SE TICE CLIENT SIDE CODE-A, JA SAM DEFINISAO DA SE PODACI SALJU KROZ indexedDB (OBJECT STORE 'sync-posts'); A IZ SERVICE WORKER-A, ON sync PODACI SE PROSLEDJUJU DO CLOUD FUNKCIJE; STO ZNACI DA SE 'POST' REQUEST OBAVLJA U OBIMU POMENUTOG ON sync HANDLER-A, GDE SE UZIMA DATA IZ OBJECT STORE-A, I PRAVI SE S NJIAM 'POST' REQUEST, ALI UZ KORISCENJE FormData INTERFACE-A

HAJDE DA OPET POGLEDAM CODE public/src/js/feed.js

ZELIM DA VIDIM CODE KOJI SE ODNOSI NA STAVLJANJE DATE U indexedDB U 'sync-posts' OBJECT STORE

I **NE ZABORAVI DA U SVAKOM POZIVANJU fetch, NJEGOV URL ARGUMENT ZAMENIS NOVIM, KOJI CE SE SASTOJATI OD**

- URL-A NA KOJEM JE DEPLOYED TVOJA APLIKACIJA

PLUS

- */imeCludFunkcije*  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (TO JE **/storePostData**)

****

**DIGRSIJA:** (!!!!! IAKO SAM DOLE OBJASNIO KAKO DA PRI SLANJU NETWORK 'POST' REQUEST-A, KORISTIM PRAVI **Content-Type** *HEDAER*, NAMENJEN ZA **FormData**, IPAK NEMOJ NISTA DEFINISATI KAO HEADER, KADA BUDES SLAO POST NETWORK REQUEST); A ZASTO? PA IZGLEDA DA TO '**ZBUNJUJE busboy-A**' (DOBIJAO SAM ERROR VEZAN ZA HEADERS-E TOM PRILIKOM (U SUSTINI busboy NIJE MOGAO PRONACI HEADERS-E))

DA SAMO OVDE NAVEDWEM NEKE 'Content-Type'

**DEFAULT `"Content-Type"` HEADER, *'POST'* REQUEST-OVE JESTE**:

- *`"application/x-www-form-urlencoded"`*

JA SAM RANIJE SLAO JSON, PA SAM OVO BIO REDEFINISAO NA

- *`"application/json"`*

OVO BI BILO NAMENJENO ZA **FormData** INSTANCU

- *"multipart/form-data"*

ILI

- *'"raw"'* (OVO DODATNO ISPITAJ, ALI MISLIM DA IMA SIROKU PRIMENU)

**DAKLE ZAPAMTI, REKAO SAM DA, IPAK NE DEFINISES Content-Type HEADER NA CLIENT STRANI, PRI SLANJU HTTP REQUEST-A**

****

DA SADA KONACNO DEFINISEM SVE POMENUTE STVARI, NA CLENT CODE-U

feed.js FAJL:

```javascript
const sendData = function(){    // FALLBACK FUNKCIJA, KOJA SE POZIVA AKO BROWSER NE PODRZAVA BACKGROUND SYNC

    /* const dataObject = {
        id: new Date().toISOString(),
        title: titleInput.value,
        location: locationInput.value,
        image: 'https://firebasestorage.googleapis.com/v0/b/instapwaclone.appspot.com/o/burgers_food.jpeg?alt=media&token=001349ec-8c02-4c16-87df-9db24b252256'
    } */

    // POMENUTI OBJEKAT MI DAKLE VISE NIJE POTREBAN, JER CU UMESTO NJEGA KORISTITI FormData

    const postData = new FormData();   // INSTANTICIZIRAO SAM GA

    // APPENDUJEM MU PRVO SVE PODATKE IZ TEKSTUALNIH INPUT-A (NARAVNO I id)

    postData.append('id', new Date().toISOString());
    postData.append('title', titleInput.value);
    postData.append('location', locationInput.value);

    // A SADA APPEND-UJEM I Blob (SKALDISTI GA picture GLOBALBNA VARIJABLA, KAO STO JE POZNATO);

    // 1. ARGUMENT JE KLJUC, A KLJUC KOJI CE BITI NJEGOV (Blob-OV), U FORM DATA-U, NEKA SE ZOVE file, POSTO TAJ Blob REPREREZENTUJE FILE SLIKE
    // A MOGA OSAM ZADATI BILO KOJI KLJUC

    // 2. ARGUMENT, JESTE Blob INSTANCA naravno

    // 3. ARGUMENT JE IME KOJE ZELIM DA IMA, FAJL, KOJI POMENUTI BLOB REPREZENTUJE 

                // NEKA TO IME BUDE FORMIRANO OD ONIH PODATKAK KOJE SU FORMIARALI id

                // PLUS MIME TYPE FAJLA, KOJEG REPREZENTUJE Blob (OVO SE ODNOSI NA FORMAT SLIKE (jpg, jpeg, png..))

    postData.append(
        'file',
        picture,
        postData.get('id') + "." + picture.type.match(/^(image\/)([a-z]+)/)[2]
    )


    // fetch('https://us-central1-instapwaclone.cloudfunctions.net/storePostData', {   // RANIJE BILO OVO
                                                                                    // PROMENJEN OZBOG cors
    fetch('https://instapwaclone.firebaseapp.com/storePostData', {
        method: "POST",
        /* body: JSON.stringify(dataObject), */   // OVO DAKLE VISE NECU KORISTITI OVDE

        // U BODY-JU, TREBA DA BUDE         FormData        INSTANCA

        body: postData,

        /* headers: {                                // OVO HEADERS-I MI VISE NE TREBAJU
            "Content-Type": "application/json",      // JER NE SALJEM JSON STRING
            "Accept": "application/json"
        } */

        // DEFINISEM HEADERS, ZA FormData

        /* headers: {
            "Content-Type": "multipart/form-data",      // REKA OSAM DA NE KORISTIS
        } */

    })
    .then(resp => {
        console.log("Send Data: ", resp);
        // updateUI(dataObject)                // OVDE VIDIM GRESKU, JER UI UPDATE-UJEM PODACIMA, KOJIH VISE NEMA
                                         // REDEFINISACU OVO KASNIJE
        // PREDPOSTAVLJAM DA SE UI MOZE UPDAT-OVATI SA
        // PODACIMA OPET VRACENIM SA SERVERA, AKO JE REQUEST BIO USPESAN

        // DA NAPOMENEM DA JE AUTOR TUTORIJALA      POZVAO      updateUI    BEZ ARGUMENATA
        // (NIJE NI BITNO)
    })

    // ALI UPAMTI DA JE OVAJ FALLBACK DEFINISAN OVAKO, A CLOUD FUNCTION NIJE REDEFINISANA DA RECEIVE-UJE FormData

    // BAR NE JOS, ALI USKORO CU I TO DEFINISATI


};


const titleInput = document.querySelector('input#title');
const locationInput = document.querySelector('input#location');
const form = document.querySelector('div#create-post form');

form.addEventListener('submit', ev => {

    ev.preventDefault();


    if(titleInput.value.trim() === "" || locationInput.value.trim() === ""){
        alert("Please enter valid data!");

        return;
    }

    closeCreatingPostModal();   // RANIJE DEFINISANA FUNKCIJA U ISTOM FAJLU
                                // KADA SE SUBMITT-UJE FORMUALR, ODMAH SE SKALNJA MODAL NA KOJEM JE FORMULAR


    if('serviceWorker' in window.navigator && 'SyncManager' in window){    // AKO OVO NIJE ISPUNJENO, DOLE SE POZIVA
                                                                            // POMENUTI FALLBACK
        // OVDE CU POSLATI I SLIKU, ZAJEDNO SA OSTALIM PODACIMA

        navigator.serviceWorker.ready
        .then(swr => {

            // PODACI PUNE sync-posts OBJECT STORE, I TEK CE SE VADITI IZ SERVICE WORKER-A I TEK CE SE ONDA
            // NAKON INSTANTICIZIRANJA FormData INSTANCE, DEFINISATI KACENJE (TO JEST TO SAM VEC TAMO I DEFINISAO)
            // append METODOM, PODATKAK NA FormData INSTANCU, KOJA CE BITI POSLATA DO CLOUD FUNKCIJE (ENDPOINT-A)

            let post = {
                id: new Date().toISOString(),
                title: titleInput.value,
                location: locationInput.value,

                slika: picture    // DAKLE I blob INSATANCA SNAPSHOTA // (OVA INSTANCA JE RANIJE PROCITNAN SA CANVASA
                                  // KOJI JE CAPTURE-OVAO STREAM KAMERE)
                                  // BITI POSLATA U indexedDB
            }

                                // TO SAM URADIO ZBOG ONOG STO SAM VEC MNOGO PUTA OBJASNIO
                                // ALI RECI CU OPET
                                // ZELIM DA ISTATICIZIRAM       FormData    SA OVIM PODACIMA
                                // ALI U SERVICE WORKERU (ON sync HANDLER)

            writeData('sync-posts', post)

            .then(() => {

                // OVDE CU NAMERNO STAMPATI         picture
                // JER ZEIM DA SE POIGRAVAM, ODNOSNO DA ISPITUJEM POMENUTI Blob
                // U KONZOLI (MOGU DA GA NAINIM VREDNOSU temp VARIJABLE I TAK OSE POIGRAVAM)

                console.log("OVO JE BLOB SLIKE; IGRAJ SE S NJIM BLAH:", picture);

                return swr.sync.register('sync-new-post');
            })

            .then((syncRegistration) => {

                let snackbarContainer = document.querySelector('#confirmation-toast');
                let data = {message: "Your post was saved for synching!"};

                snackbarContainer.MaterialSnackbar.showSnackbar(data)

            })
            .catch(err => {
                console.log(
                    err, "STORING POST IN IndexedDb WAS UNSUCCESSFUL!, OR REGISTRATION OF SYNC TASK"
                );
            })

        })

    }else{

        sendData();         // KAO STO SAM REKAO POZIVA SE FALLBACK
    }

})
```

PRIKAZUJEM SAV BACKGROUND SYNC CODE SERVICE WORKERA, JER SE TAMO PODACI VADE IZ indexedDB-JA I PRAVI SE NETWORK REQUEST KA END POINT-U ('POST' REQUEST NARAVNO)

**NEMOJ I OVDE DA ZABORAVIS DA PROMENIS URL NETWORK REQUEST-A**

public/sw.js FAJL:

ps. KAD MENJAS CLIENT SIDE CODE NIKAD NEMOJ DA ZABORAVIS DA UPDATE-UJES VERZIJE CACHE-A

```javascript
self.addEventListener('sync', function(ev){

    console.log('--+---+-- SyncEvent --+---+--+---+-   ', ev);

    if(ev.tag === 'sync-new-post'){  // NARAVNO, AKO JE TRIGGER-OVAN sync EVENT, RELATED SA POMENUTOM REGISTRACIJOM
                                     // MOGU OVAJ STRING NAZVATI I REGISTRATION TAG-OM, TU JE DOSTUPAN, DA BIH ZNAO
                                     // STA DA VADIM IZ indexedDB-JA (SVE OBJASNJENO RANIJE)

        ev.waitUntil(                       // SERVICE WORKER DAKLE CEKA DOK SE SLEDECE NE IZVRSI (SVE OBJASNJENO VEC)

            readAllData('sync-posts')      // CITAM ONE PODATKE, KOJI SU POTREBNI ZA SLANJE SERVER-U (OBJASNJENO RANIJE)

            .then(dataArray => {            // DAKLE POSTOJI MOGUCNOST DA JE VISE OBJEKATA UBACENO U OBJECT STORE       'sync-posts'
                                            // A JA OVDE SALJEM POST REQUEST, ZA SVAKI POJEDINACNI OBJEKAT IZ OBJECT STORE-A
                                            // JER SAM ACCESS-OVAO SVIM OBJEKTIMA IZ OBJECT STORE-A

                for(let data of dataArray){


                    // REKAO SAM RANIJE DA CU OVDE INSTATICIZIRATI I FormData INSTANCU, ALI JE NECU SLATI SERVERU

                    const postData = new FormData();   // INSTANTICIZIRAO SAM GA (USTVARI BICE INSTATICIZIRAN U SVAKOJ ITERACIJI)
                                                       // ZA SVAKI EXTRACTED OBJECT IZ OBJECT STORE-A

                    // SADA IZ ODREDJENOG OBJEKTA (ODNOSNO OBJEKTA TRENUTNE ITERACIJE), KOJE JE OBJECT, OBJECT STORE-A  sync-posts
                    // EXTAHUJEM PODATKE

                    // FormData-I , PRVO APPEND-UJEM SVE PODATKE IZ TEKSTUALNIH INPUT-A (NARAVNO I id)

                    postData.append('id', data.id);
                    postData.append('title', data.title);
                    postData.append('location', data.location);

                    // A SADA APPEND-UJEM I Blob

                    // 1. ARGUMENT JE KLJUC, A KLJUC KOJI CE BITI NJEGOV (Blob-OV), U FORM DATA-U, NEKA SE ZOVE file, POSTO TAJ Blob REPREREZENTUJE FILE SLIKE
                    // A MOGA OSAM ZADATI BILO KOJI KLJUC (MEDJUTIM, POSTO SAM 'file' ZDAO I U FALLBACK-U, ONDA TO RADIM I OVDE (NE SME BITI RAZLIKE))

                    // 2. ARGUMENT, JESTE Blob INSTANCA naravno

                    // 3. ARGUMENT JE IME KOJE ZELIM DA IMA, FAJL, KOJI POMENUTI BLOB REPREZENTUJE

                                // NEKA TO IME BUDE FORMIRANO OD ONIH PODATKAK KOJE SU FORMIARALI id

                                // PLUS MIME TYPE FAJLA, KOJEG REPREZENTUJE Blob (OVO SE ODNOSI NA FORMAT SLIKE (jpg, jpeg, png..))

                    postData.append(
                        'file',

                        data.slika,          // ~~~~~~  U SVAKOM OBJEKTU, IZ, POMENUTOG OBJECT STORE-A,
                                             //         Blob     JE STORED KAO U PROPERTIJU slika ~~~~~~
                                             // TO SMA OBJASNIO (URADIO) GORE U on submit HANDLERU (feed.js FAJL)

                        postData.get('id') + "." + data.slika.type.match(/^(image\/)([a-z]+)/)[2]
                    )

                    // ~~~~~~~~~~~~~~~~~~~ DAKLE NECU GORNJI OBJEKAT (postData) SLATI NA SERVER,
                    // ~~~~~~~~~~~~~~~~~~~ ALI CU GA STAMPATI DA VIDIM OD CEGA SE SASTOJI
                    // ~~~~~~~~~~~~~~~~~~~ ODNOSNO PRIMENJIVACU METODE FormData-INOG PROTOTIPA NA NJEMU
                    // ~~~~~~~~~~~~~~~~~~~ GET-OVACU IZ NJEGA Blob   MOJE CAPTURED SLIKE (SNAPSHOT-A), UZ POMOC KLJUCA     file
                    // ~~~~~~~~~~~~~~~~~~~ PA CU NAD Blob INSTANCOM PRIMENJIVATI NEKE METODE

                                            // SVE CE TO BITI MOGUCE U CHROME KONZOLI, ZATO STO U CHROME KONZOLI
                                            // JA MOGU DESNIM CLICK-OM IZABRATI DA SE ZELENI ODSTAMPANI OBJEKAT
                                            // STORE-UJE U TRENUTNOJ VARIJABLI

                    //-----------------------------------------------------------
                            // DAKLE STAMPAM        FormData        INSTANCU
                    // console.log(postData);

                    //

                    // STAMPACU GETTED      Blob        FROM FORM DATA
                    // console.log("-*-*-*-*-*-*-*", postData.get('file'), "-*-*-*-*-*-*-*-*-");

                    //-----------------------------------------------------------


                    // fetch('https://us-central1-instapwaclone.cloudfunctions.net/storePostData', {   // RANIJE BILO OVO
                                                                                    // PROMENJEN OZBOG cors
                    fetch('https://instapwaclone.firebaseapp.com/storePostData', {
                        method: "POST",
                        /* body: JSON.stringify({             // !!!! DAKLE OVO JE ONO STO CU MENJATI (ALI NE SADA, VEC TEK KAD DEFINISEM SERVER SIDE CODE)
                            id: data.id,                   // !!!! POSTO ZELIM DA PODATKE SALJEM KROZ FormData INSTANCA (DAKLE, ZELIM DA ONA BUDE U BODY-JU)
                            title: data.title,             // !!!! JA NE ZELIM STRINGIFIED OBJEKAT, KOJI JE SADA OVDE
                            location: data.location,       // !!!! ZAELI FormData INSTANCU, SA ONIM BLOB-OM, KAO SASTAVNIM DELOM

                                                           // ~~~~~~~  ALI JA CU OVO TEK MENJATI ONDA KADA BUDEM SREDIO SERVER SIDE CODE

                            image: 'https://firebasestorage.googleapis.com/v0/b/instapwaclone.appspot.com/o/burgers_food.jpeg?alt=media&token=001349ec-8c02-4c16-87df-9db24b252256'

                            // OVO JE BIO DUMMY IMAGE I ZATO JE OVO HARD CODED URL, KAKO GA NAZIVAJU
                        }),
                        headers: {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        } */

                        body: postData

                        // HEADERSI

                        /*  headers: {
                            "Content-Type": "multipart/form-data",     // REKAO SAM DA NE KORISTIS
                        } */



                    })
                    .then(resp => {
                        console.log("Send Data: ", resp);

                        if(resp.ok){

                            deleteItemFromData('sync-posts', data.id)     // KADA SU PODACI USPESNO POSLATI DO CLOUD FUNKCIJE,
                                                                          // ONI VISE NISU POTREBNI U indexedDB-JU  (OBJASNIO VEC RANIJE)
                        }


                    })
                    .catch(function(err){
                        console.log('Error, while sending data', err)
                    })

                }
            })
        );
    }
})
```

## :arrow_upper_right: MALO CU DA GOVORIM O MODULIMA os, fs I path, KOJE SAM UVEZAO U MOJ SERVER SIDE CODE

TI MODULI SU MODULI KOJI DOLAZE ZAJEDNO SA Node.js-OM

RECI CU NESTO O NJIMA I ZASTA CU IH UPOTREBLJAVATI U MOM PROJEKTU

:one: ['os'](https://nodejs.org/api/os.html#os_os) PAKET MOZE PRUZITI INFORMACIJE O OPERATIVNOM SISTEMU KOJI JE U UPOTREBI (MISLI SE NA OPERATIVNI SISTEM SERVERA, PREDPOSTAVLJAM)

[ako ne verujes pogledaj ovaj primer](https://www.w3schools.com/nodejs/shownodejs_cmd.asp?filename=demo_ref_os)

MENI IZ OVOG PAKETA ZANIMA MOGUCNOST DA PRISTUPIM INFORMACIJAM TEMPORARY STORAGE-A OPERATIVNOG SISTEMA

**UPRAVO KADA blob STIGNE DO SERVER-A, PREDPOSTAVLJAM DA JE NJEGOV RELATED FAJL, SMESTEN U TEMP DIREKTORIJUM**

E PA MOGU KORISTITI os PAKET, TACNIJE [os.tmpdir()](https://nodejs.org/api/os.html#os_os_tmpdir), KAKO BI PRISTUPIO TEMPORARY DIREKTORIJUMU

ZAPAMTI DA SE TAMO NALAZI TVOJ FAJL

**AKO ZNAS IME FAJLA I AKO SI PRISTUPIO, POMENUTOM DIREKTORIJUMU, MOZES INICIRATI UPLOAD FAJAL U WritableStream**

MISLIM DA CE MI OVO BITI JASNIJE, KADA VIDIM STA CE TO USTVARI URADITI, PRI KORISCENJU SA busboy

JER BUSBOY CE EXTRAHOVATI NEKE PODATKE O Blobu, KAO STO SU fieldname, file, filename, encoding, mimetype

**ALI MEDJU TIM PODACIMA NECE BITI INFO O TEMP DIREKTORIJUMU WINDOWS-A, U KOJEM JE MOJ FILE (IMAGE FILE)**

I UPRAVO ZBOG POMENUTE METODE OS JA CU ZNATI PATH TEMP DIREKTORIJUMA

:two: ['path'](https://nodejs.org/api/path.html#path_path) 

>>> The path module provides utilities for working with file and directory paths. It can be accessed using:

OVAJ MODUL IMA NOGO METODA A MENE ZANIMA TRENUTNO SAMO [join()](https://nodejs.org/api/path.html#path_path_join_paths) METODA

```javascript
path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');
// Returns: '/foo/bar/baz/asdf'
```

TI ZAKLJUCI CEMU SLUZI, PREDHODNA METODA

:three: 'fs' ODNOSNO [File System](https://nodejs.org/api/fs.html)

>>> The fs module provides an API for interacting with the file system in a manner closely modeled around standard POSIX functions (NE ZNAM STA JS [POSIX](https://www.php.net/manual/en/ref.posix.php))

PREDPOSTAVLJAM POSIX ZNACI: ' Process Control Functions'

OD OVOG PAKETA CU KORISTITI [createWriteStream()](https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options) FUNKCIJU

**IZ ONOGA STO SAM SAZNAO, SHVATIO SAM DA OVA FUNKCIJA PRAVI *WritableStream* INSTASNCU** (ONO STO JA ZNAM JESTE DA JE BODY, NEKOG REQUEST, UVEK ReadableStream)

NAIME U MOM SLUCAJU JA CU FUNKCIJI DODATI *PATH* **(SASTAVLJEN OD FOLDERA U TEMP FOLDERU SERVERA (GDE SE FAJL NALAZI, NAKON STIZANJA DO SERVERA), I IMENA FAJLA)**

I S TIM CU KREIRATI WritableStream INSTANCU

[WritableStream](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream) JE ABSTRAKCIJA ZA UPISIVANJE STREAMING PODATAKA U DESTINACIJU

PREDPOSTAVLJAM DA JE OVO FINAL COG U PROCESU UPLOADING-A: WRITING U WRITABLE STREAM, KOJI KASNIJE MOGU KORISTITI KAKO BI UPLOAD-OVAO FAJL NA ZELENO MESTO (FIREBASE STORAGE U MOM SLUCAJU)

KASNIJE SE NA SAMOM FAJLU, PRIMENJUJE pipe METODA;

>>>> Calling the [stream.pipe()](https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options) method to send the data to a Writable

ONA SE USTVARI PRIMENJUJE NA [ReadableStream](https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options)-U, KOJI CE MI BITI DOSTUPAN PRI KORISCENJU BUSBOY-A

## DA SE POZABAVIM @google-cloud/storage PAKETOM; OBRATI PAZNJU JER GA MOZES POGRESNO ISKORISTITI

TO SAM REKAO I RANIJE, ALI STA MISLIM POD TIM 'POGRESNO'?

NA FIREBASE-OVOJ STRANICI JE U DOKUMENTACIJI OBJASNJENA UPOTREBA STARIJE VERZIJE OVOG PAKETA

functions/index.js FAJL:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');

admin.initializeApp(functions.config().firebase)

const storage = admin.storage(); // REAKO SAM DA JE OVO @google-cloud/storage

// Iko je on tu pokazacu kak oda ga configuriram, da bih ga mogao koristiti, kada NE BUDEM KORISTIO FIREBASE U NEKOM PROJEKTU U BUDUCNOSTI
//A BUDEM POZELEO DA KORISTIM ,POMENUTI PAKET


const Busboy = require('busboy');

const file_system = require('fs')
const os = require('os');
const path = require('path');

const UUID = require('uuid/v4');

// OVO SU PAKETI KOJI SU NEOPHODNI ZA PUSH, AL ITO SAM OBJASNJAVAO RANIJE
// ****************************************************************************
const webpush = require('web-push');

// TU SU I VAPID KLJUCEVI
const privateVapidKey = "oC8DBLahIEEzbmom6BtrF6z7_rVY";
const publicVapidKey = "BMfwPHbn5_YXc0wZZu5xEIIhs40w8CDWGnf2HSq-v-vS_m122gcDWDRgFzvr";
// NARAVNO KLUCEVI NISU PRAVI, JER NECU DA IH PRIKAZUJEM U md FAJLOVIMA 
// *******************************************************************************

                //****************** DAKLE KADA U NKEOM PROJEKTU ZELIM DA KORISTIM @google-cloud/storage*******************radim sledece:

// DA PRVO KREIRAM KONFIGURACIJSKI OBJEKAT, KOJI CU KORISTITI DA KONFIGURIRAM GOOGLE CLOUD STORAGE
// KAKO BI GA MOGAO KORISTITI U MOM PROJEKTU

// NAIME, U PITANJU JE CREDENTIAL, O KOJEM SAM GOVORIO PRI POCETKU OVOG md FAJLA

const gcsConfig = {keyFilename: '/instapwaclone-f5157fff88e9.json', projectId: 'instapwaclone'}

// SADA DA UVEZEM I KONFIGURIRAM GOOGLE-CLOUD STORAGE (ODNOSNO POZIVAM UVEZENU FUNKCIJU SA KONFIGURACIJSKIM OBJEKTOM)

//!!!!!!!!  // OBRATI PAZNJU DA JE OVO BILA STARIJA SINTAKSA, KOJA SE VISE NE KORISTI
// const gcs = require('@google-cloud/storage')(gcsConfig);
//!!!!!!!!  I U TOME SE OGLEDALA GRESKA, FUNKCIJA ODMAH FAIL-UJE, JER NIJE VRACENA FUNKCIJA
// VEC KONSTRUKTOR

// I TO JE BILO ONO NA STA SAM U NASLOVU REKAO DA TRBA OBRATITI PAZNJU

// DAKLE SADA SE KORISTI KONSTRUKTOR

const {Storage} = require('@google-cloud/storage');

const gcs = new Storage(gcsConfig);

```

I OPET NAPOMINJEM:

****

STO SE TICE GOOGLE-CLOUD STORAGE DOKUMENTACIJE, **MISLIM DA SAM OTKRIO NAJBOLJU DOKUMENTACIJU VEZANU ZA Node.js** I AKO ZELIM DA SE NA NAJBOLJI NACIN UPOZNAM SA PAKETOM NAJBOLJE JE CITATI OVU [ZVANICNU DOKUMENTACIJU ZA GOOGLE CLOUD STORAGE Node.js](https://googleapis.dev/nodejs/storage/latest/index.html)

****

## :tea::tea::tea::tea: KAKO BIH VIDEO KOLIKO JE OVAJ @google-cloud/storage PAKET SUVISAN, KADA KORISTIM FIREBASE, ODRADICU NEKOLIKO PRIMERA, KOJI CE SE TICATI UPOTREBE FIREBASE-OVOG storage PAKETA, NA CLIENT-U :tea::tea::tea::tea:

UPOTREBICU storage PAKET NA CLIENT STRANI, KAK OBI VIDEO KAKO JE JEDNOSTAVAN UPLOADING FAJL-OVA

### KREIRAM PRIMER U KOJEM NE SALJEM NISTA DO CLOUD FUNKCIJE (DAKLE NECU KREIRATI CLOUD FUNKCIJU), VEC SAMO SALJEM SLIKE U DEFAULT BUCKET FIREBASE CLOUD STORAGE-A (KORISCENJEM storage LIBRARY-JA NA CLIENT STRANI) (SAMO STO CE SVAKA OD TIH SLKA BITI U RAZLICITOM FORMATU)

SVE CU ODRADITI IZ HTML-A, DA SE SVE LEPO VIDI ODJEDNOM

****

DIGRESIJA (PA BAS I NIJE): **VEZANO ZA ODLICNE RESURSE, A NEKE STVARI ODAVDE CU JA KORITITI U OVOM PRIMERU**

OVDE CU KORISTITI NESTO STO SE ZOVE [FileReader INSTANCA](https://developer.mozilla.org/en-US/docs/Web/API/FileReader) (NENO KORISCENJE JE OBJASNJENO U GORNJEM javascript.info TUTORIJALU) (KORISTICU NJENE METODE)

A TAKODDJE TU SI I RESURSI VEZANI ZA BINARNI DATA, KOJI JA KORISTIM U OVOM PRIMERU

[javascript.info](https://javascript.info/binary) (**OVAJ SJAJNI WEBSATJT IMA ODLICNA OBJASNJENJA ZA **Binary data, files**) (TU JE I OBJASNJENJE KAKO DA TRANSFORMISEM ISKORISTIM Blob INSTANCU, [KAKO BI ENCODE-OVAO FAJL U ArrayBuffer ILI U Base64](https://javascript.info/file#filereader))

[javascript.info](https://javascript.info/network) **IMA ODLICNE RESURSE ZA OBJASNJAVANJE NETWORK REQUEST-OVA** (OVO SVE MORAS, I MORAS, I MORAS , IMORAS PRECI **!!!!!!!!!!!!!!!!**)

****

public/index.html FAJL

```HTML
    <!-- OVO SVE RADIM U MOM PROJEKTU SAMO ZBOG TERTIRANJA POMENUTOG -->
    <!-- !!!!! KAD SE UVERIM, UKLONICU SAV OVAJ CODE IZ MOG APP-A !!!!! -->

    <!-- DAKLE PRVO DEFINISEM SAMO JEDAN CONTAINER, SA JEDINIM FILE PICKEROM
    I SA JEDNIM DUGMETOM -->
    <div class="blah_file_send">
        <input type="file" name="picAfile" multiple>   <!-- MOGU DA BIRAM VISE FAJLOVA -->
        <button>Posalji slike</button>
    </div>

    <!-- SAM ODA POZICIONIRAM ELEMENTE DA SE VIDE  -->
    <style>
        div.blah_file_send {
            position: fixed;
            top: 200px;
            left: 200px;
            z-index: 8000;
        }
    </style>

    <!-- ***************************************************** -->
    <!-- ***************************************************** -->
    <!-- ***************************************************** -->
    <!-- ***************************************************** -->


    <!-- DAKLE OVO JE UVEZENI firebas-app PAKET (ODNOSNO SOFTWARE DEVELOPMENT KIT) -->
    <!-- UVEZAO SAM GA RANIJE, SAMO POKAZUJEM DA MORAM UCITATI TAJ MODUL, KAKO BI KORISTIO FIREBASE FEATURE-E -->
        <!-- The core Firebase JS SDK is always required and must be listed first -->
    <script src="https://www.gstatic.com/firebasejs/6.3.5/firebase-app.js"></script>

    <!-- TODO: Add SDKs for Firebase products that you want to use
        https://firebase.google.com/docs/web/setup#config-web-app -->


    <!--  I OVO SAM POKAZAO, INICIJALIZACIJU MOG PROJEKTA -->
    <script>
        // Your web app's Firebase configuration
        var firebaseConfig = {
            apiKey: "AIzaSyB76KSNqmgZIJrzSd9QQ8kyL1DX8Qis-ls",
            authDomain: "instapwaclone.firebaseapp.com",
            databaseURL: "https://instapwaclone.firebaseio.com",
            projectId: "instapwaclone",
            storageBucket: "instapwaclone.appspot.com",
            messagingSenderId: "693799903166",
            appId: "1:693799903166:web:733c23cb06a6bdba"
        };
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
    </script>

    <!-- ***************************************************** -->
    <!-- ***************************************************** -->
    <!-- ***************************************************** -->
    <!-- ***************************************************** -->
        <!-- uvezao sam storage PAKET -->
    <script src="https://www.gstatic.com/firebasejs/6.4.0/firebase-storage.js"></script>


    <script>

        // pristupam svim elementima

        const senderSlikaKont = document.querySelector('div.blah_file_send');
        const pikerSlike = senderSlikaKont.querySelector('input[name="picAfile"]');
        const dugmeZaSlanje = senderSlikaKont.querySelector('button')

        // OVO CE MI OMOGUCITI DA KORISTIM storage LIBRARY
        const firebaseStorage = firebase.storage();             // OVO PREDSTAVLJA JEDINI DEFAULT BUCKET
                                                                // FIREBASE STORAGE-A

        console.log({pikerSlike, naslovInput, dugmeZaSlanje, firebaseStorage});

        console.log(pikerSlike.files[0]);  // OVO JE JEDAN OD BLOB-OVA KOJI JE PROCITAN OD INPUTA
        // OVO JE SAMO PODSETNIK DA NE ZABORAVIS DA HTMLInputElement  KOJI JE       type="file"
        // NASLEDJUJE IZ File KLASE I NJENE INSTANCE IMAJU GETTER file KOJI RETURN-UJE FileList NIZ
        // TO JE NIZ SA SVIM Blob INSTANCAMA, KOJE REPREZENTUJU SVE PICKED FAJLOVE

        // AKO JE KORISNIK IZABRAO VISE FAJLOVA, IZABRACU IH SVE

        // SLACU REQUEST ON click

        dugmeZaSlanje.addEventListener('click', ev => {

            // ODMAH DA KAZEM DA CE MI TREBATI FileReader INSTANCA, JER CU PREKO NJE IZVRSITI
            // SVAKU TRANSFORMACIJU

            // POSTO JE DECODING ASINHRON, EVENT BASED
            // ZELI MDA SLUSAM KADA SE ENCODING ZAVRSI ZA SVAKI OD 3 FAJLA KOJE ENCODE-UJEM

            const fileReader = new FileReader();
            const fileReaderSecond = new FileReader();
            const fileReaderThird = new FileReader();

            const createdAt = new Date().toISOString();    // ZELI MDA STAVIM TIMESTAMP U IME SVAKOG UPLOADED FAJAL

            // I ONO STA JE DOBRO KORISTII JESTE DECODE-OVATI OVAJ STRING, UZ POMOC         decodeURI    METODE
            // AKO SE SECAS MOZE PROBLEMA NASTATI AKO IAM NEKIH KARAKTERA U GORNJEM STRINGU, KAO STO SU
            // % ZAJEDN OSA BROJEVIMA (TO PREDSTAVLJA URL ENCODING) (NE ZELIM URL ENCODING U IMENU FAJLOVA)
            // TO MOZE *UPROPASTITI*, KONACNI URL

            // !!!!!!!!!!!!!!!!

            // SVI PICKED FAJLOVI
            const fileList = pikerSlike.files;

            // JA USTVARI UVEK ZELIM DA SE IZBERU CETIRI FAJLA
            // AKO KORISNIK IZABERE VISE ILI MANJE, NECU NIKAKV UPLOAD

            if(fileList.length !== 4) return;

            const blob = fileList[0]; // NJEGA NE TRANSFORMISEM

            firebaseStorage.ref().child('photos').child(decodeURI(createdAt)).put(blob)  // UPLOAD-UJEM FAJL PREKO
                                                                                         // NJEGOVE Blob INSTANCE

            // EVO OVDE DEFINISEM HANDLERE, KOJI CE SE IZVRSITI NAKON TRANSFORMACIJE JEDNOG TIPA DATE U DRUGI
            // AN PRIMER, KADA INICIRAM TRANSFORMACIJU Blob-A U Base64 DATA URI, JA MOGU U TAKVOM MHANDLERU PRISTUPITI
            // Base64 VREDNSOTI

            // EVENT KOJI SE TRIGERUJE JE load

            fileReader.onload = e => {
                const buffer = e.target.result;

                console.log({buffer})

                // UPLOAD-UJEM PUTE ArrayBuffer-a
                firebaseStorage.ref(`photos/${decodeURI(createdAt + fileList[1].name)}`).put(e.target.result)
                // POSTO JE RETURNED VALUE put-A, USTVARI Promise INSTANCA, MOGU PRISTUPITI
                // DOWNLOAD URL-U, MOGU PRISTUPITI CHAININGOM then-A
                .then(response => response.ref.getDownloadURL())                // OVA METODA SE DAKLE
                                                                                // PRIMENJUJE NAD Reference
                                                                                // INSTANCOM
                // TREB DA KAZEM DA JE ONO STO SE PROSLEDJUJE PARAMETR
                // (JA SAM GA NAZVAO response), USTVARI UploadTaskSnapshot INSTANCA
                
                .then(url => console.log({url}))

            }
            
            fileReaderSecond.onload = e => {
                console.log(e.target.result)

                const cuttedBase = e.target.result.split(',')[1];

                console.log({cuttedBase});

            // STO SE TICE UPLODINGA FAJLA, U VIDU Base64 DATA URI-A, KORISTIM DRUGU METODU (putString()),
            // REFERENCE BUCKET-A
            // ALI MORAM ISECI TAJ STRING UZIMAJUCI ONO STO IDE NAKON   data:;base64,    PODSTRINGA
            // TU POMAZE split METODA (NAIME SAMO CE TAKVA STRING VREDNOST BITI VALIDAN ARGUMENT)
            // A MOGU KORISTITI I    replace    METODU , OVAKO
            //                                                      e.target.result.replace('data:;base64,', "")
                
                firebaseStorage.ref(`photos/${decodeURI(createdAt + fileList[2].name)}`).putString(cuttedBase)
            } 
            
            fileReaderThird.onload = e => {
                console.log(e.target.result)
                // I UPLOAD-UJEM FAJL KORISCENJEM Uint8Array INSTANCE
                const uint8 =  new Uint8Array(e.target.result);
                console.log({uint8})

                firebaseStorage.ref(`photos/${encodeURI(createdAt) + fileList[1].name}`).put(uint8);
            }

            // SADA JA USTVARI INICIRAM TRANSFORMCIJE
            // DAKLE SAD CU PRIMENITI METODE FileReader -A; I SVAKOJ Blob INSTANCA JESTE ARGUMENT
            
            // PRVI TRANSFORMACIJA JE U ArrayBuffer
            fileReader.readAsArrayBuffer(fileList[1]);

            // DRUGA TRANSFORMACIJA JE U Base64Data URI
            fileReaderSecond.readAsDataURL(fileList[2])

            // TRECU CU TRANSFORMISATI U ArrayBuffer
            fileReaderThird.readAsArrayBuffer(fileList[3]);
            //SAMO STO CE TRECA UCESTVOVATI PRI INSTATICIZIRANJU Uint8Array INSTANCE (PRIKAZO GORE U onload HANDLERU ) 


            // STAVIO SAM SVAKI FAJL U photos FOLDER JER SAM SAMO ZA NJEGA DOZVOLIO write (SECAS SE PRAVILA)
        

        })


    </script>


    <!-- I ZAISTA KADA IZABEREM FAJL I KLIKNEM NA DUGME, I AKO ODEM U FIREBASE KONZOLU -->
    <!-- U Storage TABU, BICE PRIKAZAN I photos FOLDER, KADA UDJEM U NJEGA TAM OCE BITI UPLOADED FILE -->

```

OVO, SVE GORE SAM MOGAO TESTIRATI I SA LOCALHOST-A (**A DA SAM SA LOCALHOST-A SLAO HTTP REQUEST KA ENDPOINTU, IMAO BIH ERROR U POGLEDU Access-Controll-Allow-Origin**)

UGLAVNOM, SADA, SVI FAJLOVI SU USPESNO BILI UPLOADED

**KADA POSMATRAS URL-OVE UPLOADED FAJLOVA, MOZES VIDETI DA JE U URL-U IMPLEMENTED uuid** (KORISCENJEM @google-cloud/ storage , TI MORAS OBEZBEDITI uuid (BAR JE TAKO BILO)) (A OVDE SVE FIREBASE-OV STORGE API, RADI UNDER THE HOOD)

### ZELIM SADA DA ODRADIM JEDAN PRIMER, A ONO STA ZELIM DA URADIM JESTE DA DO ENDPOINT-A (CLUD FUNKCIJE), POSALJEM Uint8Array INSTANCU; USTVARI NEKA TO BUDE STRINGIFIED VREDNOST, PA DA ISKORISTIM FIREBASE firestore LIBRARY, ILI FIRESTORE-OV real time database (DAKLE JA SADA ZELIM DA NE KORISTIM STORAGE UOPSTE, PRILIKOM 'UPLOADING'-A (POD NAVODNICIMA VELIKIM, JER NISTA NE UPLOAD-UJEM VEC ONO STA CU RADITI JESTE STORING 'BINARNOG FORMATA' (ALI TO CE USTVARI BITI SAMO STRING, Uint8Array INSTANCE), NEKOG FAJLA U DATBASE-U))

DAKLE SACUVO BIH ODREDJENI TIP VREDNSOTI KOJI CE NA IDIREKTANA NACIN PREDSTAVLJATI 'FAJL' (U PITANJU JE NIZ OD KOJEG SE 'BIANRNIM PUTEM', MOZE, OPET SAGRADITI Blob INSTANCA (OPET PREKO NOVE INSTANCE Uint8Array-A), KADA NIZ FETCHUJEM NAZAD NA CLIENT-U))

OVO ZAHTEVA DA DIVE-UJEM U UCENJE BINARY VREDNSOTI, VEZANIH ZA FAJLOVE (GOVORIM O VEC POMINAJNIMA ArrayBuffer-U I Uint8Array-U), ALI ZA TO NEMAM VREMENA, TAKO DA CU SE OGRANICITI SAMO NA UPOTREBU POMENUTIH TIPOVA VREDNSOTI I DAVACU DODATNA OBJASNJENJA O TOME KAKO JA SHVATAM SVE POMENUTO; UZ TO PRIKAZACU NEKOLIKO PRIMER-A, KOJI SE BAVE POMENUTIM VREDNOSTIMA

U SUSTINI RESURSE SAM VEC OSTAVIO (MISLIM AN LINKOVE, KOJI SU VEZAN IZA javascript.info STRANICU), U NEKIM RANIJIM PODNASLOVIMA I NASLOVIMA

****

PS. OSTAVICU PRVO NEKE INFORMACIJE, PRE NEGO STO DAM DODATNA OBJASNJENJA VEZANA ZA POMENUTE TIPOVE VREDNOSTI

***ODLUCIO SAM DA 'SALJEM' **Uint8Array** INSTANCU DO ENDPOINT-A (USTVARI NECU SLATI INSTANCU, VEC JEDAN JSON STRING KOJI JE USTVARI STRINGOVANI NIZ) (MORA DA SE DEFINISE, INSTANCINA TRANSFORMACIJA U STRING ***

DAKLE PARSING TO STRING MI TREBA ZATO STO ZELIM DA DATA SALJEM KAO JSON (VIDECES I KAKO KAD BUDEM DEFINISAO JEDAN PROBNI PRIMER)

****

- KADA SE DOBIJE NAZAD NIZ IZ STORAGE-A, OD NJEGA SE MOZE NAPRAVITI NOVA Uint8Array INSTANCA, OD KOJE SE MOZE NAPRAVITI NOVI Blob; PA ONDA taj Blob KORISTIM ZA URL.CreateObjectURL METODU, KAKO BI NAPRAVIO URL, KOJI ONDA MOGU UCITATI U NEKU SLIKU

**PRE TOGA NERKE INFORMACIJE**

- ZNAM OD RANIJE DA *Base64 DATA URI MOZE UCINITI DA MOJI JAVASCRIPT FAJLOVI IMAJU VELIKI SIZE*, JER SE TU IPAK RADI O KORISCENJU FAJLA U VIDU STRING-A U MOM CODE-U (MALI FAJLOVI DOLAZE U OBZIR, ALI VELIKI BI NAPRAVIL PERFORMANCE ISSUES)

- SAZNAO SAM DA ArrayBuffer MOZE BITI KORISCEN NA SERVER STRANI (IMA POSEBAN API, ALI JA TO NECU KORISTITI SADA)

- [ArrayBuffer](https://javascript.info/arraybuffer-binary-arrays) IMA GOTOVO ISTI SYZE U BYTE-OVIMA (MALO JE MANJI ALI PRIBLIZNO ISTI), NEGO BASE64

ArrayBuffer NEMA NISTA SLICNO SA JAVASCRIPT Array-EM; I KOLIKO SAM RAZUMEO ON PREDSTAVLJA MEMORY AREA, DAKLE ON JE SIROVI BINARY DATA KAO I Base64

- A [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) JE NESTO DRUGO; **ON USTVARI PREDSTAVLJA *view object*,**

>>>> [A view object does not store anything on it’s own. It’s the “eyeglasses” that give an interpretation of the bytes stored in the ArrayBuffer.](https://javascript.info/arraybuffer-binary-arrays)

**CAK SAM IM IZMERIO BYTE SIZE U JEDNOM PRIMERU, I ON IZNOSI GOTOVO ISTO ZA OBA TIPA BINARNIH VREDNOSTI**

```javascript
// fetch-OVAO SAM JEDNU SLIK USA ISTOG ORIGINA

let bas64;

var byteLength = str => parseInt((str).replace(/=/g,"").length * 0.75);

const uzmiFajlIdajBase64 = async () => {

    const response = await fetch('./slika.jpg')

    const blob = await response.blob();

    const fileReader = new FileReader()

    fileReader.onload = e => {


        base64 = e.target.result;

        console.log({base64, byteSize: byteLength(base64)})         //  ---->   ~      10350



    }

    fileReader.readAsDataURL(blob);

}

let buffer;

const uzmiFajlIdajArrayBuffer = async () => {

    const response = await fetch('./slika.jpg')

    const blob = await response.blob();

    const fileReader = new FileReader()

    fileReader.onload = e => {


        buffer = e.target.result;

        console.log({buffer, byteSize: buffer.byteLength})     // ---->   ~    10200

    }

    fileReader.readAsArrayBuffer(blob);

}




uzmiFajlIdajArrayBuffer();

uzmiFajlIdajBase64();


```

**KONACNO CU SADA DA ODRADIM PRIMER, U KOJEM CU DA KORISTIM Uint8Array**

*DA KRENEM TAKO STO CU KONIGURIRATI NOVI ENDPOIT, KAKO BI OMOGUCIO CORS*

firebase.json FAJL:

```javascript
{
  "functions": {
    "predeploy": [
      "npm --prefix \"$RESOURCE_DIR\" run lint"
    ]
  },
  "hosting": {
    "public": "public",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [ {
      "source": "/storePostData",
      "function": "storePostData"
    },
    {
      "source": "/testingPost",
      "function": "testingPost"
    }, 
    {
      "source": "/testGoogleStorage",
      "function": "testGoogleStorage"
    },
    {
      "source": "/sendImageString",
      "function": "sendImageString"
    },
    {
      "source": "/storeUint",
      "function": "storeUint"
    }]
  }
}
```

DA SADA U MOM APP-U DEFINISEM NEKE HTML ELEMENTE, (FILE PICKER DUGME ZA SLANJE REQUEST-A, I IMG ELEMENT, BEZ DEFINISANOG src TRIBUTA)

```HTML
 <div class="blah_file_send">
    <input type="file" name="picAfile" multiple>
    <button>Posalji slike</button>
    <img class="slika" width="200" alt="slika">
</div>

<script>

    dugmeZaSlanje.addEventListener('click', ev => {      
            
        const fileList = pikerSlike.files;

        const blob = fileList[0];

        blob.arrayBuffer()              // POSTOJI METODA Blob-A
                                        // KOJA RETURN-UJE Promise, KOJI JE RESOLVED SA ArrayBuffer INSTANCOM
        .then(buffer => {
            
            // SA ArrayBuffer INSTANCOM MOGU INSTATICIZIRATI Uint8Array
            let uint8 = new Uint8Array(buffer);
            
            const stringFromUint = uint8.toString()      // OVO JE METODA KOJA JE OVERRIDE-UJE
                                                            //  Object.prototype.toString
                                                            // DAKLE U PITANJU JE DERUGACIJA METODA
            
            // A ONO STO CE PROIZICI IZ NJE JESTE OVAKAV STRING:

                                                        //                  "2,4,5,6,7,..."

            // JA TOM STING-U DODAJEM ZAGRADE, JER CU GA SLATI KAO TEXT
            const stringArray = `[${stringFromUint}]`;

            fetch('https://instapwaclone.firebaseapp.com/storeUint', {   // URL JE DAKLE NAPRAVLJEN OD
                                                                        // OD ONOG URLA GDE JE DEPLOYED WEB APP
                                                                        // I OD ENDPOINTA

                method: "POST",
                headers: {
                    "Content-Type": "text/plain",
                    // "Accept": "application/octet-stream"
                },

                body: stringArray

            })
            .then(response => {

                // CIM STORE-UJEM NIZ JA CU NAPRAVITI CLOUD API, KOJI CE PRISTUPITI NIZU U
                // DATBASE-U I ODMAH GA VRATITI NAZAD U RESPONSE-U

                return response.json()
                // KAD ODGOVOR STIGNE, NARAVNO CITAM GA SA json METODOM

                // ALI NE ZABORAVI DA JE NIZ USTVARI U VIDU STRINGA
                // NIS JE STRINGIFIED, JER NA SERVER STRANI MU NISTA NECU RADITI, U POGLEDU NEKE TRANSFORMACIJE

            })
            .then(data => {
                console.log(data)
            
                const array = JSON.parse(data.stringArray)

                // OVDE MOGU DA TRANSFORMISEM BINARNI DATA U BLOB, I NAPRAVIM URL POGODAN ZA UCITAVANJE SLIKE

                const url = URL.createObjectURL(
                    new Blob(
                        [new Uint8Array(array)]
                    )
                )

                // UCITAVAM SLIKU
                imageElement.src = url;


            })
            .catch(err => {

                console.log(err);

            })


        })



    })

</script>


```

KADA SAM DEFINISAO CLIENT SIDE CODE, VREME JE DA DEFINISEM MOJ ENDPOIT, ODNOSNO CLOUD FUNKCIJU KOJA TREBA DA HANDLE-UJE PRISTIGLI DATA

functions/index.js

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');

admin.initializeApp(functions.config().firebase)

const storage = admin.storage();

const Busboy = require('busboy');

const file_system = require('fs')
const os = require('os');
const path = require('path');

const UUID = require('uuid/v4');

const webpush = require('web-push');
const privateVapidKey = "oC8DBLahIEnXnAME7Je3jarU6rVY";
const publicVapidKey = "BMfwPHbn5_YXc0wZZu5xEIIhs40w8CDWGnFzvrBCChNxX_spJoSM";

/*
const gcsConfig = {keyFilename: '/instapwaclone-f5157fff88e9.json', projectId: 'instapwaclone'}
const {Storage} = require('@google-cloud/storage');
const gcs = new Storage(gcsConfig); */

// ZELIM DA KORISTIM DATBASE-OV API

const database = admin.database();

// KREIRACU CLOUD FUNCTIONS

exports.storeUint = functions.https.onRequest(async (request, response) => {

    const stringArray = request.body;

    // STRING ZELIM DA STORE-UJEM U NEKI NOVI OBJECT STORE (NE BRINI NE MORAS DA KORIGUJES PRAVILA JER SAM
    // RANIJE DOZVOLIO I READI I WRITE ZA SVE U DATBASE-U)
    // NA PRIMER, NEKA TO BUDE OBJECT STORE 'blah' (TACNIJEJE RECI NA LOKACIJI 'blah')

    const id = decodeURI(new Date().toISOString());

    const generatedPlace = database.ref('blah').push();         // OVO BI TREBALO U BAZI PODATAKA
                                                                // DA GENERISE ONO MESTO
                                                                //CIJI JE NAME SACINJEM IOD RANDOM KARAKTER-A
                                                                // METODA push TO RADI

                                    // TAKO DA DATA U OVOM SLUCAJU STORE-UJES NA

                                    // 'blah/ASDSDgfafdGFGFSh'

    // SADA SETT-UJEM FIELD-OVE NA TOM MESTU

    await generatedPlace.set({stringArray, id})   // Promise se resolve-uje ni sa cim (NEBITNO)

    /***************************************************************** */

    // SNAPSHOT-U, ONOG GENERISANOG MESTA MOGU PRISTUPITI KROZ SLEDECI LISTENER
    //
    // OVO USTVARI ZNACI DA SLUSAM SAMO JEDNU PROMENU (once) NA POMENUTOM MESTU U DATABASE-U
    //TA PROMENA JE DODAVANJE NOVE VREDNOSTI 'value'

    generatedPlace.once("value", snapshot => {

        response.status(200).json(snapshot.val())

        // DATA JE SADA SERVIRNA IZ DATABASEA

    })

})


```

ALI OVO DAKLE JESTE LOS NACIN, JER U DATBASE-U, JA STORE-UJEM OGROMAN NIZ, KOJI IMA HILJDE CLANOVA

ONO STA NEMAM JETE DOWNLOAD URL, KOJI BIH ODMA MOGAO KORISTITI

NAIME, OVAJ PREDHODNI PRIMER JE TU VISE BIO SAM ODA SE UPOZNAM SA BINARNIM NIZOVIMA I KAKO SE MOGU KORISTITI

**POSTO SAM SE DO ODREDJENOG NIVOA UPOZNAO SA BINARY DAT-OM, DA SE IPAK VRATIM NA UPOTREBU @google-cloud/storage, KAKO BI SE I SA TIM API-EM UPOZNAO**

## :name_badge::name_badge: AKO ZELIS DA VIDIS KAKO DA UPOTREBLJAVAS GOOGLE CLOUD STORAGE-A, KONKRETNO KAKO DA UPLOAD-UJES MOZES OTICI NA SLEDECI LINK :name_badge::name_badge:

[DOKUMENTACIJA](https://cloud.google.com/storage/docs/uploading-objects#storage-upload-object-code_sample) (POGLEDAJ CODE SAMPLES ZA NODE.JS)

A IMAS TO I U [github repo-u](https://github.com/googleapis/nodejs-storage/blob/master/samples/files.js)

**SAMO STO SE OVDE NE SPOMINJ TOKENI** (uuid)

1. MOGUCNOST JEDAN: ONI SU VEC IMPLEMENTED UNDER THE HOOD PRILIKOM UPLOAD-A

2. ILI NIKO NIJE HTEO DA OBJASNI KAKO SE FORMIRA URL UZ POMOC NJIH, VEC SU SAMO PRIKAZIVALI CODE ZA UPLOAD

ALI NISAM ZNAO ZA OVE NOVE MOMENTE:

****

STO SE TICE GOOGLE-CLOUD STORAGE DOKUMENTACIJE, **MISLIM DA SAM OTKRIO NAJBOLJU DOKUMENTACIJU VEZANU ZA Node.js** I AKO ZELIM DA SE NA NAJBOLJI NACIN UPOZNAM SA PAKETOM NAJBOLJE JE CITATI OVU [ZVANICNU DOKUMENTACIJU ZA GOOGLE CLOUD STORAGE Node.js](https://googleapis.dev/nodejs/storage/latest/index.html)

****

## :name_badge::name_badge: PRE NEGO STO SE POZABAVIM, MOJIM PRIMEROM (REDEFINISANJEM storePostData CLOUD FUNKCIJE), TREBALO BI DA PROCITAM, U GOOGLE CLOUD FUNCTIONS DOKUMENTACIJI, KAKO SE USTVARI MOZE HANDLE-OVATI MULTIPART DATA, ODNOSNO DATA SA multipart/form-data CONTENT TYPE-OM (I OVDE JE POKAZANA UPOTREBA BUSBOY-A) :name_badge::name_badge:

[GOOGLE CLOUD FUNCTIONS DOKUMENTACIJA, VEZANA ZA HANDLE-OVANJE MULTIPART FORM DATA-E](https://cloud.google.com/functions/docs/writing/http#multipart_data)

## :running::running::running::running: U MEDJUVREMENU, OTKRIO SAM NESTO, STO JE DA JE UPLOADING 'BLOB-A' NA CLOUD STRANI MOGUCE POSTICI UZ POMOC GOOGLE CLOUD STORAGE API, KORISCENJEM JEDNE DRUGE METODE :running::running::running::running:

****

STO SE TICE GOOGLE-CLOUD STORAGE DOKUMENTACIJE, **MISLIM DA SAM OTKRIO NAJBOLJU DOKUMENTACIJU VEZANU ZA Node.js** I AKO ZELIM DA SE NA NAJBOLJI NACIN UPOZNAM SA PAKETOM NAJBOLJE JE CITATI OVU [ZVANICNU DOKUMENTACIJU ZA GOOGLE CLOUD STORAGE Node.js](https://googleapis.dev/nodejs/storage/latest/index.html)

****

I ODATLE SAM SAZNAO POMENUTO, ALI HAJDE DA SVE POKAZEM PUTEM PRIMER-A

MEDJUTIM ONO STO MORAM KORISTITI U OVOM PRIMERU JESTE BINARNU VREDNOST

U SUSTINI STORAGE API CE STVORITI FAJL, UNDER THE HOOD ZA MENE, A JA SAMO TREBAM INICIRATI DA SE DATA KOJU OBEZBEDIM, UCITA U TAJ FAJL KAO WRITABLE, A TO SVE CINI JEDNA METODA, POMENUTOG FAJLA (TO JE save() METODA)

NECU DODATNO OBJASNJAVATI STREAM-OVE (SPOMINJAO SAM IH I RANIJE), JER TO BI TREBAL ODA URADIM KAKDA SE BUDEM BAVIO BACK END-OM DETALJNIJE

ODNOSNO KADA BUDEM UCIO Node.js BAVICU SE SVIM OVIM STVARIM-A

### :one: ONO STA SAM POKUSAO I USPELO MI JE JESTE DA SA CLIENT STRANE POSALJEM CEO Blob OBJEKAT, KOJI SAM ONDA UPLOAD-OVAO

TADA SAM NA SERVER STRANI KORISTIO &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **request.rawBody**

PRE PRIKAZA PRIMERA, DA KAZEM NESTO O [Buffer API-U](https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html#buffer_class_method_buffer_from_buffer), Node.js-A

NAIME, UZEO SAM SLEDECI CITATI SA STACK OVERFLOW-A, KOJI MNOGO TOGA OBJASNJAVA

>>>> Node Buffer is currently entirely based on Uint8Array. Everything you can do with a Uint8Array instance you can do with a Buffer instance. And even more, because Buffer adds additional functions and properties. Internally, when a Buffer instance has to be created, they actually create an Uint8Array instance and then set its prototype to the Node Buffer prototype. So you can access the underlying ArrayBuffer with buffer1.buffer, etc.

SADA DA SE VRATIM NA PRIMER

BACKEND:

```javascript
exports.sendRaw = functions.https.onRequest(async (request, response) => {

    const bucket = storage.bucket('gs://instapwaclone.appspot.com');

    // ONO STO CU PRVO DA URADIM, JESTE DA CU DA 'KREIRAM FAJL', KOJI TREBA DA BUDE UPLOADED
    // NA MESTU U BUCKET-U, KOJE CU SPECIFICIRATI ARGUMENTOM

    const file = bucket.file(`blahFolder/${new Date().toISOString()}.png`);

    // NARAVNO VIDIS KAKO OPVAKVO ZADAVANJE IMENA FAJLA, NA KOJU SAM ZAKACIO .png
    // MOZE BITI PROBLEMATICNO
    // JER TOME BI TREBALO DA PRISTUPIM A NE DA VRSIM OVAKAV HARD CODING


    // ZATO OVO JESTE LOS NACIN


    // SADA VRSIM UPLOAD, TAKO STO NA File-U, PRIMENJUJEM       save        METODU
    // SA      REQUEST-OVIM RAW BODY-JEM

    try{

        await file.save(request.rawBody)   // MOZES PROVERITI I KOJE METODE I PROPERTIJE IMA rawBody
                                            // USTVARI TO SU SVE MEETODE I PROPERTIJI KOJE IMA Node-OVA Buffer INSTANCA  

        // ONO STA JE USTVARI rawBody JESTE Buffer

        // IZGLEDA DA CE OVAJ API USTVARI RASCLANITI, POMENUTI BUFFER, KAKO BI SE U STORAGE-U UPLAOD-OVALA
        // ACTUAL SLIKA

        response.status(200).json({message: "USPEO JE UPLOAD", bufferRequest: request.rawBody instanceof Buffer})

        // NAPRAVIO SAM PROVERI I ZAISTA rawBody JESTE BUFFER

        // TO ZNACI DA SAM TAJ Buffer DIREKTNO STAVIO DA ON BUDE ARGUMENT PRILIKOM UPLODA-A
        // UZ POMOC SAVE METODE

        // PREDPOSTAVLJAM DA METODA PRAVI NEKEKAV PARSING, KAKO BI NA KRAJU BIO UPLOADED FAJL


    }catch(err){

        response.status(500).json({err, message: "NIJE USPEO UPLOAD"})

    }


})
```

FRONTEND:

```HTML

<style>
    .blah {
        position:fixed;
        left: 20%;
        top: 28%;
        z-index: 200;
    }
</style>
<div class="blah">
    <input type="file">
    <button>Salji</button>
</div>

<script>

    const fileInputBlah = document.querySelector('div.blah > input[type="file"]');
    const dugmeSalji = document.querySelector('div.blah > button');

    dugmeSalji.addEventListener('click', async e => {


        const response = await fetch('https://instapwaclone.firebaseapp.com/sendRaw',
            {
                method: 'POST',
                body: fileInputBlah.files[0],        // DAKLE SALJEM Blob DIREKTNO
                                                    // A NA SERVER STRANI MOCI CU MU PRISTUPITI KAO Buffer-U
            }

        )

        const data = await response.json()

        console.log(data)

    })

</script>

```

DAKLE IMACU FAJAL NA SPECIFICIRANOM MESTU U BUCKET-U, STO MOGU PROVERITI U FIREBASE KONZOLI

TAMO MOGU PRONACI I LINK (ALI MENI JE POTREBAN LINK ODMA RETURNED SA CLOUDA-A) (TO CU POKUSATI DA POSTIGNEM U JEDNOM PRIMERU O KOJEM CU GOVORITI U SLEDECEM NASLOVU)

ALI OVO NE RESAVA, MOJ PROBLEM, KOJI SE ODNOSI NA TO DA MI JE ZAISTA NEOPHODNA MULTIPART FORM DATA, NA SERVER STRANI, KAKO BIH ODMAH, U OKVIRU JEDNOG REQUEST-A, IMAO FAJL, ZAJEDNO SA OSTALI

I OPET MORAK POKUSATI DA KORISTIM MIDDLEWEAR, SA KOJIMA NA FIREBASE CLOUD STRANI IMAM PROBLEMA

ALI PRE TOGA, JOS JEDAN PRIMER, KOJI KORISTI Uint8Array

### :two: DAKLE SADA BIH ZELO DA DIREKTNO POSALJEM Unit8Array INSTANCU; ALI I DA NAPRAVIM DISTINGCIJU, IZMEDJU DVA TIPA URL-A, KOJI MOGU POSTOJATI U KONZOLI; JEDAN JE NAIME URL STORAGE LOKACIJE I FAJLA U NJEMU, A DRUGI JE DOWNLOAD URL

FRONTEND:

```html
    [<style>
        .blah {
            position:fixed;
            left: 20%;
            top: 28%;
            z-index: 200;
        }
    </style>
    <div class="blah">
        <input type="file">
        <button>Salji</button>
    </div>
    <script>

        const fileInputBlah = document.querySelector('div.blah > input[type="file"]');
        const dugmeSalji = document.querySelector('div.blah > button');


        dugmeSalji.addEventListener('click', async e => {

            let buffer = await fileInputBlah.files[0].arrayBuffer();     // CONVINIENT METODA ZA PRAVLJEJE BUFFER-A
                                                                         // return-UJE Promise, KOJI JE RESOLVED SA ArrayBuffer
                                                                         // INSTANCOM 
            const response = await fetch('https://instapwaclone.firebaseapp.com/octetSend', 
                {
                    method: 'POST',
                    body: new Uint8Array(buffer),       // POGLEDAJ SALJEM SADA Uint8Array
                    headers: {
                        "Content-Type": 'application/octet-stream', // OVO BI TREBAL ODA BUDE KOREKTAN HEADER U OVOM SLUCAJU
                                                                    // KADA VIDIM U KONZOLI UPLOADED SLIKU TAM OSAM ZAPAZIO OVAJ
                                                                    // CONTENT TYPE, ALI I ON JESTE TYPE KADA SE SALJU TYPED ARRAY-OVI
                                                                    // (PREDPOSTAVLJAM)
                    }
                }

            )

            buffer = null;  // PREDPOSTAVLJAM DA JE DOBRO UNISTITI REFERENCU

            const data = await response.text()

            console.log(data)

        })

    </script>]
```

BACKEND:

```javascript
exports.octetSend = functions.https.onRequest(async (request, response) => {

    const bucket = storage.bucket('gs://instapwaclone.appspot.com');

    // TRBD A IMAS NA UMU DA SLEDECE STO SAM ZADA OKAO ARGUMENT file METODE

    const file = bucket.file(`blahFolder/${new Date().toISOString()}.png`);

    // !!!!!!! I TO NEMA VEZE SA DOWNLOAD URL-OM, JER ON SE GENERISE DRUGACIJE

    // DAKLE FAJ BI TREBALO DA BUDE SMESTEN U       MOM BUCETU          gs://instapwaclone.appspot.com
    //                                              U FOLDERU           blahFolder
    //                                              POD IMENOM          nekiDatumString.png
    ///////////////////////////////////////////////////////

    // NE ZABORAVI DA JE DOWNLOAD URL, ONAJ URL KOJI IMA SLEDECI DEO

// https://firebasestorage.googleapis.com/v0/b/instapwaclone.appspot.com/o/blahFolder%2F2019-08-23T22%3A44%3A56.043Z.png   

// (IMA JOS DELOVA URL-A KOJI SU GENERISANI (A KOJE I TI MOZES GENERISTI UZ POMOC UUID-JA))

    // NAIME AKO POSMATRAS DOWNLOAD URL (BAR ONAJ DEO KOJI SAM PRIKAZAO), MOZES VIDETI DA SE ON SASTOJI OD

    //                                          - OSNOVNOG DELA KOJI JE ISTI

    //                                                      https://firebasestorage.googleapis.com/v0/b/

    //                                          - IMENA BUCKET-A

    //                                                       instapwaclone.appspot.com/

    //                                          - ZATIM OD SLEDECEG

    //                                                        o/

    //                                          - ZATIM TU JE I IMAE FAJLA, KOJE SAM JA ZADAO
    //                                              I KOJE JE SA EKSTENZIJOM

    // ONO ODCEGA SE SASTOJI OSTATAK URL OBJASNICU U PRIMERU, KOJI CE USLEDITI NAKON OVOG

    try{
        // SADA STVARNO UPLOADUJEM
        await file.save(request.rawBody)

        response.status(200).send("This thing is uploaded");

    }catch(err){

        response.status(500).send("Uploaded is not");

    }


})
```

**KAO STO VIDIS I Unit8Array JE VALJAN ARGUMENT ZA save METODU**

### :three: DOBRO, U OVOIM PRIMERU, SLACU SAMO JSON DATA, ODNSNO POKUSACU DA POSALJEM JEDAN STRINGIFIED Uint8Array, SA METAPODACIMA FAJLA, ALI NA PRIMER ZELIM DA POSALJEM I NEKE DRUGE STRINGOVE (KAO DA JE U PITANJU JEDAN POST SA NASLOVOM, CONTENTOM I SLIKOM); A NAKON UPLOAD-A, ZELIM DA OBEZBEDIM I DOWNLOAD URL; ALI ONO STO CU URADITI TAKODJE JESTE DA CU KADA NAPRAVIM Unit8Array JA USTVARI SA NJIM KREIRATI Buffer; JER ZELIM DA Buffer KORISTIM PRI UPLOAD-U

DAKLE POKUSAVAM DA ISPROBAM DRUGACIJI PRINCIP PO KOJEM SALJEM STRINGIFIED Unit8Array, ODNOSNO SA NJIM ZELIM DA POSALJEM JOS METAPODATKAKA, KO STO SU IME FAJLA, JER ZELIM DA GA ISKORISTIM, PRILIKOM UPLOAD-A; A ZELIM DA IMAM I MIMETYPE

ONO STA CU KORISTITI JESTE I uuid KOJI CU, KROZ METADATA DODATI DOWNLOAD URL-U

ZASTO TO RADIM?

PA NA PRIMER, JA NE ZELIM DA, JEDNIM 'POST' REQUEST-OM SALJEM, SAMO FAJL; VEC PORED FAJLA JA ZELIM DA SALJEM PODATKE, KOJI CE BITI PODACI JEDNOG POSTA (KAO STO SU TITLE I CONTENT) (BAS KAO STO JE I PLANIRANO U GLAVNOM PRIMER-U, MOG APP-A)

PA POMISLIH, ZASTO NE BIH POSLAO STRINGIFIED Uint8Array, SA METADATA-OM, KAO DEO JEDNOG JASON OBJEKTA, A UZ NJEGA CU NAPRIMER POSLATI I DATA-U IZ DRUGIH INPUT-OVA, KOJI BI BILI NAMENJENI NA PRIMER NEKOM SADRZAJU I NASLOVU (BAS KAO DA SE UNOSI JEDDAN POST)

NAIME, KAO STO SAM REKAO Buffer INSTANCA, KOJA SE KORISTI U Node.js -U JESTE 'BASED' NA Unit8Array-U; NAIME [JA MOGU KREIRATI Buffer SA Unit8Array INSTANCOM](https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html#buffer_class_method_buffer_from_buffer)

**I buffer INSTANCU ZELIM DA KORISTIM PRI UPLOAD-U**


DA POCNEM SA PRIMEROM

- PRVO DEFINISEM CLIENT CODE

```html
<style>
    .blah {
        position:fixed;
        left: 20%;
        top: 28%;
        z-index: 200;
    }
</style>
<div class="blah">
    <input type="file">
    <input type="text" placeholder="Title">
    <input type="text" placeholder="Content">
    <button>Salji</button>
</div>
<div class="blah_posts"></div>
<script>

    const fileInputBlah = document.querySelector('div.blah > input[type="file"]');
    const dugmeSalji = document.querySelector('div.blah > button');
    const titleInputBlah = document.querySelector(
        'div.blah > input:not(:nth-of-type(1)):not(:nth-last-of-type(1))'
    )
    const contentInputBlah = document.querySelector('input[placeholder=Content]')



    dugmeSalji.addEventListener('click', async e => {

        // e.stopImmediatePropagation();

        const content = contentInputBlah.value; 
        const title = titleInputBlah.value;
        let blob = fileInputBlah.files[0];
        
        const mimeType = blob.type;
        const fileName = blob.name;
        const fileNameExtension = 
        ("." + mimeType.replace(/\w+\//g, "")).toLowerCase();  // OVDE CU DOBITI NA PRIMER .png ILI .jpg
                                                                        // OVO MI DELUJE NEKEKO SIGURNIJE NEGO DA
                                                                        // KORISTIM IME FAJLA, KOJI TAKODJE IMA .png
                                                                        // ILI SLICNO NA SEBI
        
        // VEZBAM I MALO RegExp

        const name = fileName.toLowerCase().replace(fileNameExtension, "")  // HOCU I SAMO IME FAJLA BEZ TYPE EXTENSION-A



        let buffer = await blob.arrayBuffer();      // VARIJABLA, NIJE KONSTANTA, JER ZELIM DA JE UNISTIM NA KRAJU
        
        let uint8 = new Uint8Array(buffer);
        
        let fileString = uint8.toString();          // OVO CE RETURN-OVATI OVKAV STRING 
                                                                //   "6, 8, 0, 0, 0, 0, 9, 4, 6, 9, 5, 0, 0..."

        console.log({mimeType, name, fileNameExtension, name, fileString, content, title});

        // POMENUTI fileString BICE OGROMAN ZATO CE U KONZOLI PRILIKOM STAMPE, BITI TRUNCATED
        // JER ZUZIAM OGROMAN PROSTOR, ISTO KAO STO JE I SLUCAJE SA Base64 URI-OM

        let response;

        try{

            response = await fetch('https://instapwaclone.firebaseapp.com/createPostBlah',
                {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Accept": "application/json"
                    },

                    // DAKLE, SVE PODATKE UGRADJUJEM U OBJEKAT JSON FORMATA, UKLJUCUJUCI
                    // I OGROMNI STRING, SADTAVLJEN OD JEDNOCIFRENIH CELIH BROJEVA I NULA

                    body: JSON.stringify({postData: {    // ZASTO SAM SVE WRAPP-OVAO U JOS JEDAN PODOBJEKAT
                                                            // MISLIM DA MOZE DOCI DO OVERRIDING-A
                                                            // SA ONI MDRUGIM PROPERTIJIMA IZ BODY-JA
                                                            // NA PRIMER file (DA NISAM SVE WRAPP-OVAO
                                                            // NA SERVER STRANI BIH GA CITAO, KAO 
                                                            // request.body.file 
                                                            // E PA JA MISLIM DA TAJ PROPERTI VEC POSTOJI NA BODY-JU)
                                                            // ZATO CU SAD DATA NA CLOUDU CITATI request.body.postData
                                                            // i tak odalje
                                                            // MOZDA CAK I GRESIM (NIJE VAZNO)
                        content,
                        title,
                        file: {
                            mimeType,
                            fileNameExtension,
                            name,
                            fileString
                        }
                    }})
                    
                }
            )

            //  MOZDA BIH OVDE MOGAO DA UNISTIM REFERENCE NA LARGE OBJEKTE I STRINGOVE
            blob, buffer, uint8, fileString = null;
            //


            const takenPostData = await response.json()

            console.log(takenPostData);  // KASNIJE CU ODLUCITI STA BIH MOGAO DA URADIM SA PODACIMA
                                            // DAKLE SVI PODACI BI TREBAL IDA BUDU FETCHED IZ DATABASE-A
                                            // JER SU TAM OSTAVLJENI I ODANDE TREBA DA BUDU UZETI
                                            // KAKO BI SE NAPRAVIO, JEDAN POST
                                            // MEDJU PODACIAM TREBA DA BUDE I DOWNLOAD URL-A
                                            // FAJLA, KOJI JE UPLOADED U STORAGE


            // EVO OVDE MOGU DEFINISATI DA SE SAMO ISKORISTI URL SLIKE

            const image = new Image();

            image.src = takenPostData.url

            document.body.append(image)


        }catch(err){

            //  MOZDA BIH OVDE, TAKODJE MOGAO DA UNISTIM REFERENCE NA LARGE OBJEKTE I STRINGOVE
            blob, buffer, uint8, fileString = null;
            //

            console.log({err});


        }


    })

</script>
```

- PA SADA DEFINISEM NOVU CLOUD FUNKCIJU, KOJA TREBA DA HNDLE-UJE, SAV POSLATI DATA

```javascript

exports.createPostBlah = functions.https.onRequest(async (request, response) => {

    // DA ODMAH RESTRUKTURIRAM DATA, JEDNOG POST-A, JER TREBACE MI ODMAH

    const {content, title, file} = request.body.postData;

    // RESTRUKTURIRACU I file  OBJEKAT, JER I ON IMA PROPERTIJE, KOJE SAM PODESIO PRE SLANJA REQUEST-A, NA CLIENT-U

    const {mimeType, fileNameExtension, name, fileString} = file;

    // TREBACE MI MOJ BUCKET, I TREBACE MI REFERENCA MESTA U REALTIME DATBASE-U

    const bucketLocation = 'gs://instapwaclone.appspot.com';

    const bucket = storage.bucket(bucketLocation);

    const databasePlaceRef = database.ref('blahPost').push();    // TAKO RECI, KADA BUDEM KORISTIO OVU REFERENCU
                                                            // ZA STAVLJANJE U DATABASE
                                                            // OBJEKAT RELATED TO POST BI TREBAL DA BUDE U 
                                                            // blahPost OBJECT STORE-U
                                                            // (NE ZABORAVI DA REDEFINISES SECURITY RULES
                                                            // ZA OVO MESTO U DATABASE-U)

    // !!!!!!!!!    DAKLE U PREDHODNOM PRIMERU SAM OBJASNIO OD CEGA SE SASTOJI URL
    // !!!!!!!!!    I OBJASNIO SAM I DA POSTOJE DVA URL-A (LOKACIJSKI I DOWNLOAD)
    // !!!!!!!!!    JA CU POZIVANJEM file METODE USTVARI DEFINISATI GDE FAJL TREBA DA BUDE U BUCKETU I POD KOJI MIMENOM
    // !!!!!!!!!        (NEMOJ DA POMISLIS DA SADA OVDE DEFINISEM DOWNLOAD URL (TO JOS NE RADIM))

    // DAKLE KADA SE FAJL BUDE UPLAOD-OVAO, ZELIM DA NJEGOVA LOKACIJA BUDE TAKVA, DA ON BUDE
    // SMESTEN U        blahFiles        FOLDER, I DA IMA ONO ISTO IME SA KOJIM JE POSLAT DO ENDPOINTA

    const myFile = bucket.file(`blahFiles/${name + fileNameExtension}`)
    // MOZDA PREVISE KORISTIM POMENUTU decodeURI METODU, ALI NEMA VEZE

    // SADA ZELIM DA NAPRAVIM Uintu8Array INSTANCU

    try{

        // ALI ZELIM DA HANDLE-UJEM ANY ERROR, KOJI MOZE NASTATI U TOM PROCESU

        // NE ZABORAVI DA PRASE-UJES
        const uint8 = new Uint8Array(JSON.parse(`[${fileString}]`));  // DAKLE OD OVOGA OVDE ZELI MDA KREIRAM Buffer
        // https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html#buffer_class_method_buffer_from_buffer

        // SADA ZELIM DA KREIRAM Buffer INSTANCU, KOJA SE KORITI NA CLOUD-U
        const buffer = Buffer.from(uint8);
        // U DOKUMENTACIJI JE NAVEDENO DA CE ALLOCATED MEMORI OD unit8, BITI ODUZETA uint8-U I DATA NOVOM Buffer-U

        // OVDE CU DEFINISATI UPLOAD I ZELIM DA UTICEM NA TO KAKO CE IZGLEDATI URL, UZ POMOC
        // uuid -JA

        // KREIRACU uuid

        const uuid = UUID();

        console.log({uuid})

        await myFile.save(buffer,    // TREBAO BI DA DEFINISEM I OPTIONS OBJEKAT, I 

            {
                uploadType: "media",
                metadata: {
                    metadata: {
                        contentType: mimeType,
                        firebaseStorageDownloadTokens: uuid  // OVDE ZADAJEM uuid KLJUC, KOJI CE BITI DEO DOWNLOAD URL-A
                    }
                }
            }
        )

        // AKO JE USPEO UPLOAD, MOGU SE FORMIRANJU DOWNLOAD URL, ON VEC NAIME POSTOJI, ALI POTREBNO GA JE OVDE
        // REKREIRATI DA BIH GA POSLAO U DATBASE
        // TAKAV URL SALJEM U DATBASE, SA title-OM I contentom, KAO DELOVIMA, JEDNOG POST-A

        const url = 'https://firebasestorage.googleapis.com/v0/b/' +
            bucketLocation.replace("gs://", "") +           // OVO SAM URADIO JER MI TREBA SAMO IME BUCKETA
            "/o/" + "blahFiles" + encodeURIComponent("/") + encodeURIComponent(name) + fileNameExtension + // NE ZABORAVI blahFiles FOLDER DA NAVEDES
            "?alt=media&token=" + uuid;

            // !!!!!!!!!!!!!!!!! PROBLEM IMAS U POGLEDU KAKO SE FORMIRA UPLOAD URL
            // !!!!!!!!!!!!!!!  IZGLEDA DA CLOUD STORAGE API, SAM UNDER THE HOOD VRSI ENCODING

            // !!!!!!!!!     I ONAJ SLASH SIGN ('/') IZMEDJU        blahFiles FOLDERA       I       IMENA FAJLA
            // !!!!!!!!      BIVA ENCODED

            // !!!!!!!       IME FAJLA CE TAKODJE BITI URL ENCODED

            //  TAKO DA SAM JA MORAO UPOTREBITI    encodeURIcomponent   GORE NAD POMENUTIM SLASHOM

        // ISTO TAKO POTREBNO JE DA SE ENCODE-UJE IME U URL-U, JER SAM GA ENCODE-OVAO I PRILIKOM UPLOAD-A

        // VODI RACUNA DA SE            encodeURI I decodeURI       KORISTE ZA CELOKUPNI URL (ONAJ SA http://)

        // A                       encode/decodeURIComponent        SE KORISTE ZA ZELJENE STRINGOVE

        // const id = new Date().toISOString();

        await databasePlaceRef.set({     // OVO BI TTEBAL ODA GENERISE POST (I DATA U NJEMU)
                                      // U DATABASE MESTU KOJE SAM RANIJE GORE DEFINISAO  (ODNOSNO LAKACIJI)
                                      // IME (ODNOSNO key) OVOG POST OBJEKTA JE GENERISAN
                                      // MOGU GA ZADATI I DA BUDE VREDNOST id PROPERTIJA POST-A

            title, content,
            id: databasePlaceRef.key,    // MOZDA JE OVO LOSA STVAR, MOZDA NIJE () (A MOZDA JE id U POSTU)
            url                         // SUVISNA STVAR PRI BAVLJENJU SA REALTIME DATBASE-OM FIRESTORE-S
        })

            // DAKLE OVO SU BILI GRADIVNI ELEMENT-I URL-A

        //  https://firebasestorage.googleapis.com/v0/b/
        // instapwaclone.appspot.com/
        // o/


        //      ?alt=media&token=           KAO STO VIDIS OVO SAM DODAO PORED SVEGA ZAJEDNO SA uuid KLJUCEM



        // console.log({content, title, file});

        // SAD IMAS POST REFERENCE I MOZES DA TRAZIS SNAPSHOT, A IZ NJEGA MOZES DA POSALJES PODATKE POSTA NAZAD
        // DO CLIENT-A,
        // U BODY-JU RESPONSE

        const snapshot = await databasePlaceRef.once('value')

        // SALJEM PODATKE SNAPSHOTA NAZAD DO CLIENT

        response.status(200).json(snapshot.toJSON())

    }catch(err){

        response.status(500).json({error_message: err})

    }


})
```

MISLIM DA SE MORAS BOLJE UPOZNATI SA FIREBASE DATABSE API-OM, JER JE I ON SJAJAN

POGOTOVO MI JE SJAJNA [ThenableReference INSTANCA](https://firebase.google.com/docs/reference/js/firebase.database.ThenableReference) KOJU SAM LEPO MOGAO UPOTREBITI U PREDHODNOM PRIMERU



ISTO TAKO PROBAJ I [ultiparty](https://www.npmjs.com/package/multiparty#readme)






## :dash::dash::dash::dash: SADA MOGU ODPOCETI SA DEFINISANJEM storePostData CLOUD FUNKCIJE, KOJA UZ POMOC BUSBOY PAKETA, TREBA DA PARSE-UJE FormData, KAK OBI MI PRVENSTVENO BILO OMOGUCENO DA KORISTIM FAJL, ODNOSN ODA KORITIM GOOGL CLOUD STORAGE API, KAKO BI UPLOAD-OVAO TAJ FAJL, I UZEO NJEGOV DOWNLOAD URL; NARAVNO, ZA SLUCAJ USPESNOG UPLOAD-A, I GETTING-A POMENUTOG URL-A, DEFINISEM DA JE TAJ URL, ZAJEDNO SA SVIM OSTALIM POSLATIM PODACIMA (KROZ FormData) DEO JEDNOG POST OBJEKTA, KOJEG CU DODATI U REALTIME DATABASE-U, U 'posts' OBJECT STORE :dash::dash::dash::dash:

MORAM RECI NEKE VAZNE INFORMACIJE KOJE SE TICU READABLE I WRITABLE STREAMOVA U Node.js-U, JER CU IH KORISTITI

PRVENSTVENO ONE INFORMACIJE, KOJE SE TICU EVENT-OVA, WRITABLE-A UI REDABLE-A

POGLEDAJ SLEDECI NAVOD

>> end and finish are the same event BUT on different types of Streams

>>stream.Readable fires ONLY end and NEVER finish

>>stream.Writable fires ONLY finish and NEVER end

[DOKUMENTACIJA](https://nodejs.org/dist/latest-v5.x/docs/api/stream.html#stream_events_finish_and_end)

DA SADA DEFINISEM CODE ZA

functions/index.js FAJL, ODNOSNO MOJU storePostData FUNKCIJU

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');

admin.initializeApp(functions.config().firebase)

const storage = admin.storage(); // DAKLE OVO JE USTVARI @google-cloud/storage API

const Busboy = require('busboy');

const file_system = require('fs')
const os = require('os');
const path = require('path');

const UUID = require('uuid/v4');

// ****************************************************************************
const webpush = require('web-push');
const privateVapidKey = "oC8DBLahIEom6BtrF6z7_rVY";
const publicVapidKey = "BMfwPHbnYXc0wZZu5xEIIhs40w8CDWGnf2HSq-v-vS_m122gcDRgFzvr";
// *******************************************************************************

// OVO MI NE TREBA JER KAO STO SAM REKAO IMAM PRISTUP, POMENUTOM API-U, KROZ ADMIN-A (POKAZO GORE)
/* const gcsConfig = {keyFilename: '/instapwaclone-f5157fff88e9.json', projectId: 'instapwaclone'}
const {Storage} = require('@google-cloud/storage');
const gcs = new Storage(gcsConfig); */


// ZELIM DA KORISTIM DATBASE-OV API

const database = admin.database();

// KREIRACU CLOUD FUNCTIONS FROM SCRATCH, NE OBAZIRUCI SE NA ONE RANIJE NEUSPELE VERZIJE

exports.storePostData = functions.https.onRequest((request, response) => {

    // AKO NIJE REC O 'POST' REQUEST-U, SALJEM ERROR SA STATUSOM  405
    // DA DRUGI METOD NIJE DOZVOLJEN

   if(request.method !== "POST") response.status(405).end()   // I END-UJEM RESPONSE PROCES


    const uuid = UUID();

    const busboy = new Busboy({headers: request.headers});

    const bucket = storage.bucket('gs://instapwaclone.appspot.com'); // FIREBASE-OV JEDINI BUCKET
                                                                     // KOJI SAD KORISTIM PUTEM
                                                                     // @google-cloud/storage API-A
    //response.status(200).send({data: bucket.name});

    // UZIMAM PATH CLOUD-OVOG TEMPPORARY DIREKTORIJUMA

    const tempfolderPath = os.tmpdir();

    // KREIRAM OBJEKAT U KOJI CU SKUPITI KEY VALUE PAROVE, PROCITANE OD FIELD-OVA IZ FormData-E
    // ALI IZUZEV FAJLA
    const fields = {};

    // KREIRAM OBJEKAT, KOJI TREBA DA SE SASTOJI OD SLEDECIH PAROVA:
    //              -  IME FIELD-A, KOJE JE ZADATO KADA JE Blob APPENDED NA FormData INSTANCU (NA CLIENT-U)
    //              -  CELI PATH FAJLA, U TEMPORARY FOLDER-U OPERATIVNOG SISITEMA CLOUD-A
    const tempFilePaths = {};

    // SADA CU KREIRATI JEDAN NIZ, A TAJ NIZ TREBA DA SKLADISTI Promise INSTANCE,
    // I TAJ NIZ TREBA DA BUDE ARGUMENT,     Promise.all()        METODE
    // U SUSTINI, SVAKA Promise INSTANCA IZ OVOG NIZA, TREBALA BI DA SE RESOLVE-UJE, ONDA KADA
    // SE MOJ FAJL USPESNO UPISE U WRITE STREAM
    const fileWrites = []

    // NARAVNO, RADIM KROZ ODREDJEN LISTENER, KOJI je MOGUCNOSTI BUSBOY-A (VIDECES DOLE STA JE U PITANJU)
    // ALI I KROZ WRITE STREAM
    //***********************************************************************************************


    // SADA TREBA DA PROCESS-UJEM SVE FILED-OVE (MISLIM AN SAMO ONE KOJI SU TEXT (NE FAJLOVI)), IZ FormData-E
    // TO CU URADITI UZ POMOC SLEDECEG BUSBOY-OVOG HANDLERA
    // ODNOSNO, POMENUTI HANDLER, TREBALO BI DA SE IZVRSI, SVAKI PUT KADA JE DETECTED FIELD CIJA VREDNSOT JE TEKST
    // DAKLE NE FAJL
    busboy.on('field', (fieldname, val) => {
        fields[fieldname] = val;
    })

    // DEFINISACU JEDAN BROJAC. A VIDECES I ZASTO U SLEDECEM HANDLER-U
    let i = 0;

    //SADA PROCESSUJEM SVE FAJLOVE IZ FormData
    // UZ POMOC DRUGOG BUSBOY-OVOG HANDLER-A
    // ODNOSNO, POMENUTI HANDLER, TREBALO BI DA SE IZVRSI, SVAKI PUT KADA JE DETECTED FIELD CIJA VREDNSOT JE FAJL
    busboy.on('file', (fieldname, file, filename, encoding, mimetype) => {
        
        // !!!!!!!!!!!!!!!!    CISTO DA NAPOMENEM       file        PARMAETAR SE ODNOSI NA READABLE STREAM

        // FORMIRAM PRVO ONAJ PATH DO FAJLA U TEMPORARY FOLDER-U OS-A CLOUD-A

        const filePathForTemp = path.join(tempfolderPath, filename)

        // PA DODAJEM TAJ POTPUNI PATH DO FAJLA
        
        tempFilePaths[fieldname] = filePathForTemp;

        // KREIRAM JEDAN WRITE STREAM I NJEGOVA REFERENCA CE BI TREBATI NA MNOGO MESTA

        const writeStream = file_system.createWriteStream()

        // SADA UCITAVAM FAJL U TAJ WRITE STREAM, ALI NECU TO URADITI PRE NEGO STO ZAKACIM NEKE EVENT HANDLERE
        // I NA WRITABLE, ALI I NA FILE


        // ~~~~~                O       finish      I           error       EVENT-OVIMA     WriteStream-A
        // !!!!!!!!!!  SADA JE POTREBNO SLUSATI NA TO DA LI JE FAJL USPESNO ILI NEUSPESNO UPISAN U WRITE STREAM
        // !!!!!!!!!!  ALI TO ZELI MDA URADIM KROZ      Promise         INSTANCU
        // !!!!!!!!!!  AKO JE USPESNO UPISAN ZELI MDA SE Promise RESOLVE-UJE, A AKO JE NEUSPESNO UPISAN, ZELIM DA
        // !!!!!!!!!!  REJECT-UJE
                                    
        
        // ~~~~~                O        end        
        // ALI ZELIM DA ZAKACIM LISTENER I NA FAJL, A TAJ LISTENER BI TREBAO DA SE IZVRSI KADA SE FAJL
        // UPLOAD-UJE (TO PREDPOSTAVLJAM); A TADA TRBA ZATVORITI WRITABLE
        
        // TO O ZATVARANJ USAM PROCITAO OVDE SAM PROCITAO:
        //          https://nodejs.org/api/stream.html#stream_writable_end_chunk_encoding_callback
        // >>>>>    Calling the writable.end() method signals that no more data will be written to the Writable


        const promise = new Promise((resolve, reject) => {

            file.on('end', () => { writeStream.end() })         // READ STREAM SE MOZE END-OVATI

            writeStream.on('finish', resolve)       // WRITE STREAM MOZE SE FINISH-OVATI

            writeStream.on('error', reject)

            // The 'finish' and 'end' events are from the parent Writable and Readable classes respectively. 
            // The 'finish' event is fired after stream.end() 
            // is called and all chunks have been processed by stream._transform(),
            // 'end' is fired after all data has been output which is after the callback 
            // in stream._flush() has been called.
            // (NAVOD NE ZNACI MNOGO ALI MALO JE JASNIJE)
        })

        // DAKLE DEFINISEM PIPING, ODNOSNO UPISUJEM READABLE STREAM U WRITABLE STREAM

        file.pipe(WritableStream);

        // SADA I PROMISE MOGU DODATI, ONOM NIZU ZA PROMISE INSTANCE, ZA KOJI SAM REKAO DA CE BITI ARGUMENT
        // Promise.all() METODE

        fileWrites.push(promise)

    })


    // SADA MOGU SLUSATI NA EVENT 'finish'  NA BUSBOY-U , KOJI BI TREBAO DA SE TRIGGER-UJE NA BUSBOY-U, SVAKI PUT
    // KADA SE

     // This callback will be invoked after all uploaded files are saved. (NE ZNAM DA LI CE BITI INVOKED NAKON
     // SVAKOG SAVE-A U WRITABLE STREAM-U, ILI NAKON SVIH, PREDPOSTAVLJAM D SU SVI)

    // PREDPOSTAVLJAM DA JE Promise.all, OVDE NEKA MERA PREDOSTROZNOSTI 
    // NJEGA CU OVDE POZVATI I ODPOCETI SA UPLOAD-OM, SAMO
    // KADA SE Promise INSTANCA PROIZASLA IZ TE METODE, RESOLVE-UJE
    
    busboy.on('finish', () => {
        Promise.all(fileWrites).then
    })




})





```


STO SE TICE URL ENCODINGA, KOJI SAM GORE POMENUO ,TREBA DA TI BUDE JASNO DA SI KORISTIO [encodeURIComponent()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) FUNKCIJU, KOJA SE MOZRE KORISTITI U NODE-U, IAKO SAM JOJ JA NASO DOKUMENTACIJU SAMO VEZAN OZA CLIENT, ALI I Node.js IMA TU FUNKCIJU

## DEPLOY-OVACU SADA MOJE CLOUD FUNKCIJE

- firebase deploy --only functions

I MOJA storePostData FUNKCIJA BI SADA TREBALA DA BUDE UPDATED

