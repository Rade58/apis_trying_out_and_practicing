# PRE NEGO STA BILO KAZEM OVDE, MORAM RECI DA SE FAJL MOZE UPLOAD-OVATI IZ MOJE APLIAKCIJE, KORISCENJEM firebase.storage API-A I TAKO STAVITI U FIREBASE STORAGE, STO SAM RADIO U, DRUGOM PROJEKTU, GDE NISAM SLAO FAJL APPENDED NA FormData INSTANCU, STO OVDE SADA RADIM

TO SAM VEC RADIO U ONOJ REACT APLIKACIJI; TAKO DA U BUDUCNOST KORISCENJE FormData NECE DOLAZITI U OBZIR

JER JE FIREBASE, PRETRPEO PROMENE I NE MOZE SE VISE KORISTITI formidable PAKET

A STORAGE KAO STO SAM REKAO MOGU KORISTITI NA CLIENT STRANI

>>>> [Node.js doesn't have a built-in multipart/form-data parsing library.](https://cloud.google.com/functions/docs/writing/http#multipart_data)
>>>>  Instead, we can use the ['busboy'](https://www.npmjs.com/package/busboy) library from NPM to parse these requests.

DAKLE PAKET, KOJI BI TREBALO DA RADI JESTE busboy PAKET

## OVDE CU DAKLE POPRAVITI CODE MOJE CLOUD FUNKCIJE, KOJA JE TREBALA DA RECEIVE-UJE FORM DATA; A PROBLEMI SU NASTALI ZBOG KORISCENJA PAKETA formidable; ON SE NAIME VISE NE MOZE KORISTITI, JER JE FIREBASE PRETRPEO NEKE PROMENE

RECENO JE DA formidable NE RADI VISE ZA GOOGLE CLOUD FUNCTIONS IZ ISTOG RAZLOGA ZASTO NE RADI I [multer](https://www.npmjs.com/package/multer) PAKET

*ZASTO NE RADI POMENUTI PAKET, NE MOGU NIGDE NACI ODGOVOR, ALI U REDU JE JER MI I NETREBA (DAKLE ODGOVOR ZASTO NE RADI formidable MORAM NACI NEGDE DRUGDE (ALI NIJE NI BITNO JER ZNAM ZA PAKET KOJI FUNKCIONISE))*

PRE SVEGA JA CU OVDE OSTAVITI NEKE VALIDNE INFORMACIJE, KOJE SE TICU, KORISCENJA STORAGE-A

ALI OBRATICU PAZNJU I NA NEKE PROMENE, KOJE SU SE DESILE U FIREBASE-U

OVDE CES DO ODREDJENOG NIVOA KORISTITI I ODREDJENE Node.js FEATURE-E, ODNOSNO API-EVE

ALI GOTOVO SVA OBJASNJENJA ZA ONO STO CU KORISTITI MOZES NACI U [DOKUMENTACIJI ZA API-JEVE Node.js-A](https://nodejs.org/api/)

## NAIME JA CU U MOM PROJEKTU KORISTITI @google-cloud/storage PAKET; A ZASTO AKO IMAM PRISTUP STORAGE-U I KROZ FIREBASE? ZBOG PRIRODE PROJEKTA, JER AUTOR PEOJEKTA ZELI DA SALJE FormData DO ENDPOINT-A, A NA NJEMU APPENDED IMAGE FILE; PORED PROBLEMA STO CLOUD NEMA NACINA DA HANDLE-UJE FormData, POSTOJI I OGRANICENJE firebase.storage API-A, KOJE SE OGLEDA U TOME DA NE PRIHVATA PATH ARGUMENT; KOJI BI BIO PATH DO FAJLA, KOJI BI SE NAKON STIZANJA DO CLOUD FUNKCIJE, UPLOAD-OVAO U TEMPORARRY FOLDERU CLOUD OS-A

NAIME KADA SE UPLOAD-UJU FAJLOVI, POMOCU firebase.storage API, SAMO MOGU KORISTITI SLEDECE TIPOVE VREDNOSTI ZA FAJL:

- Blob  ([put](https://firebase.google.com/docs/reference/js/firebase.storage.Reference.html#put) METODA)

- Unit8Array (ISTA METODA KAO GORE)

- ArrayBuffer (ISTA -||-)

- Base64 STRING (ZA OVO NISAM SIGURAN, MISLIM DA SE OVO RADI POSEBNOM METODOM([putString](https://firebase.google.com/docs/reference/js/firebase.storage.Reference.html#put-string) MZODA))

A NE MOZE PRIHVATATI, SAMO PATH DO LOKACIJE U KOJOJ BI FAJL BIO TEMPORARY

MEDJUTIM @google-cloud/storage PAKET OMOGUCAVA DA KORISTIM FILE-OV TEMPORARY PATH, PRI UPLOAD-U (API JE NESTO KOMPLIKOVANIJI ZBOG KORISCENJA UUID PAKETA)

## :exclamation::exclamation::exclamation::exclamation: POSTO CE SE U MOM APP KORISTITI PAKET @google-cloud/storage, NA SLEDECEM LINKU, :exclamation: POGRESNO JE OBJASNJENA :exclamation: INTEGRACIJA GOOGLE CLOUD STORAGE-A SA FIREBASE-OM; ZATO STO OBJASNJENJE VAZI ZA STARI API :exclamation::exclamation::exclamation::exclamation:

:exclamation::exclamation:[Integrate with Google Cloud Platform (NECE FUNKCIONISATI (FIREBASE MORA DA UPDATE-UJE SVOJU DOKUMENTACIJU))](https://firebase.google.com/docs/storage/gcp-integration):exclamation::exclamation:

## :white_check_mark::white_check_mark::white_check_mark: OBJASNJENJE NA SLEDECEM LINKU CE ZAISTA OBJASINTI PODESAVANJE CREDENTIAL VEZANOG ZA @google-cloud/storage; OVO OBJASNJENJE MOGU KORISTITI I AKO JE REC O INTEGRACIJI, KOJA SE TICE NEKE DRUGE PLATFORME, A NE FIREBASE; ONO STO CES VIDETI JESTE DA JE FIREBASE DOSTA STVARI URADIO ZA TEBE U OVOM POGLEDU, ZATO STO JE FIREBASE IPAK GOOGLE-OVA PLATFORMA :white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark::white_check_mark:

[google cloud storage CREDENTIALS](https://cloud.google.com/docs/authentication/production#auth-cloud-explicit-nodejs)

ONO STO BI TE ZANIMALO NA OVOJ STRANICI JESTE NASLOV `Obtaining and providing service account credentials manually`

**U SUSTINI POTREBNO JE GENERIJANJE json FAJLA NA KOME SU CREDENTIALS**

**E PA FIREBASE JE TO VEC URADIO ZA TEBE**

**TAJ JSON FAJL SE VEC NALAZI U functions FOLDERU, POD IMENOM**

:arrow_right: *instaclone-fb-key.json*

*TAK ODA **NE MORAS OPET GENERISATI TAJ FAJL** (ALI AKO GA GENERISES NISTA NISI POGRESIO, I TVOJ PROJEKAT CE IMATI OPET DODATNI SET CREDENTIAL INFORMACIJA (TOKENA I OSTALIH STVARI))*

## STA SE TU MOZE ZAKLJUCITI: PA KADA IMAS FIREBASE PROJEKAT, ON JE KREIRAN KROZ 'GOOGLE CLOUD INFRASTRUKTURU', JER KAD ODES NA GOOGLE DEVELOPER CONSOLE, SVE PROJEKTE, KOJE SI KREIRAO KROZ FIREBASE, MOZES NACI I TAMO U GOOGLE DEVELOPER KONZOLI, KOJA IMA SJAJNE MOGUCNOSTI

[OVAJ CLANAK IMA DOSTA DOBRIH INFORMACIJA O TOME](https://medium.com/google-developers/whats-the-relationship-between-firebase-and-google-cloud-57e268a7ff6f)

PA RECIMO TAMO GDE SAM ZA MOJ PROJEKAT MOGAO [PODESAVATI CREDENTIALS]; TAM OJE USTVARI CELA KONZOLA GOOGLE OPCIJA KOJE MOGU PODESAVATI

NA PRIMER U [GOOGLE DEVELOPER KONZOLI](https://console.developers.google.com/apis) **MOGU SEARCH-OVATI GOOGLE API-EVE I SERVISE, KOJE ONDA MOGU ENABLE-OVATI ZA MOJ APP**

**SECAS SE DA SI NA TOM MESTU ENABLE-OVAO I [OAuth](https://github.com/Rade58/apis_trying_out_and_practicing/blob/master/FIREBASE%20AND%20AWS/FIREBASE%20I%20REACT%20%28KROZ%20PROJEKAT%29/PROJEKAT/I%29%20AUTHENTICATION/3.%20OAuth%20Sign%20In%20SA%20GOOGLE-OM.md#star2star2star2star2-uspeo-sam-da-popravim-gore-pomenuto-tako-sto-sam-upload-ovao-logo-u-oauth-consent-screen-tab-u-localhost-nije-bio-problem-star2star2star2star2)**

## MISLIM DA SAM JA U OVOM PROJEKTU, PRE NEGO STO SAM SE DOVOLJNO DOBRO UPOZNAO SA FIREBASE-OM, UPRAVO KORISTIO FIREBASE NA STARI NACIN, A ONO STO NISAM URADIO JESTE INICIJALIZACIJA FIREBASE APP-A DIREKTNO U MOM PROJEKTU, CIME 'POVEZUJEM' MOJ APP SA FIREBASE-OM; STO MI OMOGUCAVA LAKSE KORISCENJE FIREBASE FEATURE-A U MOM APP, I LAKSE HANDLE-OVANJE NETWORK REQUEST-OVA U CLOUD FUNKCIJAMA, KOJE STIZU IZ MOG APP

KADA REGISTRUJEM MOJ APP KAO FIREBASE APP, NA PLATFORMI TO MI OLAKSAVA POSAO, JER SE NE MORAM BAVITI DODATNIM PROBLEMIMA

TO JE NAIME 'TWO WAY STREET' STO SE TICE CLOUD FUNKCIJA

IDEM U FIREBASE KONZOLU I BIRAM SETTING-SE (MALI ZUPCANIK)

ODATLE MOGU REGISTROVATI MOJ APP KAO FIREBASE WEB APLIKACIJU (MOGUCE SU OPCIJE I ZA NATIVE APP ITD)

U SUSTINI SVE MI JE PROVIDED

A TO STO JE PROVIDED POTREBNO JE EMBED-OVATI U MOJ PAGE

DAKLE KOPIRAM SLEDECE STVARI U MOJ PAGE, PRI DNU body ELEMENTA, PRE NEGO SE U BILO KOJIM SCRIPT-OVIMA MOJE APLIKACIJE, BUDE KOORISTIO FIREBASE

```HTML
<!-- The core Firebase JS SDK is always required and must be listed first -->
<script src="https://www.gstatic.com/firebasejs/6.3.5/firebase-app.js"></script>

<!-- KADA MOJ APP CODE-IRAM UZ POMOC BUNDLER-A KAO STO JE WEBPACK, JASNO JE DA 
CU PREDHODNI SCRIPT UVOZITI KAO MODUL, ALI TO SAM OBJASNIO VEC U DRUGOM PROJEKTU
ZNAS VEC KOJEM -->

<!-- TODO: Add SDKs for Firebase products that you want to use
     https://firebase.google.com/docs/web/setup#config-web-app -->

<script>
  // Your web app's Firebase configuration
  var firebaseConfig = {                                // OVDE SU BILE INFORMCIJE
                                                        // ALI NECU IH PRIKAZATI
                                                        // IAKO TO NISTA I NE ZNACI
                                                        // SMEJU DA BUDU PUBLIC

                                                        // ALI IPAK NAJBOLJE JE KADA KORISTIM NEKI 
                                                        // BUILD SISTEM KAO STO JE WEBPACK
                                                        // DA OVU KONFIGURACIJU UVEZEM KAO JSON
    apiKey: "AIzaSyB76KSNqmgZIJrzSd9QQis-ls",
    authDomain: "instapwBLAH.firebap.com",
    databaseURL: "https://instaBLAHne.firebaseio.com",
    projectId: "insta-pwa-clone",
    storageBucket: "insta-pwa-clone.appspot.com",
    messagingSenderId: "693903166",
    appId: "1:69379966:web:733c23ca6bdba"
  };
  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
</script>

<!-- OVDE SU MOJI OSTAL ISCRIPT-OVI IZ MOG PROJEKTA, A NEKI OD NJIH KORISTE FIREBASE -->
<!-- USTVARI SAMO SALJU REQUEST-OVE DO ENDPOINTA, ODNOSNO DO CLOUD FUNKCIJA -->
<!-- A IMA I SLUCAJEVA, KADA SE DIREKTNO SALJE DATA U REALTIME DATABASE -->

<script src="/src/js/material.min.js"></script>
<script src="/src/js/idb.js"></script>
<script src="/src/js/utility.js"></script>
<script src="/src/js/feed.js"></script>
<script src="/src/js/app.js"></script>

<!-- KRAJ body TAGA -->

```

## SADA ONO STO BI TREBALO DA BUDE LAKSE NA STRANI CLOUD FUNKCIJA, JESTE LAKSE HANDLE-OVANJE NEKIH REQUEST-OVA, KONKRETNO MISLIM DA NE MORAM KORISTITI @google-cloud/storage PAKET, UOPSTE, JER ON JE VEC PROVIDED KROZ FIREBASE; ALI TO NIJE ISTI API, ODNOSNO POSTOJE RAZLIKE KOJE SE TICU KONKRETNOG STAVLJANJA PODATKAKA U BUCKET, @google-cloud/storage NUDI VISE MOGUCNOSTI, KONKRETN OTU JE JEDNA KOJA MI NIJE OMOGUCENA KROZ firebase.storage, A MOGU JE KORISTITI KROZ @google-cloud/storage

ALI UZ TO @google-cloud/storage JE KOMPLIKOVANIJI

KONKRETNO STO SE TICE firebase.storage (**VEC JE IMPLEMENTIRANO GENERISANJE I UPOTREBA uuid TOKENA, KOJI SE KORISTE PRI UPLOAD-U I DOWNLOAD-U**)

**MORAO BI KORISTITI NEKE DOWNLOAD TOKENE** (*uuid*)

E PA TO SE SADA OBAVLJA IZA KULISA (KORISCENJEM POMENUTIH config INFORMACIJA) (MISLIM DA SAM TO NAPOMENUO I U DRUGOM PROJEKTU)

**NARAVNO POTREBNO JE INICJALIZOVATI APP I U functions/index.js FAJLU, ALI TO JE ZNATNO JEDNOSTAVNIJE** 

## STO SE TICE INICIJALIZACIJE APP, NA STRANI CLOUD FUNKCIJA, I TO SE ISTO TREBA URADITI; I TU POSTOJI TEZI NACIN (VISE MANUELAN); A I DRUGI 'FIREBASE NACIN', JER JE I TO FIREBASE OLAKSAO

```javascript
// EVO GA MANUELNI NACIN

// (1) UVEZEM ONAJ FAJL O KOJEM SAM VEC GOVORIO         instaclone-fb-key.json

// (2) KOPIRAM SVE PROPERTIJE IZ ONOG, GORE POMENUTOG firebaseConfig OBJEKTA, KOJEG SAM KORISTIO
//      ZA INICIJALIZACIJU NA CLIENT STRANI

// I SA TIME INICIJALIZUJEM APP

const serviceAccount = require('./instaclone-fb-key.json');

admin.initializeApp({
    credential: serviceAccount,
    //
    apiKey: "AIzaSyB76KSNqmgZIJrzSd9QQis-ls",
    authDomain: "instapwBLAH.firebap.com",
    databaseURL: "https://instaBLAHne.firebaseio.com",
    projectId: "insta-pwa-clone",
    storageBucket: "insta-pwa-clone.appspot.com",
    messagingSenderId: "693903166",
    appId: "1:69379966:web:733c23ca6bdba"
})

```

OVO BI BIO ONAJ **JEDNOSTAVNI NACIN, PO KOJEM CE firebase INICIJALIZOVATI APP, SA POMENUTIM STVARIMA, STO CE SE OBAVITI UNDER THE HOOD**

```javascript
admin.initializeApp(functions.config().firebase);
```

*KAO STO VIDIM, ZNATNO MANJE CODE-A*

## CORS PROBLEM VEZAN ZA HTTP REQUESTS

TI SI NAUCIO KAKO DA KORISTIS CLOUD FUNKCIJE NA SLEDECE NACINE

- [onCall](https://github.com/Rade58/apis_trying_out_and_practicing/blob/master/FIREBASE%20AND%20AWS/FIREBASE%20I%20REACT%20%28KROZ%20PROJEKAT%29/PROJEKAT/VIIII%29%20CLOUD%20FUNCTIONS/!!!!%20CORS%20PROBLEM.md#ovde-cu-uggrabiti-priliku-da-upotrebim-jedan-noviji-firebase-ov-cloud-functions-api) (ON ZAHTEVA DA UVEZEM firebase.functions NA CLIENT STRANI I DA KORISTIM API ZA SLANJE REQUEST-OVA, (DAKLE TU SE NE KORISTI fetch-API)) (*VOLIM OVO ZBOG JEDNOSTAVNOSTI*)

- onWrite (OnCreate, onUpdate, onDelete) SE INVOCIRAJU, KADA SE DESI PROMENA U FIRESTORE-U

ALI IMAO SI PROBLEMA ZA **onRequest** I SA [Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin)

JER SI TADA SLAO REQUEST-OVE SA RAZLICITIH ORIGIN-A (TVOJE CLOUD FUNKCIJE SU DEPLOYED NA JEDNOM URL-U, A TVOJ APP JE DEPLOYED NA DRUGOM)

MEDJUTIM  I ZA TO POSTOJI **RESENJE** A **NE ZAHTEVA KORISCENJE THIRD PARTY PAKETA, KAO STO JE [cors](https://www.npmjs.com/package/cors)**

U OSTALOM MENI cors PAKET UOPSTE NIJE FUNKCIONISAO, NE ZNAM ZASTO (MOZDA SAM POMISLIO DA SAMO NE FUNKCIONISE, ZBOG MOG LOSEG CODE-A (JEDINO ZNAM DA SAM GA JEDNOM KORISTIO, BEZ PROBLEMAM, A NAKON NEKOG VREMENA NIJE FUNKCIONISAO))

## RESENJE CORS PROBLEMA, KOJE SE OGLEDA U TOME DA SE SAM OTREBA DEFINISATI PAR OPCIJA, U FAJLU firebase.json; I POTPUNE PROMENE URL ZA KOJ ISALJEM REQUEST

DA POKAZEM TO PREKO PRIMERA

IMAM JEDNU CLOUD FUNKCIJU

```javascript
exports.testFunction = functions.https.onRequest((request, response) => {

    response.status(200).send({podatak: "podatak neki"})

})
```

POKUSACU DA POSALJEM HTTP REQUEST

ZA KOJI ENDPOINT, ODNOSNO NA KOJI URL?

PA NA SLEDECI URL:

**TAMO GDE SU DEPLOYED MOJE FUNKCIJE (TAJ URL NALAZIM U Fuctions TABU FIREBASE KONZLE)**

*PLUS* KROZ(**/**) *PLUS*

**IME MOJE FUNKCIJE (`testFunction`)**

```javascript
// LUPIO SAM OVAKAV URL:           'https://firebase-functions-blah.net'


fetch('https://firebase-functions-blah.net/testFunction')
.then((resp => { console.log(resp.json()) }))

// OVO SALJEM SA CLENT MESTA, ODNOSNO MESTA ODAKLE JE DEPLOYED MOJ APP (DAKLE URL MOJE APLIKACIJE)
// NA PRIMER 'https://moja_aplikacija.com'
```

ONO STO CU DOBITI JESTE ERROR STATUS 500

:x::x::x::x:*No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin '…' is therefore not allowed access...*:x::x::x::x:

I NAPOMINJE ME DA MOGU KORISTI, **mode: *'no-cors'*** DA BI DOBIO **OPAQUE** RESPONSE

:page_with_curl::page_with_curl::page_with_curl::page_with_curl: **RESENJE SE DAKLE OGLEDA U SAMOM DEFINISANJU, NOVIH OPCIJA ZA *firebase.json* FAJLA, I SLANJA REQUESTA NA URL, KOJ IBI SE SASTOJAO OD SLEDECEG** :page_with_curl::page_with_curl::page_with_curl::page_with_curl:

- `URL GDE JE MOJ APP DEPLOYED` **+** `/` **+** `IME FUNKCIJE`

:one: REDEFINISEM *firebase.json* TAK OSTO U **"hosting"** OBJEKTU, U NJEGOVOM **"rewrites"** NIZU, DODAM NOVOG CLANA, A TO JE OBJEKAT SA PROPERTIJIMA *"source"* I *"function"*

- ZA "source" ZADAJEM PATH ZA FUNKCIJU, NA PRIMER OVAKO: **"/testFunction"**

- ZA "function" ZADAJEM IME FUNKCIJE, NA PRIMER OVAKO: **"testFunction"**

```javascript
// firebase.json FAJL

{
  "functions": {
    "predeploy": [
      "npm --prefix \"$RESOURCE_DIR\" run lint"
    ]
  },
  "hosting": {
    "public": "public",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [ {    // OVDE DAKLE
      "source": "/testFunction",
      "function": "testFunction"
    }]
  }
}

```

:two: SADA REQUEST SALJEM NA URL KOJI SE SASSTOJI OD PAGE GDE JE DEPLOYED MOJ APP I IMENA CLOUD FUNKCIJE

OVAKO

```javascript
// MOJ APP JE DEPLOYED NA       'https://moja_aplikacija.com'

// IME FUNKCIJE JESTE           testFunction


fetch('https://moja_aplikacija.com/testFunction')   // VIDIS PROMENJENI URL
.then((resp => { console.log(resp.json()) }))

```

**SADA CE ZAHTEV BITI USPESAN I U KONZOLI CE BITI STAMPANO**    `{podatak: "podatak neki"}`

## POCECU OD POCETKA, NAIME REDEFINISACU CEO functions/index.js FAJL, JER ZELIM DA UVEZEM TACNO ONE STVARI, KOJE CU KORISTITI, ZATIM CU SVE DEFINISATI I U SKLADU SA MODERNOM SINTAKSOM (ZELIM DA KORISTIM ES6, ZA MOJE FUNKCIJE) (STO SE TICE MODULA, KORISTICU CommonJs SINTAKSU, JER JE PODRAZANA, A DA NE RIZIKUJEM SA ESM MODULIMA)

>>> KADA DEPLOY-UJEM FUNKCIJE A NE KORISTIM MODERNU SINTAKSU, FIREBASE MI POKAZUJE WARNING-E (ALI NE ZATO STO KORISTIM CommonJs MODULE, VEC ZATO STO NE KORISTIM ARROW FUNKCIJE I ZATO STO MOZDA EMBED-UJEM JEDAN PROMISE U DRUGI, UMESTO DA VRSI MCHAINING)
>>> PROVERI TAKODJE DA LI JE Node.js 8 I VISE U UPOTREBI ZA TVOJ PROJEKAT
>>> AKO NIJE UPDATE-UJ, ONAKO KAKO SAM TO POKAZAO U DRUGOM PROJEKTU, JER UPRAVO TO OMOGUCUJE DA MOGU KORISTITI MODERNU SINTAKSU JAVASCRIPT-A

**MEDJUTIM HAJDE DA PRVO URADIM INSTALIRANJE I UPDAT-OVANJE, NEKIH PAKETA**

**URADICU TO PRETEZNO U MOM functions/package.json FAJLU**

PRVI PAKETI KOJE ZELIM DA INSTALIRAM SU

- firebase-admin

- firebase-functions

**U REACT PROJEKTU, OVE PAKETE SAM KORISTIO I NA CLIENT-U I NA SERVER-U** (ZATO ZELIM DA IH INSTALIRAM IZA package.json, ALI I ZA functions/package.json)

TAKODJE OVE PAKETE BI TREBAL ODA IMAM GLOBALNO (NE ZNAM ZASTO, ALI ZA SADA IH NECU INSTALIRATI GLOBALNO JER IH VEC IMAM), A UVEK ZELI MDA IH INSTALIRAM NA LATEST VERZIJU

DAKLE INSTALIRAM IH LOKALNO, NA OBA POMENUTA MESTA

I ON OSTO ZELIM JESU LATEST VERZIJE

- npm install firebase-functions@latest firebase-admin@latest --save

(DAKLE POTRENE INSTALACIJE NA DVA MESTA, AKO ZELIM DA KORISTIM TE PAKETE LOKALNO ALI I ZA CLOUD-U (FUNCTIONS))

**TAKODJE CU U functions INSTALIRATI I [busboy](https://www.npmjs.com/package/busboy) PAKET**

- npm install --save busboy

**formidable MOZES UKLONITI**

- npm uninstall formidable --save

**PAKETE fs, os, path DOLAZE SA Node-OM, I NJIH SAMO UVOZIM**

**MOZES DA UKLONIS cors PAKET (functions FOLDER) (`npm uninstall --save cors`)** (NECE TI TREBATI, KAO STO SAM REKAO)

OD RANIJE SI IMAO I PAKETE:

- web-push (ON OSTAJE)

- uuid-v4 (uuid-v4 PAKET NIGDE NIJE REGITROVAN (NECU GA UKLANJATI NITI UPDATE-OVATI) (ALI NECU GA NI KORISTITI) (TO JE PAKET ZA GENERISANJE TOKENA ZA UPLOAD I DOWNLOAD (NE MESAJ IH SA VAPID KLJUCEVIMA))

POSTOJE TAKODJE MNOGI DRUGI PAKETI ZA **uuid**

JA CU KORISTIT OVAJ:

- npm install **uuid** --save

KADA GA BUDES UVOZIO, KORISTI CETVRTU VERZIJU, OVAKO **require('uuid/v4')**

SADA DA KONACNO POCNEM SA REDEFINISANJEM

functions/index.js FAJL:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');
// dakle uveza osam dva pomenuta paketa

// SADA MOGU INICIJALIZOVATI APP I NA CLOUD STRANI, BAS KAO STO SAM OBECAO
admin.initializeApp(functions.config().firebase)

// !!!! OVDE SAM INICIJALIZOVAO KORISCENJE firebase.storage-A (SAM ODA SE PODSETIM KAKO TO IDE)
const storage = admin.storage();   // !!!! IAKO GA JA USTVARI NECU KORISTITI, IZ GORE OBJASNJENIH RAZLOGA

// INSTALIRAO SAM RANIJE busboy (UKLONIO SAM formidable, ON MI NAIME NECE TREBATI)
// SAD UVOZIM busboy-A
const Busboy = require('busboy');

// TREBACE MI I PAKETI KOJI SU VEC NATIVNI ZA Node.js (NISAM IH TREBAO INSTALIRATI)
const file_system = require('fs')
const os = require('os');
const path = require('path');

const UUID = require('uuid/v4');        // UVOZIM PAKET ZA GENERISANJE UPLOAD/DOWNLOAD TOKENA

// OVO SU PAKETI KOJI SU NEOPHODNI ZA PUSH, AL ITO SAM OBJASNJAVAO RANIJE
// ****************************************************************************
const webpush = require('web-push');

// TU SU I VAPID KLJUCEVI
const privateVapidKey = "oC8DBLahIEEzbmom6BtrF6z7_rVY";
const publicVapidKey = "BMfwPHbn5_YXc0wZZu5xEIIhs40w8CDWGnf2HSq-v-vS_m122gcDWDRgFzvr";
// NARAVNO KLUCEVI NISU PRAVI, JER NECU DA IH PRIKAZUJEM U md FAJLOVIMA 
// *******************************************************************************
// OVDE CU STATI SA DEFINISANJEM CODE CLOUD FUNKCIJA, JER ZELIM DA DEFINISEM SECURITY RULES ZA STORAGE
```

## DEFINISANJE SECURITY PRAVILA SA STORAGE

EVO KAKVA PRAVILA ZELIM DA DEFINISEM:

```javascript
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    
    match /photos/{photoURL} {
        
        allow read;

        allow write;

    }
  
  }
}
```

DAKLE DOZVOLIO SAM READ I WRITE U SPECIFICIRANOM FOLDERU

**OBRATI PAZNJU DA SAM DEFINISAO PRAVILA ZA**

- photos FOLDER U, JEDINOM DEFAULT BUCKETU

- {photoURL} JE VARIJABLA I PREDSTAVLJA URL FAJLA (TACNIJE IME FAJLA U photos FOLDERU)

*TO IMAJ U VIDU JER CE TI TREBATI, KADA BUDES DEFINISAO UPLOAD FAJLA, JER ZELIS DA SLIKE IPAK STAVLJAS U SPECIFICAN FOLDER A NE DIREKTNO U BUCKET*

*BOLJE JE STAVLJATI U FOLDER BUCKETA, JER AKO BUDEM NA PRIMER U APLIKACIJI DODAVAO FAJLOVE, KOJI NISU SLIKE, ZASTO DA ONI BUDU NA ISTOM NIVO, ZASTO NE BI RAZLICITI TIPOVI FAJLOVA IMALI RAZLICITE FOLDERE U KOJE SU SMESTENI*

## STO SE TICE TVOJE CLOUD FUNKCIJE, ONA CE SE ZVATI storePostData; OMOGUCI CORS ZA NJU

firebase.json FAJL:

```javascript
{
  "functions": {
    "predeploy": [
      "npm --prefix \"$RESOURCE_DIR\" run lint"
    ]
  },
  "hosting": {
    "public": "public",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [ {
      "source": "/storePostData",   //      OMOGUCENO
      "function": "storePostData"   //
    },
    {       // NE OBRACAJ PAZNJU NA OVE DVE, IGRAO SAM SE NESTO PA SAM IH DODAO
      "source": "/testingPost",
      "function": "testingPost"
    }, 
    {
      "source": "/testGoogleStorage",
      "function": "testGoogleStorage"
    }]
  }
}

```

## STO SE TICE CLIENT SIDE CODE-A, JA SAM DEFINISAO DA SE PODACI SALJU KROZ indexedDB (OBJECT STORE 'sync-posts'); A IZ SERVICE WORKER-A, ON sync PODACI SE PROSLEDJUJU DO CLOUD FUNKCIJE; STO ZNACI DA SE 'POST' REQUEST OBAVLJA U OBIMU POMENUTOG ON sync HANDLER-A, GDE SE UZIMA DATA IZ OBJECT STORE-A, I PRAVI SE S NJIAM 'POST' REQUEST, ALI UZ KORISCENJE FormData INTERFACE-A

HAJDE DA OPET POGLEDAM CODE public/src/js/feed.js

ZELIM DA VIDIM CODE KOJI SE ODNOSI NA STAVLJANJE DATE U indexedDB U 'sync-posts' OBJECT STORE

I **NE ZABORAVI DA U SVAKOM POZIVANJU fetch, NJEGOV URL ARGUMENT ZAMENIS NOVIM, KOJI CE SE SASTOJATI OD**

- URL-A NA KOJEM JE DEPLOYED TVOJA APLIKACIJA

PLUS

- */imeCludFunkcije*  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (TO JE **/storePostData**)

****

**DIGRSIJA:**

JOS NESTO STO MISLI MDA JE BITNO:

- ONO STO SALJEM U BODY-JU REAUEST-A KA CLOUD-U JESTE **FormData** INSTANCA

- MISLIM DA BI BIL ODOBRO DA DODAM HEADERS ZA TO, MOZDA **busboy** LAKSE HANDLEUJE TAKAV REQUEST

**DEFAULT `"Content-Type"` HEADER, *'POST'* REQUEST-OVE JESTE**:

- *`"application/x-www-form-urlencoded"`*

JA SAM RANIJE SLAO JSON, PA SAM OVO BIO REDEFINISAO NA

- *`"application/json"`*

A ONO STO TI ZELIS, SADA USTVARI DA DEFINISES, JESTE

- *"multipart/form-data"*

ILI

- *'"raw"'* (NAIME, OVO CES TEK VIDETI NA KRAJU DALI CE TI TREBATI) (IGNORISI OVO I KORISTI 'multipart/form-data')

****

DA SADA KONACNO DEFINISEM SVE POMENUTE STVARI

feed.js FAJL:

```javascript
const sendData = function(){    // FALLBACK FUNKCIJA, KOJA SE POZIVA AKO BROWSER NE PODRZAVA BACKGROUND SYNC

    /* const dataObject = {
        id: new Date().toISOString(),
        title: titleInput.value,
        location: locationInput.value,
        image: 'https://firebasestorage.googleapis.com/v0/b/instapwaclone.appspot.com/o/burgers_food.jpeg?alt=media&token=001349ec-8c02-4c16-87df-9db24b252256'
    } */

    // POMENUTI OBJEKAT MI DAKLE VISE NIJE POTREBAN, JER CU UMESTO NJEGA KORISTITI FormData

    const postData = new FormData();   // INSTANTICIZIRAO SAM GA

    // APPENDUJEM MU PRVO SVE PODATKE IZ TEKSTUALNIH INPUT-A (NARAVNO I id)

    postData.append('id', new Date().toISOString());
    postData.append('title', titleInput.value);
    postData.append('location', locationInput.value);

    // A SADA APPEND-UJEM I Blob (SKALDISTI GA picture GLOBALBNA VARIJABLA, KAO STO JE POZNATO);

    // 1. ARGUMENT JE KLJUC, A KLJUC KOJI CE BITI NJEGOV (Blob-OV), U FORM DATA-U, NEKA SE ZOVE file, POSTO TAJ Blob REPREREZENTUJE FILE SLIKE
    // A MOGA OSAM ZADATI BILO KOJI KLJUC

    // 2. ARGUMENT, JESTE Blob INSTANCA naravno

    // 3. ARGUMENT JE IME KOJE ZELIM DA IMA, FAJL, KOJI POMENUTI BLOB REPREZENTUJE 

                // NEKA TO IME BUDE FORMIRANO OD ONIH PODATKAK KOJE SU FORMIARALI id

                // PLUS MIME TYPE FAJLA, KOJEG REPREZENTUJE Blob (OVO SE ODNOSI NA FORMAT SLIKE (jpg, jpeg, png..))

    postData.append(
        'file',
        picture,
        postData.get('id') + "." + picture.type.match(/^(image\/)([a-z]+)/)[2]
    )


    // fetch('https://us-central1-instapwaclone.cloudfunctions.net/storePostData', {   // RANIJE BILO OVO
                                                                                    // PROMENJEN OZBOG cors
    fetch('https://instapwaclone.firebaseapp.com/storePostData', {
        method: "POST",
        /* body: JSON.stringify(dataObject), */   // OVO DAKLE VISE NECU KORISTITI OVDE

        // U BODY-JU, TREBA DA BUDE         FormData        INSTANCA

        body: postData,

        /* headers: {                                // OVO HEADERS-I MI VISE NE TREBAJU
            "Content-Type": "application/json",      // JER NE SALJEM JSON STRING
            "Accept": "application/json"
        } */

        // DEFINISEM HEADERS, ZA FormData

        headers: {
            "Content-Type": "multipart/form-data",
        }

    })
    .then(resp => {
        console.log("Send Data: ", resp);
        // updateUI(dataObject)                // OVDE VIDIM GRESKU, JER UI UPDATE-UJEM PODACIMA, KOJIH VISE NEMA
                                         // REDEFINISACU OVO KASNIJE
        // PREDPOSTAVLJAM DA SE UI MOZE UPDAT-OVATI SA
        // PODACIMA OPET VRACENIM SA SERVERA, AKO JE REQUEST BIO USPESAN

        // DA NAPOMENEM DA JE AUTOR TUTORIJALA      POZVAO      updateUI    BEZ ARGUMENATA
        // (NIJE NI BITNO)
    }) 

    // ALI UPAMTI DA JE OVAJ FALLBACK DEFINISAN OVAKO, A CLOUD FUNCTION NIJE REDEFINISANA DA RECEIVE-UJE FormData

    // BAR NE JOS, ALI USKORO CU I TO DEFINISATI


};


const titleInput = document.querySelector('input#title');
const locationInput = document.querySelector('input#location');
const form = document.querySelector('div#create-post form');

form.addEventListener('submit', ev => {

    ev.preventDefault();


    if(titleInput.value.trim() === "" || locationInput.value.trim() === ""){
        alert("Please enter valid data!");

        return;
    }

    closeCreatingPostModal();   // RANIJE DEFINISANA FUNKCIJA U ISTOM FAJLU
                                // KADA SE SUBMITT-UJE FORMUALR, ODMAH SE SKALNJA MODAL NA KOJEM JE FORMULAR


    if('serviceWorker' in window.navigator && 'SyncManager' in window){    // AKO OVO NIJE ISPUNJENO, DOLE SE POZIVA
                                                                            // POMENUTI FALLBACK
        // OVDE CU POSLATI I SLIKU, ZAJEDNO SA OSTALIM PODACIMA

        navigator.serviceWorker.ready
        .then(swr => {

            // PODACI PUNE sync-posts OBJECT STORE, I TEK CE SE VADITI IZ SERVICE WORKER-A I TEK CE SE ONDA
            // NAKON INSTANTICIZIRANJA FormData INSTANCE, DEFINISATI KACENJE (TO JEST TO SAM VEC TAMO I DEFINISAO)
            // append METODOM, PODATKAK NA FormData INSTANCU, KOJA CE BITI POSLATA DO CLOUD FUNKCIJE (ENDPOINT-A)

            let post = {
                id: new Date().toISOString(),
                title: titleInput.value,
                location: locationInput.value,

                slika: picture    // DAKLE I blob INSATANCA SNAPSHOTA // (OVA INSTANCA JE RANIJE PROCITNAN SA CANVASA
                                  // KOJI JE CAPTURE-OVAO STREAM KAMERE)
                                  // BITI POSLATA U indexedDB
            }

                                // TO SAM URADIO ZBOG ONOG STO SAM VEC MNOGO PUTA OBJASNIO
                                // ALI RECI CU OPET
                                // ZELIM DA ISTATICIZIRAM       FormData    SA OVIM PODACIMA
                                // ALI U SERVICE WORKERU (ON sync HANDLER)

            writeData('sync-posts', post)

            .then(() => {

                // OVDE CU NAMERNO STAMPATI         picture
                // JER ZEIM DA SE POIGRAVAM, ODNOSNO DA ISPITUJEM POMENUTI Blob
                // U KONZOLI (MOGU DA GA NAINIM VREDNOSU temp VARIJABLE I TAK OSE POIGRAVAM)

                console.log("OVO JE BLOB SLIKE; IGRAJ SE S NJIM BLAH:", picture);

                return swr.sync.register('sync-new-post');
            })

            .then((syncRegistration) => {

                let snackbarContainer = document.querySelector('#confirmation-toast');
                let data = {message: "Your post was saved for synching!"};

                snackbarContainer.MaterialSnackbar.showSnackbar(data)

            })
            .catch(err => {
                console.log(
                    err, "STORING POST IN IndexedDb WAS UNSUCCESSFUL!, OR REGISTRATION OF SYNC TASK"
                );
            })

        })

    }else{

        sendData();         // KAO STO SAM REKAO POZIVA SE FALLBACK
    }

})
```

PRIKAZUJEM SAV BACKGROUND SYNC CODE SERVICE WORKERA, JER SE TAMO PODACI VADE IZ indexedDB-JA I PRAVI SE NETWORK REQUEST KA END POINT-U ('POST' REQUEST NARAVNO)

**NEMOJ I OVDE DA ZABORAVIS DA PROMENIS URL NETWORK REQUEST-A**

**I MORAS DA DEFINISSES POMENUTI HEADER**

public/sw.js FAJL:

```javascript
self.addEventListener('sync', function(ev){

    console.log('--+---+-- SyncEvent --+---+--+---+-   ', ev);

    if(ev.tag === 'sync-new-post'){  // NARAVNO, AKO JE TRIGGER-OVAN sync EVENT, RELATED SA POMENUTOM REGISTRACIJOM
                                     // MOGU OVAJ STRING NAZVATI I REGISTRATION TAG-OM, TU JE DOSTUPAN, DA BIH ZNAO
                                     // STA DA VADIM IZ indexedDB-JA (SVE OBJASNJENO RANIJE)

        ev.waitUntil(                       // SERVICE WORKER DAKLE CEKA DOK SE SLEDECE NE IZVRSI (SVE OBJASNJENO VEC)

            readAllData('sync-posts')      // CITAM ONE PODATKE, KOJI SU POTREBNI ZA SLANJE SERVER-U (OBJASNJENO RANIJE)

            .then(dataArray => {            // DAKLE POSTOJI MOGUCNOST DA JE VISE OBJEKATA UBACENO U OBJECT STORE       'sync-posts'
                                            // A JA OVDE SALJEM POST REQUEST, ZA SVAKI POJEDINACNI OBJEKAT IZ OBJECT STORE-A
                                            // JER SAM ACCESS-OVAO SVIM OBJEKTIMA IZ OBJECT STORE-A

                for(let data of dataArray){


                    // REKAO SAM RANIJE DA CU OVDE INSTATICIZIRATI I FormData INSTANCU, ALI JE NECU SLATI SERVERU

                    const postData = new FormData();   // INSTANTICIZIRAO SAM GA (USTVARI BICE INSTATICIZIRAN U SVAKOJ ITERACIJI)
                                                       // ZA SVAKI EXTRACTED OBJECT IZ OBJECT STORE-A

                    // SADA IZ ODREDJENOG OBJEKTA (ODNOSNO OBJEKTA TRENUTNE ITERACIJE), KOJE JE OBJECT, OBJECT STORE-A  sync-posts
                    // EXTAHUJEM PODATKE

                    // FormData-I , PRVO APPEND-UJEM SVE PODATKE IZ TEKSTUALNIH INPUT-A (NARAVNO I id)

                    postData.append('id', data.id);
                    postData.append('title', data.title);
                    postData.append('location', data.location);

                    // A SADA APPEND-UJEM I Blob

                    // 1. ARGUMENT JE KLJUC, A KLJUC KOJI CE BITI NJEGOV (Blob-OV), U FORM DATA-U, NEKA SE ZOVE file, POSTO TAJ Blob REPREREZENTUJE FILE SLIKE
                    // A MOGA OSAM ZADATI BILO KOJI KLJUC (MEDJUTIM, POSTO SAM 'file' ZDAO I U FALLBACK-U, ONDA TO RADIM I OVDE (NE SME BITI RAZLIKE))

                    // 2. ARGUMENT, JESTE Blob INSTANCA naravno

                    // 3. ARGUMENT JE IME KOJE ZELIM DA IMA, FAJL, KOJI POMENUTI BLOB REPREZENTUJE

                                // NEKA TO IME BUDE FORMIRANO OD ONIH PODATKAK KOJE SU FORMIARALI id

                                // PLUS MIME TYPE FAJLA, KOJEG REPREZENTUJE Blob (OVO SE ODNOSI NA FORMAT SLIKE (jpg, jpeg, png..))

                    postData.append(
                        'file',

                        data.slika,          // ~~~~~~  U SVAKOM OBJEKTU, IZ, POMENUTOG OBJECT STORE-A,
                                             //         Blob     JE STORED KAO U PROPERTIJU slika ~~~~~~
                                             // TO SMA OBJASNIO (URADIO) GORE U on submit HANDLERU (feed.js FAJL)

                        postData.get('id') + "." + data.slika.type.match(/^(image\/)([a-z]+)/)[2]
                    )

                    // ~~~~~~~~~~~~~~~~~~~ DAKLE NECU GORNJI OBJEKAT (postData) SLATI NA SERVER,
                    // ~~~~~~~~~~~~~~~~~~~ ALI CU GA STAMPATI DA VIDIM OD CEGA SE SASTOJI
                    // ~~~~~~~~~~~~~~~~~~~ ODNOSNO PRIMENJIVACU METODE FormData-INOG PROTOTIPA NA NJEMU
                    // ~~~~~~~~~~~~~~~~~~~ GET-OVACU IZ NJEGA Blob   MOJE CAPTURED SLIKE (SNAPSHOT-A), UZ POMOC KLJUCA     file
                    // ~~~~~~~~~~~~~~~~~~~ PA CU NAD Blob INSTANCOM PRIMENJIVATI NEKE METODE

                                            // SVE CE TO BITI MOGUCE U CHROME KONZOLI, ZATO STO U CHROME KONZOLI
                                            // JA MOGU DESNIM CLICK-OM IZABRATI DA SE ZELENI ODSTAMPANI OBJEKAT
                                            // STORE-UJE U TRENUTNOJ VARIJABLI

                    //-----------------------------------------------------------
                            // DAKLE STAMPAM        FormData        INSTANCU
                    // console.log(postData);

                    //

                    // STAMPACU GETTED      Blob        FROM FORM DATA
                    // console.log("-*-*-*-*-*-*-*", postData.get('file'), "-*-*-*-*-*-*-*-*-");

                    //-----------------------------------------------------------


                    // fetch('https://us-central1-instapwaclone.cloudfunctions.net/storePostData', {   // RANIJE BILO OVO
                                                                                    // PROMENJEN OZBOG cors
                    fetch('https://instapwaclone.firebaseapp.com/storePostData', {
                        method: "POST",
                        /* body: JSON.stringify({             // !!!! DAKLE OVO JE ONO STO CU MENJATI (ALI NE SADA, VEC TEK KAD DEFINISEM SERVER SIDE CODE)
                            id: data.id,                   // !!!! POSTO ZELIM DA PODATKE SALJEM KROZ FormData INSTANCA (DAKLE, ZELIM DA ONA BUDE U BODY-JU)
                            title: data.title,             // !!!! JA NE ZELIM STRINGIFIED OBJEKAT, KOJI JE SADA OVDE
                            location: data.location,       // !!!! ZAELI FormData INSTANCU, SA ONIM BLOB-OM, KAO SASTAVNIM DELOM

                                                           // ~~~~~~~  ALI JA CU OVO TEK MENJATI ONDA KADA BUDEM SREDIO SERVER SIDE CODE

                            image: 'https://firebasestorage.googleapis.com/v0/b/instapwaclone.appspot.com/o/burgers_food.jpeg?alt=media&token=001349ec-8c02-4c16-87df-9db24b252256'

                            // OVO JE BIO DUMMY IMAGE I ZATO JE OVO HARD CODED URL, KAKO GA NAZIVAJU
                        }),
                        headers: {
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        } */

                        body: postData

                        // HEADERSI

                         headers: {
                            "Content-Type": "multipart/form-data",
                        }



                    })
                    .then(resp => {
                        console.log("Send Data: ", resp);

                        if(resp.ok){

                            deleteItemFromData('sync-posts', data.id)     // KADA SU PODACI USPESNO POSLATI DO CLOUD FUNKCIJE,
                                                                          // ONI VISE NISU POTREBNI U indexedDB-JU  (OBJASNIO VEC RANIJE)
                        }


                    })
                    .catch(function(err){
                        console.log('Error, while sending data', err)
                    })

                }
            })
        );
    }
})
```

## :arrow_upper_right: MALO CU DA GOVORIM O MODULIMA os, fs I path, KOJE SAM UVEZAO U MOJ SERVER SIDE CODE

TI MODULI SU MODULI KOJI DOLAZE ZAJEDNO SA Node.js-OM

RECI CU NESTO O NJIMA I ZASTA CU IH UPOTREBLJAVATI U MOM PROJEKTU

:one: ['os'](https://nodejs.org/api/os.html#os_os) PAKET MOZE PRUZITI INFORMACIJE O OPERATIVNOM SISTEMU KOJI JE U UPOTREBI (MISLI SE NA OPERATIVNI SISTEM SERVERA, PREDPOSTAVLJAM)

[ako ne verujes pogledaj ovaj primer](https://www.w3schools.com/nodejs/shownodejs_cmd.asp?filename=demo_ref_os)

MENI IZ OVOG PAKETA ZANIMA MOGUCNOST DA PRISTUPIM INFORMACIJAM TEMPORARY STORAGE-A OPERATIVNOG SISTEMA

**UPRAVO KADA blob STIGNE DO SERVER-A, PREDPOSTAVLJAM DA JE NJEGOV RELATED FAJL, SMESTEN U TEMP DIREKTORIJUM**

E PA MOGU KORISTITI os PAKET, TACNIJE [os.tmpdir()](https://nodejs.org/api/os.html#os_os_tmpdir), KAKO BI PRISTUPIO TEMPORARY DIREKTORIJUMU

ZAPAMTI DA SE TAMO NALAZI TVOJ FAJL

**AKO ZNAS IME FAJLA I AKO SI PRISTUPIO, POMENUTOM DIREKTORIJUMU, MOZES INICIRATI UPLOAD FAJAL U WritableStream**

MISLIM DA CE MI OVO BITI JASNIJE, KADA VIDIM STA CE TO USTVARI URADITI, PRI KORISCENJU SA busboy

JER BUSBOY CE EXTRAHOVATI NEKE PODATKE O Blobu, KAO STO SU fieldname, file, filename, encoding, mimetype

**ALI MEDJU TIM PODACIMA NECE BITI INFO O TEMP DIREKTORIJUMU WINDOWS-A, U KOJEM JE MOJ FILE (IMAGE FILE)**

I UPRAVO ZBOG POMENUTE METODE OS JA CU ZNATI PATH TEMP DIREKTORIJUMA

:two: ['path'](https://nodejs.org/api/path.html#path_path) 

>>> The path module provides utilities for working with file and directory paths. It can be accessed using:

OVAJ MODUL IMA NOGO METODA A MENE ZANIMA TRENUTNO SAMO [join()](https://nodejs.org/api/path.html#path_path_join_paths) METODA

```javascript
path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');
// Returns: '/foo/bar/baz/asdf'
```

TI ZAKLJUCI CEMU SLUZI, PREDHODNA METODA

:three: 'fs' ODNOSNO [File System](https://nodejs.org/api/fs.html)

>>> The fs module provides an API for interacting with the file system in a manner closely modeled around standard POSIX functions (NE ZNAM STA JS [POSIX](https://www.php.net/manual/en/ref.posix.php))

PREDPOSTAVLJAM POSIX ZNACI: ' Process Control Functions'

OD OVOG PAKETA CU KORISTITI [createWriteStream()](https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options) FUNKCIJU

**IZ ONOGA STO SAM SAZNAO, SHVATIO SAM DA OVA FUNKCIJA PRAVI *WritableStream* INSTASNCU** (ONO STO JA ZNAM JESTE DA JE BODY, NEKOG REQUEST, UVEK ReadableStream)

NAIME U MOM SLUCAJU JA CU FUNKCIJI DODATI *PATH* **(SASTAVLJEN OD FOLDERA U TEMP FOLDERU SERVERA (GDE SE FAJL NALAZI, NAKON STIZANJA DO SERVERA), I IMENA FAJLA)**

I S TIM CU KREIRATI WritableStream INSTANCU

[WritableStream](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream) JE ABSTRAKCIJA ZA UPISIVANJE STREAMING PODATAKA U DESTINACIJU

PREDPOSTAVLJAM DA JE OVO FINAL COG U PROCESU UPLOADING-A: WRITING U WRITABLE STREAM, KOJI KASNIJE MOGU KORISTITI KAKO BI UPLOAD-OVAO FAJL NA ZELENO MESTO (FIREBASE STORAGE U MOM SLUCAJU)

KASNIJE SE NA SAMOM FAJLU, PRIMENJUJE pipe METODA;

>>>> Calling the [stream.pipe()](https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options) method to send the data to a Writable

ONA SE USTVARI PRIMENJUJE NA [ReadableStream](https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options)-U, KOJI CE MI BITI DOSTUPAN PRI KORISCENJU BUSBOY-A

## DA SE POZABAVIM @google-cloud/storage PAKETOM; OBRATI PAZNJU JER GA MOZES POGRESNO ISKORISTITI

STA MISLIM POD POGRESNO?

NA FIREBASE-OVOJ STRANICI JE U DOKUMENTACIJI OBJASNJENA UPOTREBA STARIJE VERZIJE OVOG PAKETA

functions/index.js FAJL:

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');

admin.initializeApp(functions.config().firebase)

const storage = admin.storage();
const Busboy = require('busboy');

const file_system = require('fs')
const os = require('os');
const path = require('path');

const UUID = require('uuid/v4');

// OVO SU PAKETI KOJI SU NEOPHODNI ZA PUSH, AL ITO SAM OBJASNJAVAO RANIJE
// ****************************************************************************
const webpush = require('web-push');

// TU SU I VAPID KLJUCEVI
const privateVapidKey = "oC8DBLahIEEzbmom6BtrF6z7_rVY";
const publicVapidKey = "BMfwPHbn5_YXc0wZZu5xEIIhs40w8CDWGnf2HSq-v-vS_m122gcDWDRgFzvr";
// NARAVNO KLUCEVI NISU PRAVI, JER NECU DA IH PRIKAZUJEM U md FAJLOVIMA 
// *******************************************************************************


// DA PRVO KREIRAM KONFIGURACIJSKI OBJEKAT, KOJI CU KORISTITI DA KONFIGURIRAM GOOGLE CLOUD STORAGE
// KAKO BI GA MOGAO KORISTITI U MOM PROJEKTU

// NAIME, U PITANJU JE CREDENTIAL, O KOJEM SAM GOVORIO PRI POCETKU OVOG md FAJLA

const gcsConfig = {keyFilename: '/instapwaclone-f5157fff88e9.json', projectId: 'instapwaclone'}

// SADA DA UVEZEM I KONFIGURIRAM GOOGLE-CLOUD STORAGE (ODNOSNO POZIVAM UVEZENU FUNKCIJU SA KONFIGURACIJSKIM OBJEKTOM)

//!!!!!!!!  // OBRATI PAZNJU DA JE OVO BILA STARIJA SINTAKSA, KOJA SE VISE NE KORISTI
// const gcs = require('@google-cloud/storage')(gcsConfig);
//!!!!!!!!

//  SADA SE KORISTI KONSTRUKTOR

const {Storage} = require('@google-cloud/storage');

const gcs = new Storage(gcsConfig);

```

## AKO ZELIS DA VIDIS KAK ODA UPOTREBLJAVAS GOOGLE CLOUD STORAGE-A, KONKRETNO KAK ODA UPLOAD-UJES MOZES OTICI NA SLEDECI LINK

[DOKUMENTACIJA](https://cloud.google.com/storage/docs/uploading-objects#storage-upload-object-code_sample) (POGLEDAJ CODE SAMPLES ZA NODE.JS)

A IMAS TO I U [github repo-u](https://github.com/googleapis/nodejs-storage/blob/master/samples/files.js)

**SAMO STO SE OVDE NE SPOMINJ TOKENI** (uuid)

1. MOGUCNOST JEDAN: ON ISU VEC IMPLEMENTED UNDER THE HOOD INSIDE API

2. NIKO NE OBRACA PAZNJU NA NJIH

**JA CU IPAK PROBATI TO DA URADIM NA 'MAKSIMILIJAN SHWARTMUHLER NACIN', GDE CU OBEZBEDITI uuid**

## :dash::dash::dash::dash: SADA MOGU ODPOCETI SA DEFINISANJEM UPLOADING-A FAJLA, A KADA SE TO OBAVI, SLEDI ZADAVANJA NJEGOVOG URL-A, I OSTALIH PODATKA KOJE SAM APPEND-OVAO NA FormData DA BUDU DEO JEDNOG POST-A, KOJEG CU DODATI U REALTIME DATABASE-U, U 'posts' OBJECT STORE :dash::dash::dash::dash:

SASVIM JE JASNO IZ CODE, MOG APP-A DA ONO STA SE SALJE CLOUD FUNKCIJI JESTE FormData INSTANCA

SADA TREBAM UPOTREBITI busboy PAKET KAKO BI HANDLE-OVAO TAJ DATA, A POSEBNO Blob INSTANCU, KOJU SALJEM EMBEDED INSIDE FormData INSTANCE

**NAIME TU Blob INSTANCU NE MOGU KORISTITI NA SERVER STRANI**

**ONO STA MOGU KORISTITI JESTE PATH FAJLA U TEMP FOLDERU CLOUD-OVOG OPERATIVNOG SISTEM-A (TAMO JE SMESTEN FAJL PO STIZANJU DO CLOUD FUNKCIJE)**

:point_right: PROBLEM: *FIREBASE storage API NE MOZE KORISTITI, POMENUTI PATH KAO ARGUMENT*

ODNOSNO **storage.Reference.put()** KAO ARGUMENTE MOZE IMATI SLEDECE TIPOVE VREDNOSTI

- Blob | Uint8Array | ArrayBuffer (ZA Base64 STRING NISAM SIGURAN)

- NIAKO **TO NE MOZE BITI PATH DO FAJLA U TEMP FOLDERU**, OPERATIVNOG SISTEMA CLOUD-A

**ZATO SAM INSTALIRAO @google-cloud/storage PAKET, U MOM functions FOLDERU**

- npm install '@google-cloud/storage'@latest --save (AKO SAM ZABORAVIO DA SADA ISNTALIRAM)

NARAVNO INSTALIRAO SAM LATEST VERZIJU, JER ZELIM DA KORISTIM MODERNI API

DA SADA KRENEM SA, DEFINISANJEM, ODNOSNO REDEFINISANJEM MOJE **storePostData** FUNKCIJE

functions/index.js FAJLU

```javascript
const functions = require('firebase-functions');
const admin = require('firebase-admin');

admin.initializeApp(functions.config().firebase)

const storage = admin.storage(); // NE KORISTIM ALI NEKA GA (DA UVEK STOJI KAO TESTEMONIAL)
                                 // DA SE MOZE KORISTITI I NA CLIENTU I NA SERVER-U
const Busboy = require('busboy');

const file_system = require('fs')
const os = require('os');
const path = require('path');

const UUID = require('uuid/v4');

// ****************************************************************************
const webpush = require('web-push');

const privateVapidKey = "oC8DBLahIEEzbmom6BtrF6z7_rVY";
const publicVapidKey = "BMfwPHbn5_YXc0wZZu5xEIIhs40w8CDWGnf2HSq-v-vS_m122gcDWDRgFzvr";
// *******************************************************************************

const gcsConfig = {keyFilename: '/instapwaclone-f5157fff88e9.json', projectId: 'instapwaclone'}
const {Storage} = require('@google-cloud/storage');
const gcs = new Storage(gcsConfig);


// DAKLE SADA KREIRAM ENDPOINT, ODNOSNO KREIRAM CLOUD FUNKCIJU storePostData

// PRE NEGO STO KRENES TRBA DA ZNAS DA ZELIS DA SLIKU UPLOAD-UJES OVDE:

//                          /photos/{photoURL}

// JER SAM ZA TO MESTO DOZVOLIO UPLOAD (KORISCENJEM SECURITY PRAVILA)

//
// A IME FOTOGRAFIJE, ODNOSNO VARIAJBLA U GORNJEM PATH-U, BICE FORMIRANA OD id-JA, KOJEG SALJEM SA FormData
// TO CU DEFINISATI PRI SAMOM UPLOAD-U
//
//**************************************************************************************************
//**************************************************************************************************

// KREIRAM FUNKCIJU FROM SCRATCH

exports.storePostData = functions.https.onRequest((request, response) => {

    // KREIRACU NOVI uuid KLUC
    const uuid = UUID() // OVO NIJE KONSTRUKTOR I ZATO NEMA new

    // NOVA INSTANCA Busboy-A

    const busboy = new Busboy({headers: request.headers})

    // !!!!!!!!!!!!!! OVO SAM  ODLUCIO DA NE KORISTIM!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // HAJDE DA UZMEM REFERENCU FOLDERA, U KOJI ZELIM DA STAVIM SLIKU, ODNONS GDE ZELIM DA JE UPLOAD-UJEM
    const folder = storage.ref('photos')   // JA SAM POKAZAO U JEDNOM DRUGOM PROJEKTU GDE SE OVDE
                                                // BILO VISE FOLDERA (ZA SVAKOG USERA APP-A PO JOS FOLDER)
                                                // TO MISLIM DA AKO POSMATRAJUCI ARGUMENT POMISLIM NESTO
                                                // DA JE NESTO DRUGO DODATO (DODAT JE PATH)
                                                // TO JE PATH DO FOLDERA U BUCKET-U
                                                // POSTOJI JEDAN JEDINI DEFAULT BUCKET
                                                // KAO STO SAMO POSTOJI JEDAN DEFAULT REALTIME DATABASE
                                                // ILI JEDAN DEFAULT FIRESTORE DATBASE
        // (POMENUTO SAM ODLUCIO DA KASNIJE I NE KORISTIM, JER KAO STO SAM REKAO VRSICU UPLOAD
        // PREKO GOOGLE-CLOUD STORAGE-A (JER MI POMENUTI FIREBASE-OV API NE DOZVOLJAVA, KORISCENJE
        // PATH-A DO FAJL U TEMP FOLDERU CLOUD-OVOG OPERATIVNOG SISTEMA-A (JER ON JE TAMO KADA STIGNE NA CLOUD))
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    // SLEDECA VARIJABLA TREBA DA SKLADISTI JEDAN OBJEKAT (ODNOSNO DA GA REFERENCIRA)
        // KASNIJE TOM OPBJEKTU CU DODATI
        //                              -    PATH DO TEMP FOLDERA, KORISNIKOVOG OPERATIVNOG SISTEMA

        //                              -    I MIME TYPE, FAJLA

    const upload = {tempFilePath: "", mimeType: ""};

        // SLEDECA VARIJABL, KOJU CU DEKLARISATI, TREBA DA 'PRIKUPI' SVE FIELDNAME-OVE, SA NJIHOVIM VREDNSOTIMA
        // TO JE ONO STO SAM DODAO KAO KEY VALUE PAROVE ZA FormData (POTICE OD TITLE-A I CONTENTA POST-A)

    const fields = {};

    // SADA REGISTRUJEM BUSBOY-OV EVENT HANDLER, U CIJEM OBIMU TREBAM DOBITI INFO O FAJLU, KOJI JE POSLAT,
        // KAO BLOB
        // CALLABCK JE INVOKATED ZA SVAKI FILE KOJI JE DETECTED

        // I ON ZAPOCINJE USTVARI SAVING

    busboy.on('file', (fieldName, fileStream, fileName, encoding, mimeType) => {

        // KREIRAM PRVO POTPUNI PATH FAJLA NA NJEGOVOM TEMP MESTU (U TEMP FOLDERU OPERATIVNOG SISTEMA SERVER-A)
        // ON JE NAIME STAVLJEN U TAJ DIREKTORIJUMU NAKON STIZANJA DO MOG CLOUD FUNCTIONA
        const tempFilePath = path.join(os.tmpdir(), fileName);

        // SADA ZADAJEM DA TEMPORARY PATH BUDE VREDNSOT, JEDNOG PROPERTIJA ONOG upload OBJEKTA
        // A DODAJEM I mimeType, TOM OBJEKTU
        
        upload.tempFilePath = tempFilePath;     // OVO JE MOGLO LEPSE UZ SKARACENU OBJECT SINTAKSU ES6
        upload.mimeType = mimeType;             // (TADA upload NE SME BITI KONSTANTA, A I NE MORA)
                                                // ALI NEKA SE SVE OVAKO LEPO VIDI

        // POTREBNO JE READBALE STREAM 'PIPE-OVATI' U WRITABLE STREAM ZA MOJ IAMGE
        
        fileStream.pipe(file_system.createWriteStream(tempFilePath));

        // OVDE MOGU STAMPATI I SVE ARGUMENTE (POKUSACU DA MOJ CLOUD FUNCTION RUNN-UJEM LOKALNO
        // MOZDA MI USPE PA SAM ONDA U MOGUCNOSTI DA SAGLEDA MSVE OVE ARGUMENTE, OD CEGA SE SASTOJE)
        console.log({fieldName, fileStream, fileName, encoding, mimeType})

    })

    // DAKLE U PREDHODNOM CALLBACK-U DEFINISAO SAM UPISIVANJE FAJLA U WRITABLE STREAM

     
    // SLEDECI CALLBACK, KOJI ZELIM DA REGISTRUJEM, TREBALO BI DA SE INVOCIRA NA SVAKI DETECTION
        // FIELD-A EXTRACTED IZ FormData-E

    busboy.on('field', (fieldName, value, fieldNameTruncated, valTruncated, encoding, mimeType) => {
        // fieldNameTruncated PARAMETAR (BOOLEAN) (TO ZNACI SKRACNO IME FIELD-A) (CISTO OBJASNAJVAM, A NE KORISTIM TO)

        // PRI SVAKOJ ENVOKACIJI, ODNOSNO PRI SVAKOJ DETEKCIJI FIELD-A
        // FIELD I NJEGOVA VREDNOST, TRBALI BI DA POSTANU KEY VALUE PAR
        // fields OBJEKTA, KOJI SAM DEKLARISAO IZVAN OVOG HANDLERA, GORE

        fields[fieldName] = value;

    })

    // SECAS SE DA SI INICIRAO WRITING TVOG FAJLA U WRITABLE STREAM
        // U SLEDECEM CALLBACK-U, ODNOSNO HANDLERU, KOJI CE SE INVOCIRATI, ONDA KADA
        // SE FAJL BUDE POTPUNO UPISAO U WRITABLE STREAM
        // JA MOGU ISKORISTITI, TAJ WRITABLE STREAM KAKO BI UPLOAD-OVAO FAJL

    busboy.on('finish', () => {
        // !!!!
        // DAKLE, KAO STO SAM REKAO, KADA SE ZAVRSI UCITAVANJE DATA-E
        // IMAGE-A IZ READABLE STREAMA REQUEST-A,
        // U NOVI WRITABLE STREAM, KREIRAN U DRUGOM CALLBACK-U
        // OVAJ CALLBACK SE INVOCIRA

        // PREDPOSTAVLJAM DA SE CEKA DA SE ZAVRSI I GORNJE CITANJE FIELD-OVA
        // ,PA SE ONDA TRIGGER-UJE OVAJ CALLBACK
        // !!!!

        // SADA MOGU DA DEFINISEM UPLOAD, TAK OSTO CU
        // IZMEDJU OSTALOG NAVESTI, GDE SE FAJLA SADA NALAZI
        // (TO RADIM U OKVIRU GOOGLE CLOUD STORAGE API-A)

        // PRISTUPICU MOM FIREBASE DEAFULT BUCKETU (DEFAULT BUCKET ZA MOJ PROJEKAT)
        // ALI TO RADIM KAO STO REKOH PREKO GOOGLE CLOUD API-A

        const bucket = gcs.bucket('gs://instapwaclone.appspot.com'); // KAO ARGUMENT SAM DODAO URL MOG BUCKETA
                                        // STO MOGU NACI U Storage SKCIJI FIREBASE KONZOLE
                                        // ALI IMAM GA I GORE U CODE-U
        // OBRATI PAZNJU DA MORA PUN URL (JEDNO MSAM ZABORAVIO GORE PRIKAZANO gs://)

        // SADA DEFINISEM UPLOAD
        // OD ARGUMENTA CU KORITITI;

        //                                          -     PATH FAJLA GDE SE ON NALAZI U TEMP FOLDERU CLOUD-OVOG OS-A
        //
        //                                          -     ZATIM OBJEKAT, U KOJEM CU IZMEDJU OSTALOG
        //                                                  DEFINISATI NOVO IME FAJLA, ALI I METADATA
        //                                                  U OKVIRU TOG OBJEKTA DODAJEM I uuid

        //                                          -     CALLBACK KOJI SE IZVRSAVA AKO JE
        //                                                  FILE USPESNO UPLOADED ILI NIJE
        
        // HAJDE DA PRVO KREIRAM OPTIONS OBJEKAT

        const uploadOptions = {
            // destination: `photos/${fields.id}.${upload.mimeType}`, // SECAS SE DA SI SECURITY PRAVILA DEFINISAO
                                        // TAKO DA DOZVOLJAVAS WRITE I READ FAJLA SAMO U
                                        // photos FOLDERU TOVOG BUCKET-A
                                        // MISLIM DA SE OVO NE PODESAVA VISE U OKVIRU OVOG OBJEKTA

            uploadType: 'media',
            metadata:{
                metadata: {
                    contentType: upload.mimeType,
                    firebaseStorageDownloadTokens: uuid       
                }
            }
        }
        
        // SADA UPLOAD-UJEM

        bucket.upload(
            upload.tempFilePath,     // OVO JE PATH FAJLA GDE JE ON SADA
            
            uploadOptions,

            async (error, uploadedFile) => {   // CALLBACK KOJI SE IZVRSAVA, NAKON USPESNOG ILI NEUSPESNOG DOWNLOAD-A
                                            // I DEFINISAO SAM DA TO BUDE async FUNKCIJA
                                            // MISLIM DA CU LAKSE S NJOM SVE DEFINISATI
                if(error){
                    
                    console.log(error)
                    // return `Error: ${error} FAJL NIJE UPLOADED`;

                }else{

                    // UZIMAM REFERENCU, MOG OBJECT STORE-A 'posts' U REALTIME DATBASE-U
                    const postsRef = database.ref('posts')

                    // !!!!!!!!!!!!!!!!!!!!!!!!    OVO JE VAZNO   !!!!!!!!!!!!!!!!!!!!!!
                    // TVOJE IME SLIKE JE FORMIRANO OD          id-JA       POST-A
                    // TVOJE IME POST-A JE FORMIRANO OD         new Date().toISOString()
                    // 
                            //          OVO ZNACI DA SE SPECIJALNI KARAKTERI MOGU NACI
                            //          U IMENU FAJLA

                            // KADA BUDES IME FAJLA KORISTIO U URL-U
                            // MORACES ENCODE-OVATI TE SPECIJALNE KARAKTERE


                            // SECAS SE KADA SI NA GITHUBU ZADAVAO URL-OVE, SA SPECIJALNIM
                            // KARAKTETRIMA, KAO STO SU ZAGRADE ( , SECAS SE DA NISI MOGAO
                            // KORISTIURL SA SPECIJALNIM KARAKTERIMA, DOK NISI DEFINSIAO ENCODING
                            // ZAGRADA U URL-U, JE MORALA BITI '%24' I SLICNO

                            // E PA TAKAV id, ODNOSNO IME FAJLA JE POTREBNO ENCODE-OVATI JEDNOM FUNKCIJOM
                            //      encodeURIComponent()

                            // TA FUNKCIJA SE MOZE KORISTITI ODMAH U Node.js-U

                    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                    // SADA STAVLJAM SVE PODATKE U DATABASE, U POMENUTI OBJECT STORE

                    await postsRef.push(        // SADA KORISTIM SVE POMENUTE EXTRAHOVANE FIELD-OVE
                                                // I NJIHOVE VREDNOSTI
                                                // A UPLOADED FAJL MI JE DOSTUPAN DA SA NJEGA CITAM
                                                // NJEGOO IME
                        {
                            id: fields.id,
                            title: fields.title,
                            location: fields.location,
                            // IMAGE URL MORAM FORMIRATI OD 'PARCIJALNIH' INFORMACIJA
                            // DA SAM NA PRIMER KORISTIO admin.storage()
                            image: 'https://firebasestorage.googleapis.com/v0/b/' + 
                                    bucket.name +
                                    '/o/' + encodeURIComponent(uploadedFile) +
                                    "?alt=media&token=" + uuid
                            // DAKEL NA KRAJU KORISTIM uuid KOJI SAM KORISTIO, PRI UPLAOD-U
                            // TAKODJE, KAK OBI FORMIRAO OSTATAK URL-A

                        }
                    )

                    // ODAVDE BI ISAO CODE KOJI JE REZERVISAN ZA PUSH (PODESAVANJE VAPID KLJUCEVA ITD)
                    // ALI TO CU DEFINISATI, TEK KADA DEPLOY-UJEM MOJE CLOUD FUNKCIJE
                    // I VIDIM DA LI MOJ CODE FUNKCIONISE
                    
                    
                    // return "File is uploaded";

                }

            }
        )

    })

    busboy.end(request.rawBody);


})































//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************










exports.storePostData = functions.https.onRequest((request, response) => {

    // I POSTO KORISTIM cors (ODMAH CE GORNJI PARAMETRI BITI ARGUMENTI cors-A)

    cors(request, response, async () => {   // NEKA CALLBACK BUDE async FUNKCIJA

        const uuid = UUID();     // OVO CE MI IPAK BITI POTREBNO
        
        // INSTATICIZIRAM Busboy, SA HEADER-SIMA PRISTIGLIM SA REQUEST-OVIM HEADERS-IMA
        // NE BRINI SE PRAVI HEADDER JE POSLAT ZA FormData, IAKO NISAM SPECIFICIRAO
        // BROWSER GA OBEZBEDJUJE PO DEFAULTU 

        const busboy = new Busboy({headers: request.headers})

        // !!!!!!!!!!!!!! KASNIJE ODLUCIO DA NE KORISTIM!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // HAJDE DA UZMEM REFERENCU FOLDERA, U KOJI ZELIM DA STAVIM SLIKU, ODNONS GDE ZELI MDA JE UPLOAD-UJEM
        const folder = storage.ref('photos')   // JA SAM POKAZAO U JEDNOM DRUGOM PROJEKTU GDE SE OVDE
                                                // BILO VISE FOLDERA (ZA SVAKOG USERA PO JOS FOLDER)
                                                // TO MISLIM DA AKO POSMATRAJUCI ARGUMENT POMISLIM NESTO
                                                // DA JE NESTO DRUGO DODATO (DODAT JE PATH)
                                                // TO JE PATH DO FOLDERA U BUCKET-U
                                                // POSTOJI JEDAN JEDINI DEFAULT BUCKET
                                                // KAO STO SAMO POSTOJI JEDAN DEFAULT REALTIME DATABASE
                                                // ILI FIRESTORE
        // (POMENUTO SAM ODLUCIO DA KASNIJE I NE KORISTIM, JER KAO STO SAM REKAO VRSICU UPLOAD
        // PREKO GOOGLE-CLOUD STORAGE-A (JER MI POMENUTI FIREBASE-OVA API NE DOZVOLJAVA, KORISCENJE
        // PATH-A DO TEMP FAJL-A)
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    
        // SLEDECA VARIJABLA TREBA DA SKLADISTI JEDAN OBJEKAT (ODNOSNO DA GA REFERENCIRA)
        // KASNIJE TOM OPBJEKTU CU DODATI
        //                              -    PATH DO TEMP FOLDERA, KORISNIKOVOG OPERATIVNOG SISTEMA

        //                              -    I MIME TYPE, FAJLA

        const upload = {tempFilePath: "", mimeType: ""};

        // SLEDECA VARIJABL, KOJU CU DEKLARISATI, TREBA DA 'PRIKUPI' SVE FIELDNAME-OVE, SA NJIHOVIM VREDNSOTIMA
        // TO JE ONO STO SAM DODAO KAO KEY VALUE PAROVE ZA FormData (POTICE OD TITLE-A I CONTENTA POST-A)

        const fields = {};


        // SADA REGISTRUJEM BUSBOY-OV EVENT HANDLER, U CIJEM OBIMU TREBAM DOBITI INFO O FAJLU, KOJI JE POSLAT,
        // KAO BLOB
        // CALLABCK JE INVOKATED ZA SVAKI FILE KOJI JE DETECTED

        // I ON ZAPOCINJE USTVARI SAVING

        busboy.on('file', (fieldName, fileStream, fileName, encoding, mimeType) => {

            // KREIRAM PRVO POTPUNI PATH FAJLA NA NJEGOVOM TEMP MESTU (U FOLDERU OPERATIVNOG SISTEMA SERVER-A)
            // ON JE NAIME STAVLJEN U TAJ DIREKTORIJUMU NAKON STIZANJA DO MOG CLOUD FUNCTIONA
            const tempFilePath = path.join(os.tmpdir(), fileName);

            // SADA ZADAJEM DA TEMPORARY PATH BUDE VREDNSOT, JEDNOG PROPERTIJA ONOG upload OBJEKTA
            // A DODAJEM I mimeType, TOM OBJEKTU
            
            upload.tempFilePath = tempFilePath;     // OVO JE MOGLO LEPSE UZ SKARACENU OBJECT SINTAKSU ES6
            upload.mimeType = mimeType;             // (TADA upload NE SME BITI KONSTANTA, A I NE MORA)
                                                    // ALI NEKA SE SVE OVAKO LEPO VIDI

            // POTREBNO JE READBALE STREAM 'PIPE-OVATI' U WRITABLE STREAM ZA MOJ IAMGE
            
            fileStream.pipe(file_system.createWriteStream(tempFilePath));

            // OVDE MOGU STAMPATI I SVE ARGUMENTE (POKUSACU DA MOJ CLOUD FUNCTION RUNN-UJEM LOKALNO
            // MOZDA MI USPE PA SAM ONDA U MOGUCNOSTI DA SAGLEDA MSVE OVE ARGUMENTE, OD CEGA SE SASTOJE)
            console.log({fieldName, fileStream, fileName, encoding, mimeType})

        })

        // DAKLE IU PREDHODNOM CALLBACK-U DEFINISAO SAM UPISIVANJE FAJLA U WRITABLE STREAM


        // SLEDECI CALLBACK, KOJI ZELIM DA REGISTRUJEM, TREBALO BI DA SE INVOCIRA NA SVAKI DETECTION
        // FIELD-A EXTRACTED IZ FormData-E

        busboy.on('field', (fieldName, value, fieldNameTruncated, valTruncated, encoding, mimeType) => {
            // fieldNameTruncated PARAMETAR (BOOLEAN) (TO ZNACI SKRACNO IME FIELD-A)

            // PRI SVAKOJ ENVOKACIJI, ODNOSNO PRI SVAKOJ DETEKCIJI FIELD-A
            // FIELD I NJEGOVA VREDNOST, TRBALI BI DA POSTANU KEY VALUE PAR
            // fields OBJEKTA, KOJI SAM DEKLARISAO IZVAN OVOG HANDLERA, GORE

            fields[fieldName] = value;

        })

        // SECAS SE DA SI INICIRAO WRITING TVOG FAJLA U WRITABLE STREAM
        // U SLEDECEM CALLBACK-U, ODNOSNO HANDLERU, KOJI CE SE INVOCIRATI, ONDA KADA
        // SE FAJL BUDE POTPUNO UPISAO U WRITABLE STREAM
        // JA MOGU ISKORISTITI, TAJ WRITABLE STREAM KAKO BI UPLOAD-OVAO FAJL

        busboy.on('finish', () => {
            // DAKLE, KAO STO SAM REKAO, KADA SE ZAVRSI UPLOUD U TEMP FOLDER
            // PREDPOSTAVLJAM KADA SE ZAVRSI I GORNJE CITANJE FIELD-OVA

            // TREBA DA SE TRIGGER-UJE OVAJ CALLBACK

            // SADA MOGU DA DEFINISEM UPLOAD, TAK OSTO CU
            // IZMEDJU OSTALOG NAVESTI, GDE SE FAJLA SADA NALAZI
            // (TO RADIM U OKVIRU GOOGLE CLOUD STORAGE API-A)

            // PRISTUPICU MOM FIREBASE DEAFULT BUCKETU (DEFAULT BUCKET ZA MOJ PROJEKAT)
            // ALI TO RADIM KAO STO REKOH PREKO GOOGLE CLOUD API-A

            const bucket = gcs.bucket('instapwaclone.appspot.com'); // KAO ARGUMENT SAM DODAO URL MOG BUCKETA
                                            // STO MOGU NACI U Storage SKCIJI FIREBASE KONZOLE
                                            // ALI IMAM GA I GORE U CODE-U
            
            // SADA DEFINISEM UPLOAD
            // OD ARGUMENTA CU KORITITI;

            //                                          -     PATH FAJLA GDE SE ON NALAZI U TEMP FOLDERU
            //
            //                                          -     ZATIM OBJEKAT, U KOJEM CU IZMEDJU OSTALOG
            //                                                  DEFINISATI NOVO IME FAJLA, ALI I METADATA
            //                                                  U OKVIRU TOG OBJEKTA DODAJEM I uuid

            //                                          -     CALLBACK KOJI SE IZVRSAVA AKO JE
            //                                                  FILE USPESNO UPLOADED ILI NIJE
            
            // HAJDE DA PRVO KREIRAM OPTIONS OBJEKAT

            const uploadOptions = {
                destination: `photos/${fields.id}.${upload.mimeType}`, // SECAS SE DA SI SECURITY PRAVILA DEFINISAO
                                            // TAKO DA DOZVOLJAVAS WRITE I READ FAJLA SAMO U
                                            // photos FOLDERU TOVOG BUCKET-A
                uploadType: 'media',
                metadata:{
                    metadata: {
                        contentType: upload.mimeType,
                        firebaseStorageDownloadTokens: uuid       
                    }
                }
            }
            
            // SADA UPLOAD-UJEM

            bucket.upload(
                upload.tempFilePath,     // OVO JE PATH FAJLA GDE JE ON SADA
                
                uploadOptions,

                async (error, uploadedFile) => {   // CALLBACK KOJI SE IZVRSAVA, NAKON USPESNOG ILI NEUSPESNOG DOWNLOAD-A
                                             // I DEFINISAO SAM DA TO BUDE async FUNKCIJA
                                             // MISLIM DA CU LAKSE S NJOM SVE DEFINISATI
                    if(error){
                        
                        console.log(error)
                        return `Error: ${error} FAJL NIJE UPLOADED`;

                    }else{

                        // UZIMAM REFERENCU, MOG OBJECT STORE-A 'posts' U REALTIME DATBASE-U
                        const postsRef = database.ref('posts')

                        // !!!!!!!!!!!!!!!!!!!!!!!!    OVO JE VAZNO   !!!!!!!!!!!!!!!!!!!!!!
                        // TVOJE IME SLIKE JE FORMIRANO OD          id-JA       POST-A
                        // TVOJE IME POST-A JE FORMIRANO OD         new Date().toISOString()
                        // 
                                //          OVO ZNACI DA SE SPECIJALNI KARAKTERI MOGU NACI
                                //          U IMENU FAJLA

                                // KADA BUDES IME FAJLA KORISTIO U URL-U
                                // MORACES ENCODE-OVATI TE SPECIJALNE KARAKTERE


                                // SECAS SE KADA SI NA GITHUBU ZADAVAO URL-OVE, SA SPECIJALNIM
                                // KARAKTETRIMA, KAO STO SU ZAGRADE ( , SECAS SE DA NISI MOGAO
                                // KORISTIURL SA SPECIJALNIM KARAKTERIMA, DOK NISI DEFINSIAO ENCODING
                                // ZAGRADA U URL-U, JE MORALA BITI '%24' I SLICNO

                                // E PA TAKAV id, ODNOSNO IME FAJLA JE POTREBNO ENCODE-OVATI JEDNOM FUNKCIJOM
                                //      encodeURIComponent()

                                // TA FUNKCIJA SE MOZE KORISTITI ODMAH U Node.js-U

                        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                        // SADA STAVLJAM SVE PODATKE U DATABASE, U POMENUTI OBJECT STORE

                        await postsRef.push(        // SADA KORISTIM SVE POMENUTE EXTRAHOVANE FIELD-OVE
                                                    // I NJIHOVE VREDNOSTI
                                                    // A UPLOADED FAJL MI JE DOSTUPAN DA SA NJEGA CITAM
                                                    // NJEGOO IME
                            {
                                id: fields.id,
                                title: fields.title,
                                location: fields.location,
                                // IMAGE URL MORAM FORMIRATI OD 'PARCIJALNIH' INFORMACIJA
                                // DA SAM NA PRIMER KORISTIO admin.storage()
                                image: 'https://firebasestorage.googleapis.com/v0/b/' + 
                                        bucket.name +
                                        '/o/' + encodeURIComponent(uploadedFile) +
                                        "?alt=media&token=" + uuid
                                // DAKEL NA KRAJU KORISTIM uuid KOJI SAM KORISTIO, PRI UPLAOD-U
                                // TAKODJE, KAK OBI FORMIRAO OSTATAK URL-A

                            }
                        )

                        // ODAVDE BI ISAO CODE KOJI JE REZERVISAN ZA PUSH (PODESAVANJE VAPID KLJUCEVA ITD)
                        // ALI TO CU DEFINISATI, TEK KADA DEPLOY-UJEM MOJE CLOUD FUNKCIJE
                        // I VIDIM DA LI MOJ CODE FUNKCIONISE
                        
                        
                        return "File is uploaded";

                    }

                }
            )

        })


    })

})


```

STO SE TICE URL ENCODINGA, KOJI SAM GORE POMENUO ,TREBA DA TI BUDE JASNO DA SI KORISTIO [encodeURIComponent()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent) FUNKCIJU, KOJA SE MOZRE KORISTITI U NODE-U, IAKO SAM JOJ JA NASO DOKUMENTACIJU SAMO VEZAN OZA CLIENT, ALI I Node.js IMA TU FUNKCIJU

## DEPLOY-OVACU SADA MOJE CLOUD FUNKCIJE

- firebase deploy --only functions

I MOJA storePostData FUNKCIJA BI SADA TREBALA DA BUDE UPDATED



```javascript
// UVOZIM POMENUTA DVA PAKETA


/* const functions = require('firebase-functions');

const admin = require('firebase-admin');
const cors = require('cors')({
    origin: true
});

const serviceAccount = require("./instaclone-fb-key.json");

const webpush = require('web-push');

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
  databaseURL: "https://instapwaclone.firebaseio.com/"
});

exports.storePostData = functions.https.onRequest(function (request, response) {
	  
	cors(request, response, function () {
    	admin.database().ref('posts').push({
      		id: request.body.id,
      		title: request.body.title,
      		location: request.body.location,
      		image: request.body.image
    	})
		.then(function () {
			webpush.setVapidDetails(
				"mailto:bajic.rade2@gmail.com",
				publicVapidKey,
				privateVapidKey
			);
			return admin.database().ref('subscriptions').once('value');
		})
		.then(function (subscriptions) {
			subscriptions.forEach(function (sub) {
				var pushConfig = {
					endpoint: sub.val().endpoint,
					keys: {
						auth: sub.val().keys.auth,
						p256dh: sub.val().keys.p256dh
					}
				};

				webpush.sendNotification(
					pushConfig,
					JSON.stringify({
                        title: 'New Post',
                        content: 'New Post added!',

                        // DAKLE OVAJ OBJEKAT CE JOS IMATI I       openUrl    PROPERTI
                        // ZADACU RELATIVNI PATH ZA help/index.html PAGE, KOJ JE HOSTED NA ISTOM SERVERU

                        openUrl: '/help'    // NIJE POTREBNO NAVODITI I index.html JER TO JE ONO
                                            // STO SE PO DEFAULTU MORA OTVORITI NA PATH-U
                    })
                )
				.catch(function(err) {
					console.log(err);
				})

			});
			
			return response.status(201).json({message: 'Data stored', id: request.body.id});
		})
		.catch(function (err) {
			response.status(500).json({error: err});
		});
  
	});
}); */






















/* 
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const cors = require('cors')({
    origin: true
});
const serviceAccount = require("./instaclone-fb-key.json");
const webpush = require('web-push');

// *****************************************************

const formidable = require('formidable');

const gcconfig = {
    projectId: 'instapwaclone',
    keyFilename: 'instaclone-fb-key.json'
}

const gcs = require('@google-cloud/storage')(gcconfig);  // OVO JE POGRESNO KORISCENJE PAKETE
                                                         // ILI JE OUTDATED
                                                         // ZBOG POMENUTE STVARI, NECE BITI MOGUC NI DEPLOYMENT
const file_system = require('fs');

const UUID = require('uuid-v4');


const privateVapidKey = "oC8DBLahIEnXnAMEzbmom6BtrF6z7_p7Je3jarU6rVY";
const publicVapidKey = "BMfwPHbn5_YXc0wZZu5xEIIhs40w8CDWGnf2HSq-vAGVOZMLh-vS_m122NEFkIgcDWDRgFzvrBCChNxX_spJoSM";



// ******************************************************


admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
  databaseURL: "https://instapwaclone.firebaseio.com/"
});

exports.storePostData = functions.https.onRequest(function (request, response) {

    cors(request, response, function () {

        // **************************************************

        const formData = new formidable.IncomingForm();   // OBRATI PANJU DA JE OVDE I KARAKTER NAPISAN VELIKIM

        const uuid = UUID();

        formData.parse(request, function(error, fields, files){             // PITANJE JE I DA LI SAM PRAVILNO KORISTIO formidable PAKET

            if(!error){

                admin.database().ref('posts').push({

                    id: fields.id,
                    title: fields.title,
                    location: fields.location,


                    image: 'https://firebasestorage.googleapis.com/v0/b/' + bucket.name + '/o/' +
                            file.name + '?alt=media&token=' + uuid

                })
                .then(function () {
                    webpush.setVapidDetails(
                        "mailto:bajic.rade2@gmail.com",
                        publicVapidKey,
                        privateVapidKey
                    );
                    return admin.database().ref('subscriptions').once('value');
                })
                .then(function (subscriptions) {
                    subscriptions.forEach(function (sub) {
                        var pushConfig = {
                            endpoint: sub.val().endpoint,
                            keys: {
                                auth: sub.val().keys.auth,
                                p256dh: sub.val().keys.p256dh
                            }
                        };

                        webpush.sendNotification(
                            pushConfig,
                            JSON.stringify({title: 'New Post', content: 'New Post added!', openUrl: '/help'}
                        ))
                        .catch(function(err) {
                            console.log(err);
                        })

                    });

                    return response.status(201).json({message: 'Data stored', id: fields.id});
                })
                .catch(function (err) {
                    response.status(500).json({error: err});
                });

            }else{
                console.log(error)
            }


        })

    });
}); */





```