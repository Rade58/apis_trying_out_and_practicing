# KOPIRANJE UMESTO MUTATING-A

POSTOJI GOMILE BIBLIOTEKA KOJE BI MI DALE IMUTABLE DATA STRUCTURES (immutable.js and mori)

AUTOR WORKSHOPA JE SKEPTICAN U POGLEDU NJIHOVOG BRINGING-A U LARGE CLIENT SIDE APPLICATIONS (DODAJE SE LAYER COMPLEXITY-JA)

TESKO JE NA PRIMER REWRITE-OVATI CEO APP, SAMO ZATO DA BI SE KORISTILI POMENUTI LIBRARY-JI

## KORISCENJE Object.assign JE PRETTY RELIABLE

AKO MERGE-UJEM JEDAN OBJEKAT, U EMPTY OBJEKAT (PRVI ARGUMENT), ONDA BI TAJ EMPTY OBJEKAT, NAKON IZVRSENJA OVE FUNKCIJE, POSTAO KOPIJA,

OVO JE VAZNO ZA REACT, ILI USTVARI MOST LIBRARIES, CHECK TO SEE DA LI TREBA JU DA RERENDERU-JU STVARUI

ONE TADA UPOREDJUJU DVA OBJEKTA

MUTATED OBJEKT IMA ISTU SVOJU REFRENCU U MEMORIJI, DAKEL ISTA REFRENCA I KADA NIJE BIO I KADA JE POSTAO MUTIRAN

TO BI OVIM FRAMEWORK-OVIMA OTAZALO RERENDERING, ZATO SE UVEK RETURNUJU KOPIJE, KOJE KAZU REACTU ILI BILO KOM DRUGOM FRAMEWORK-U DA ZELIM DA RERENDERUJEM DOM

**ALTERNATIVA KORISCENJU _Object.assign_-A BI BIO SPREDING OBJEKTA**

```javascript
const original = { a: 1, b: 2 };

const copy = { ...original };
```

AKO OVO PROVUCES KROZ BABEL ILI TYPESCRIPT, VEROVATNO CES DOBITI Object.assign NA DRUGOJ STRANI

## NARAVNO SA Object.assign MOGUC JE COMBINING I MULTIPLE OBJEKATA

```javascript
const original = { a: 1, b: 2 };

const extension = { c: 3 };

const copy = { ...original, ...extension }; // OVAKO

// ILI OVAKO

const copy2 = Object.assign({}, original, extension);
```

## KOPIRANJE ARRAY-A

**PRIMENOM _slice_-A BEZ ARGUMENATA**

**ILI KORISCENJE SPRED SINTAKSE SA ARRAY-EM**

```javascript
const original = [1, 2, 3];

const copy = original.slice();

const copy2 = [...original];
```

_MISLIM DA POSTOJI I concat MOGUCNOST_ ([].concat(original))
