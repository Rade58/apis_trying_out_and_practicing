# KREIRANJE Nodejs MODULA

******

NOTE:

NAMERNO CU SE OVDE POZABAVITI I PISANJEM ESM MODULE-A U TYPESCRIPT-U, KOJ ICE ONDA BITI TRANSPILED U CommonJs

******

DAKLE TO JE REGULARNI CODE, KOJ ISE MORA EXPORT-OVATI

SAV TVOJ Nodejs CODE, ALREADY JESTE MODULI, STO SAM OBJASNIO U PROSLOJ LEKCIJI

## JEDINA STVAR KOJU TREBAM RAZMISLATI JE **"IMAM SAV OVAJ CODE...A STA USTVARI OD TOGA JA ZELIM DA SHRE-UJEM?"**

MOGU DECIDE-OVATI STA SE IZ MOG CODE-A EXPORT-UJE

## ALI TO JE SAMO ZA SHARING; A STO SE TICE TESTING-A, TI MORAS SVE EXPORT-OVATI

U SUSTINI IT'S UP TO ME, KAO AUTOR MODULA DA ODLUCIM **STA CE BITI AVAILABLE ZA DRUGE MODULE**

## ONO STO KORISTIM JE module GLOBAL OBJECT PROVIDED BY Nodejs RUNTIME

CIST JAVASCRIPT (ODNOSNO Node)

```typescript
const dodaj = (broj1, broj2) => {}

const oduzmi = (broj1, broj2) => {}

const nijePublic = () => {}     // OVO NECU EXPOR-TOVATI

// EVO KAKO MOGU KORISITI EXPORT
module.exports = {dodaj, oduzmi};

// VREDNOST POMNUTOGA MOZE BITI BILO KOJA, TO NE MORA BITI SAMO OBJEKAT

// AKO JE VREDNSOT BILO KOJA ON


```

## GORNJI PATTERN KOJI AUTOR WORKSHOPA STALNO KORITI, NAZIVA SE JOS I 'REVELING MODULE PATTERN'

DAKLE NA DNU SE OBICNO DEFINISE EXPORT, I NA TAJ NACIN AKO NESTO ZELI MDA DODAM SASVIM JE LAKO

I SVE JE REVEALING, I LAKSE SE SNACI

LAKSE JE REFERENIRATI STVARI ZA EXPORT

I EXPORT-OVANJE JE ODVOJEN-O OD OSTATKA CODE-A

**A IMPOTOVANJE BI SE DEFINISALO NA SAMOM POCEKU CODE-A**

I JA CU KORISTITI OVAJ PATTERN

## ALI AKO PISEM ESM, JA UOPSTE NE MORAM DA VODIM RACUNA NA POMENUTI PATTERN

MOGU RADITI STA ZELIM

EVO GA TO ISTO U TypeScript-U

## AUTOR WORKSHOPA NE PREPORUCUJE KORISCENJE exports (SHORTHAND-A), VEC SAMO module.exports

## :collision: NEMOJ DA KORISTIS DEFAULT EXPORT AKO BUDES KORISTIO STRIKNO CommonJs :collision:

*OVODE GOVORIM SAMO AKO DODJES U ZABLUDU PA ZELIS DA KORISTIS DEFAULT EXPORT SA NAMED EXPORTIMA I OCEKUJES DA CE SVE BITI U REDU* (E PA MOZES DA POGRESIS)

IMAJ NA UMU DA ZA RAZLIKU OD ESM-A, OVDE LAKO MOZES OVERWRITE-OVATI NAMED I DEFAULT EXPORT-E

EVO POSMATRAJ PRIMER

practice.js

```javascript

const a = 4;
const b = 6;

const funkcija = function(){

}


// OVO BI BIO POGRESAN PATTERN
// NAMED EXPORTS

module.exports.a = a;
module.exports.b = b;

// NEMA SUMNJE DA ONO STO SI GORE DEFINISAO ZA EXPORT USTVARI VISE NE POSTOJI
// ZBOG OVOG DEFAULT EXPORT-A
module.exports = funkcija  


// DAKLE SAMO KORISTI 'REVELING MODULE PATTERN', KADA NA PRIMER NE TRANSPILEUJES NISTA
// ODNOSNO SAMO NAMED EXPORTS

```

## ALI ESM RESAVA GORE POMENUTI PROBLEM; ODNOSNO MOGU BITI SLOBODNIJI, PRI DEFINISANJU MODULA

*practice.ts*

```typescript

export const broj :number = 48;
export const rec :number = "foo bar";



export default function(a: string){

}

```

EVO GLEDAJ OVO

MOZES OVAKO NESTO DA URADIS

*index.ts*:

```typescript
import {broj, rec} from './practice';

// A AKO ZELIS SAMO DEFAULT EXPORT URADIS SLEDECE

import nekaFunkcija from './practice';

```

## U STA SE COMPILEIRA TYPESCRIPT

EVO POGLEDAJ JEDAN PRIMER

**TypeScript** CODE

******

practice.ts

```typescript
export const a: string = "something";

export const b: number = 48;

export default (a: any) => { console.log(a) }
```

index.ts

```typescript
import {a, b} from './practice';

import nesto from './practice';

console.log(nesto, a, b);
```

OVDE POKAZUJEM JAVASCRIPT, U KOJI CE GORNJI TYPESCRIPT CODE BITI COMPILED

******

pracrice.js

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });      // KAO STO VIDIS OVDE SE KORISTI   exports ZA 
                                                                    // KOJI MI JE SCOTT MOSS


                                                     // SAVETOVAO DA GA NE KORISTIM, KADA PISEM DIREKTNO CommonJs
// NAMED EXPORTI
exports.a = "something";
exports.b = 48;

// DEFAULT EXPORT

// KAO STO VIDIS ON SE ZADAJE KAO PROPERTI      default
exports.default = (a) => { console.log(a); };
```

index.js

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true }); // ISTA STVAR JE I OVDE

// KORISCEN JE require NARAVNO
// ALI ZBOG IMPORTOVANJA DEFAULT-A, DRUGOG MODULA
// IMAM DVA POZIVANJA require-A
// TO JE ZATO STO SAM ZATRAZIO NAMED EXPORT I ZATRAZIO SAM I DEFAULT EXPORT KADA SAM DEFINISAO TYPESCRIPT CODE

const practice_1 = require("./practice");
const practice_2 = require("./practice");

// EVO OVDE MOGU VIDETI KAKO SE KORISTE I NAMED EXPORTI I DEFAULT EXPORT
console.log(practice_2.default, practice_1.a, practice_1.b);
```

******

NE MORAM DAVATI DODATNE KOMENTARE, MISLIM DA JE POPRILICNO JASNO U SA SE COMPILE-OVAO ESM

## STO SE TICE TYPESCRIPTA, MOZES IMATI PROBLEMA PRI UVOZU ONIH MODULA, KOJE TI NISI NAPRAVIO; ODNOSNO PRI UVOZU Nodejs-OVI INTERNAL MODULA I OSTALIH MODULA, KOJE SI INSTALIAO I KOJE UVOZIS IZ node_modules

```typescript

// POGLEDAJ OVO

import fs from 'fs';     // !!!  ---->      ERROR

// JEDINI NACIN JE DA KORISTIS          *

// POGLEDAJ

import * as fs from 'fs';    // **** DAKL KORISTIS * (EVERYTHING) I KORISTIS as GDE ZADAJES IME POD KOJIM CES 
                                                                                // KORISTITI MODUL

// STA JE OVDE SJAJNA STVAR ?

// PA SJAJNO JE TO ZATO STO SI INSTALIRAO TYPE-OVE ZA NODE, I POSTO SI IH 'LEAK IN'-OVAO 

fs.     // **** KADA STAVIM DOT, TYPESCRIPT MI IZLISTAVA SVE MOGUUCE PROPERTIJE I METODE fs MODULA
        // **** I NJIHOV OPIS I MOGUCI ARGUMENTI SU PRIKAZANI U TOOLTIP-U

// OVDE SAM SE DOTAKAO INTERNAL MODULA, A NJIMA CU SE POZABAVITI DETALJNIJE U SLEDECEM POGLAVLJU

```

AKO TE ZANIMA U STA JE COMPILED GORNJI ISPRAVA NCODE, SAMO POGLEDAJ, sledeci javascript

```javascript
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

const fs = require("fs");   // **** TO JE OVO
```
