# ASYNCHRONOUS PATTERNS

ODMAH DA KZEM async await JE LEGIT I MOZE SE KORITI U Nodejs-U, I TO CU NAJVISE I KORISTITI

## CALLBACK PATTERN

U OVOM PATTERN-U FUNKCIJI SE DODAJE CALLBACK ARGUMENT, A NJEGOVI PARAMETRI SU

- ERROR CALLBACK (BICE null AKO JE SVE U REDU)

- RESULT CALLBACK

LICNO NAJOMRAZENIJI NACIJ, JER MOZE NASTATI CALLBACK HELL

```javascript
radiAsyncStvar((error, result) => {})
```

NEMA STADARDA ZA OVO, VEC JE COMUNITY ADOPT-OVAO OVO

I INTRNAL node_modules OVO KORISTE

NEMA PRAVILA ZA TO, NEGO, THAT'S JUST HOW IT IS

**ALI OVO JE SO 90', JER NIKO VISE I NE KORISTI CALLBACKS**

*AUTOR WORKSHOPA NE MOZE DA PODNESE DA IH KORISTI*

AKO NEKO POKUSA DA MU SUBMIT-UJE PR (PUSH REQUEST) U KOJEM KORISTI CALLBACKS, ON IH ELEGANTNO ODBIJE

## Promises

GLAVNA STVAR JESTE STO U SLUCAJU KORISCENJA PROMISE-A, JA MOGU ANTICIPATE RESOLVEMENT I DEFINISA TI DA SE NESTO URADI PO RESOLVMENTU ILI PO REJECTION-U

```javascript
radiAsyncStvar().then(result => {}).catch(error => {})
```

MISLI MDA SAM IH DOVOLJNO KORISTIO DA BIH OVDE DAVAO SUVISNA OBJASNJNJA

## async / await

OVO JE NEXT STEP, KOJI JA NAJVISE VOLIM DA KORISTIM

ASINHRONI CODE SE TAKO PISE DA IZGLEDA SINHRONO, AL IREC JE O ASINHRONOM CODE-U, KOJI SE CINI BLOCKING-OM, UPOTREBOM await-A

MOZE DA KORISTI try catch BLOK

```javascript
const run = async () => {

    const result = await radiAsyncStvar(); //   radiNestoAsync MORA DA RETURN-UJE PROMISE

    // await BLOKIRA CODE DOK SE TAJ PROMISE NE RESOLVE-UJE

    console.log

}
```

MOJ OMILJENI ERROR HANDLING PATTERN BI BIO KORISCENJE try catch

ALI POSTOJI JOS PATTERNA

- JEDAN OD NJIH JE KORISCENJA GORNJEG (const result) DA BUDE NIZ, OD KOJIG BI PRVI CLAN BIO ERROR, A DRUG I result

**ODNOSNO PROMISE BI UVEK BIO RESLOVED SA ARRAY-OM, A PRVI ARGUMENT BI BIO ERROR, A DRUGI RESULT; DAKLE**

*COMUNITY IS MOVING LIKE THAT, DA USVAJA OVAJ DRUGI NACIN ERROR HANDLINGA, DAKLE BEZ UPOTREBE try catch-A*

*RAZLOG JE UPRAVO TO STO SE GORNJI PROMISE ONDA UVEK RESOLVE-UJE*