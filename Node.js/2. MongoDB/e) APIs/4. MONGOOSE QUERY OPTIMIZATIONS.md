# Mongoose QUERY OPTIMIZATIONS

MISLIM DA SAM VEC O OVOME GOVORIO

U SUSTINI QUERYING CE RETURN-OVATI 'FAKE PRIMISE', A TO JE DocumentQuery INSTANCA, A JA MOGU CHAIN-OVATI METODE, KOJE CE IPAK OMOGUCITI DA ONO CIME JE RESOLVED DocumentQuery (A TO SU Document ILI NIZ SA Document INSTANCAMA), POSTANE ONO CIME CE BITI RESOLVED I Promise, KOJ ICE BITI KREIRAN

DAKEL MENI TREBA Promise INSTANCA NA KRAJU QUERY-JA

- ZA TO JE SLUZILA exec METODA KOJU BIH PRIMENIO NA DocumentQuery INSTANCI

DocuemntQuery JE MONGOOSE-OV ENTITET

MENI ON TREB JEDINO KADA JE POTREBNO ODRADITI NEKE OPERACIJE NA TAKVOM OBJEKTU

## MONGOOSE OBJEKAT TI SAM OTREBA KADA RADIS OPERACIJU NA MONGOOSE-OVOM OBJEKTU, KAKAV JE DocumentQuery, ILI Document

TO SU BILE ONE METODE KOJE SI JEDNOM KORISTIO

ODNOSNO TE METODE MOGU VRSITI DALJI QUERYING

TI MOZES NA DocumentQuery-JU DALJE CHAIN-OVATI METODU findByIdAndUpdate NA PRIMER

## METODA lean, KOJA JE METODA DocumentQuery-JA, CE MODIFIKOVATI CAK Document-E, SA KOJIAM JE FAKE PROMISE RESOLVED

>>>> Sets the lean option. Documents returned from queries with the lean option enabled are plain javascript objects, not MongooseDocuments. They have no save method, getters/setters or other Mongoose magic applied.

DAKLE ONO CIME CE DocumentQuery BITI RESOLVED BICE OBICNI JAVASCRIPT OBJEKTI

EVO NA PRIMER POSMATRAJ OVKAV CHAINING

```javascript
app.get('/note', async (req, res) => {

  const notes = await Note.find({})
    .lean()   // DocumentQuery CE SADA BITI RESOLVED SA OBICNIM JAVASCRIPT OBJEKTIMA (VISE NEMA Document INSTANCI)
    .exec()   // SADA VISE NEMA NI DocumentQuery-JA, I OBICAN Promise CE BITI RESOLVED SA OBICNIM JAVASCRIPT OBJEKTIMA

    //  ZASTO JE OVO DOBRO
    // PA ZATO STO NE BI TREBALO DA SALJEM Document INSTANCU KAO JSON

    // TU NARAVNO IMA POTENCIJALA ZA GRESKU, KADA BIG Document INSTANCU PROSLEDIO CLIENT-U
    // TU SU PITANJA I EFIKASNOSTI, ALI I BEZBEDNOSTI
    // ZASTO BI CLIENTU, UOSTALO MSLAO, VISE OD ONOGA STA MU JE POTREBNO

    // DAKLE SADA SAM json METODI PROSLEDIO OBICAN JAVASCRIPT NIZ, SA OBICNIM JAVASCRIPT OBJEKTIMA (KONKRETNO U OVOM 
    // PRIMERU)

    // TAJ NIZ I OBJEKTI CE BITI PREVEDENI U JSON FORMAT I POSLATI CLIENT-U

  res.status(200).json({data: notes})

})
```

## KADA SE KREIRA DOKUMENT ILI DOKUMENTI TADA NE MOGU KORISTITI lean JER NEMA Querydocument INSTANCE, CIJA JE lean METODA

TADA MOGU KORISTITI **toJSON** METODU (POSTOJI I METODA toObject)

```javascript
app.post('/note', async (req, res) => {
  const note = await Note.create(req.body)

  res.status(201).json({data: note.toJSON() })    // EVO ISKORITIO SAM POMENUTU toJSON METODU

})
```

SAMO MALO MI NIJE JASNO ZASTO BIH TO KOTRISTIO AKO json METODA PRE SENDINGA RESPONSE-A, VALJDA ISTO TAKO PRSE-UJE U JSON

## DAKLE OVE OPTIMIZACIJE CE UBRZATI DATBASE QUERIES I ZATO IH TREBA KORISTITI
