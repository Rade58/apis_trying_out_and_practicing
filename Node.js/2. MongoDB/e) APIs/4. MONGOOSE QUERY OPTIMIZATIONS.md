# Mongoose QUERY OPTIMIZATIONS

MISLIM DA SAM VEC O OVOME GOVORIO

U SUSTINI QUERYING CE RETURN-OVATI 'FAKE PRIMISE', A TO JE DocumentQuery INSTANCA, A JA MOGU CHAIN-OVATI METODE, KOJE CE IPAK OMOGUCITI DA ONO CIME JE RESOLVED DocumentQuery (A TO SU Document ILI NIZ SA Document INSTANCAMA), POSTANE ONO CIME CE BITI RESOLVED I Promise, KOJ ICE BITI KREIRAN

DAKEL MENI TREBA Promise INSTANCA NA KRAJU QUERY-JA

- ZA TO JE SLUZILA exec METODA KOJU BIH PRIMENIO NA DocumentQuery INSTANCI

DocuemntQuery JE MONGOOSE-OV ENTITET

MENI ON TREB JEDINO KADA JE POTREBNO ODRADITI NEKE OPERACIJE NA TAKVOM OBJEKTU

## MONGOOSE OBJEKAT TI SAM OTREBA KADA RADIS OPERACIJU NA MONGOOSE-OVOM OBJEKTU, KAKAV JE DocumentQuery, ILI Document

TO SU BILE ONE METODE KOJE SI JEDNOM KORISTIO

ODNOSNO TE METODE MOGU VRSITI DALJI QUERYING

TI MOZES NA DocumentQuery-JU DALJE CHAIN-OVATI METODU findByIdAndUpdate NA PRIMER

## METODA lean, KOJA JE METODA DocumentQuery-JA, CE MODIFIKOVATI CAK Document-E, SA KOJIAM JE FAKE PROMISE RESOLVED

>>>> Sets the lean option. Documents returned from queries with the lean option enabled are plain javascript objects, not MongooseDocuments. They have no save method, getters/setters or other Mongoose magic applied.

DAKLE ONO CIME CE DocumentQuery BITI RESOLVED BICE OBICNI JAVASCRIPT OBJEKTI

EVO NA PRIMER POSMATRAJ OVKAV CHAINING

```javascript
app.get('/note', async (req, res) => {

  const notes = await Note.find({})
    .lean()   // DocumentQuery CE SADA BITI RESOLVED SA OBICNIM JAVASCRIPT OBJEKTIMA (VISE NEMA Document INSTANCI)
    .exec()   // SADA VISE NEMA NI DocumentQuery-JA, I OBICAN Promise CE BITI RESOLVED SA OBICNIM JAVASCRIPT OBJEKTIMA

    //  ZASTO JE OVO DOBRO
    // PA ZATO STO NE BI TREBALO DA SALJEM Document INSTANCU KAO JSON

    // TU NARAVNO IMA POTENCIJALA ZA GRESKU, KADA BIG Document INSTANCU PROSLEDIO CLIENT-U
    // TU SU PITANJA I EFIKASNOSTI, ALI I BEZBEDNOSTI
    // ZASTO BI CLIENTU, UOSTALO MSLAO, VISE OD ONOGA STA MU JE POTREBNO

    // DAKLE SADA SAM json METODI PROSLEDIO OBICAN JAVASCRIPT NIZ, SA OBICNIM JAVASCRIPT OBJEKTIMA (KONKRETNO U OVOM 
    // PRIMERU)

    // TAJ NIZ I OBJEKTI CE BITI PREVEDENI U JSON FORMAT I POSLATI CLIENT-U

  res.status(200).json({data: notes})

})
```

## KADA SE KREIRA DOKUMENT ILI DOKUMENTI TADA NE MOGU KORISTITI lean JER NEMA Querydocument INSTANCE, CIJA JE lean METODA

TADA MOGU KORISTITI **toJSON** METODU (POSTOJI I METODA toObject)

```javascript
app.post('/note', async (req, res) => {
  const note = await Note.create(req.body)

  res.status(201).json({data: note.toJSON() })    // EVO ISKORITIO SAM POMENUTU toJSON METODU

})
```

SAMO MALO MI NIJE JASNO ZASTO BIH TO KOTRISTIO AKO json METODA PRE SENDINGA RESPONSE-A, VALJDA ISTO TAKO PRSE-UJE U JSON

## DAKLE OVE OPTIMIZACIJE CE UBRZATI DATBASE QUERIES I ZATO IH TREBA KORISTITI

## SWEET THING ABOUT MONGOOSE

DOK DATBASE BUILD-UJE UP MODELE I KOLEKCIJE ZA MENE, A TI STARTUJER DA RUN-UJES OPERACIJE NA NJIMA, ONO STO CE SE DOGODITI JESTE DA CE TE OPERACIJE BITI BUFFERED

ISTO KAO STO NEKI ANALITICS TOOL DOES (BEFORE IT LOADS UPA, AK OTI POSCNES DA ISSUE-UJES ANLITICS COMMANDS  ITRACKING COMMANDS, BICE CAPTURED ALL THESE EVENTS, KAO U ARRAY-U, I KADA SE LOAD-UJE, ONI CE BITI REPLAYED IN ORDER THEY HAPPEN)

E PA MONGOOSE RADI SVE ISTO

AKO START-UJES DA ASHER-UJES KOMANDE NA DATBASE-U ,NA PRIMER NA Note MODELU U MOM PRIMERU, ILI BILO KOJEM MODELU KOJ IMAM, BEFORE IT'S DONE INITIALIZING, KOMANDE CE BITI BUFFERED, AND REPLAY THEM WHEN IT DOES COPNNECT

PROBLEMI KOJI MOGU NASTATI SU INEXPECTED SIDE EFFECTS

AKO POCNES DA SHERUSJES KOMAND KAO STO SU find I create, BEFORE indexes WERE BUILD, ONDA MOZES IMATI SOME DATA THAT SNUKED IN THERE, KOJ SE PROSUNJALA PORED INDEKSA

ZATO JE BOLJE SACEKATI DA SE INDEKSI NAPRAVE

INDEKSI SE NEKAD BUILD-UJU PREDUGO

ZATO SE MORA RAZMISLJATI O MNOGIM TRADEOFS

>> you have to think about when to index, when to setup, what to wait for, it's all very specific to your application. Most application you don't really have to think about that (ALI MORACES RAZMISLATI O TOME KADA JE REC O VELIKIM PRODUCTION APP-OVIMA)