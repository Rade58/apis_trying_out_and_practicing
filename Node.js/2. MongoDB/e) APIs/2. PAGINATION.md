# PAGINATION

POSTOJI MNOGO NACINA DA SE RADI PAGINATION, GENERALNO U DATABASE-OVIMA

## DVA NACINA KOJE AUTOR WORKSHOP VOL IDA KORISTI SU ILI **CUSRSOR BASED PAGINATION**, ILI *'SKIP LIMIT BASED PAGINATION'*

## CURSOR BASED BASED PAGINATION

NA PRIMER POSALJES LISTU OD HUNDRED RESULTS

LAST RESULT U ITEMU, JE U OSNOVI JESTE MESTO GDE SI LEFT OFF

TAK ODA KAD POSALJES REQUEST BACK DO SLEDECEG, ONDA POCINJES OD TOG KURSORA

NEKI LJUDI KORISTE INDEKSE, KAO KURSORE; A NEKI PRAVE THIR OWN CURSORS

>> THEY'LL SEND BACK ALL THE ITEMS, AND THEY'LL ACTUALLY MAKE THE CURSOR, A CURSOR JE BASICALLY ID, KOJI POINTS TO SOMETHING; SOMETHING UNIQUE STA SI SAVE-OVAO

OVO JE POPUT BOOKMARKA U TVOM BOOK-U

>>>> It's like, here's where I left off, and it can be anything. Something that you know is guaranteed to allow you to figure out where you left off

ITEM U RESULT-U JE BEST THING AS A CURSOR, JER AK OSORT-UJES TVOJ REZULTAT, I AKO DOBIJES LAST THING U RESULT-U; BICE GARANTOVANO DA CES STARTOVATI WHERE YO ULEF OFF

AKO JE SVE SORTED STO I TRBA DA BUDE U PAGINATION-U, TAKO DA LJUDI KORISTE LAST ITEM INSIDE ARRAY AS A CUSRSOR

TO JE DAKLE BI OJEDAN NACIN

## DRUGI NACIN JE 'SKIP THE LIMIT'

AKO OVO ZELIS DA URADIS U MONGO-U IMAS PONUDJENE METODE

- skip

- limit

TAK ODA PAGIANTIO NRADIS TU

AKO SI NA SECOND PAGE-U , I POSTOJI 10 STVARI NA PAGE-U, ZELIS DA PRESKOCIS PRVIH 10;  IZELIS DA LIMITIRAS 10

```javascript
app.get('/notes', async (req, res) => {

  const notes = await Note.find({})
    .skip(10)     //
    .limit(10)    //
    .exec()

  res.status(200).json({data: notes})

})
```

ALI NEMOJ DA ZABORAVIS, MORAS PRVO DA SORT-UJES

```javascript
app.get('/notes', async (req, res) => {

  const notes = await Note.find({})
    .sort()       // sortujes by something, odnsno to something ide kao argument
    .skip(10)
    .limit(10)
    .exec()

  res.status(200).json({data: notes})

})
```

MAL OJE OVO BIL ONERAZUMLJIVO, MZDA MOGU NEGDE VISE SAZNATI O OVOME
