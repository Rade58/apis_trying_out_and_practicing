# KREIRANJE ASSOCIATIONS SA NESTED SCHEMA-MA

SADA CU GOVORITI O RELATIONSIMA

DA SE EMBED-UJE JEDNAN DOCUMENT U DRUGI POSTOJI NEKOLIKO NACINA

JEDAN NACIN NACIN JE LSO NACIN, A SASTOJI SE OD PROSTO EMBEDING-A OBJEKTA KAO STO SAM DOLE PRIKAZAO

```javascript
const student = new mongoose.Schema({
  firstName: {
    type: String,
    required: true,
    unique: true
  },

  favFood: [{type: String}],


  info: {                 // EVO TI OVDE IMAS I ON JE NESTED OBJEKAT

    school: {           // EVO POGLEDAJ OVDE IMAS school I ON JE NESTED OBJEKAT

      name: {               // ON IMA name, A ON JE String TYPE-A
        type: String
      }

    },
    shoeSize: {
      type: Number
    }
  }

}, { timestamps: true })

const Student = mongoose.model('student', student)      // AKO SE SECAS RANIJE SAM REKAO DA CE
                                                        // DATABASE SAM PLURALIZOVATI IME KOLEKCIJE U DTABASE-U
                                                        // BICE students U DATBASE-U

```

*AKO POSMATRAM GORE info OBJEKAT, ALI IAKO POSMATRAM school OBJEKAT, MOGU ZAKLJUCITI DA: **OBA TA OBJEKATA NEMAJU KARAKTERISTICAN *_id* , SVOJSTVEN DOKUMENTU IZ DATABASE-A***

******

digresija1:

*ONO STO JE GORE MOGLO DA SE DEFINISE JESTE DA info BUDE NESTED SCHEMA, ODNOSN ODA info REFERENCIRA DRUGU SCHEMA-U*

**MOGLO JE ALI TO NE TREBA RADITI, *POGOTOVO NE U PRODUCTION-U***

******

******

digresija2:

HAJDE DA POSMATRAMO student I school

AKO SI IKADA RADIO NEKI RELTIONAL DATA BUILDING, ILI NEKU DATA CONFIGURATION, ZNAS DA MOZES STORE-OVATI ARRAY OF studentS NA school-u, ILI MOZES STORE-OVATI school NA student-U

U PRIMERU KOJI JE U OVOM FAJLU, U PITANJU JE DRUGI SLUCAJ

******

## ONO STO USTVARI TREBA DA SE URADI JESTE KREIRANJE POTPUNO NOVE SCHEME I NOVOG MODELA, I TAJ MODEL NA POSEBAN NACIN TREBA DA SE REFERENCIRA (VIDECES ZASTO SAM REKAO POSEBAN)

*TO ZNACI DA school TREBA DA REFERENCIRA DOKUMENT, KOJI JE DOKUMENT NOVE KOLEKCIJE KOJU TREBA DEFINISATI* (MOJE RECI)

**PORED TOGA TREBA SE OBEZBEDITI type ZA NESTED ENTITET, KOJI NARAVNO TREBA DA BUDE TYPE KOJI ODGOVARA DOKUMENTU**

A TAJ type CE MI OBEZBEDITI MONGOOSE

NAJBOLJEJE DA PRIKAZEM PRIMER

:one: POTREBNO JE PRVO DA SE KREIRA SCHEMA ZA school

:two: POTREBNO JE ONDA KREIRATI POTPUNO NOVI MODEL, KOJI CE DESCRIBE-OVATI NOVU KOLEKCIJU; A U SLUCAJU MOG PRIMERA TO CE BITI school

```javascript

// OVU SCHEMA-U ZA SADA NE DIRAM
const student = new mongoose.Schema({
  firstName: {
    type: String,
    required: true,
    unique: true
  },

  favFood: [{type: String}],


  info: {

    school: {

      name: {
        type: String
      }

    },


    shoeSize: {
      type: Number
    }
  }

}, { timestamps: true })

// EVO, KRIRAO SAM NOVU SCHEMA-U, KOAJ JE POGODNA ZA DA REPREZENTUJE school

const school = new mongoose.Schema({
  name: String                          // DAKLE SAMO JEDAN FIELD TREBA DA IMAJU DOKUMENTI IZ schoolS KOLEKCIJE
})


const Student = mongoose.model('student', student)

// EVO GA I NOVI MODEL
const School = mongoose.model('school', school)           // EVO


// PRIMECUJES DA REDOSLED BILO CEGA STO SAM DEFINISAO NIJE BITAN

// JER KADA BUDEM REFERENCIRAO BIL OSTA U NASTAVKU, NECE SE REFERENCIRATI NODEJS VARIJABLE, ILI BILO STA AT
// RUNTIME

// ON OSTO CE BITI USTVARI BITNO JESU IMAENA KOLEKCIJA ODNOSNO IME KOLEKCIJE
// KOJE JE OVDE U SINGULAR (KAO STO SAM REKAO PLURALITY U IMENU CE BITI OBEZBEDJEN ZA ACTUA LCOLLECTION U DATBASE-U)

```

## POSTO SAM SVE DEFINISAO MOGU SE POSTARATI student SCHEMA-OM, I KAKO DA U NJOJ DEFINISEM DA DOKUMENT IZ students KOLEKCIJE, MOZE DA IMA I FIELD, CIJA CE VREDNOST BITI JEDAN DOKUMENT IZ schools KOLEKCIJE

EVO PAR STVARI KOJE CU DA KORISTIM

- PROPERTI **ref** KAKO BI REFERENCIRAO KOLEKCIJU

- PROPERTI **type** KAKO BI ZADAO DA NEKI OBJEKAT USTVARI BUDE DOKUMENT, A NE SAMO 'PLAIN OBJEKAT'

```javascript

// OVU SCHEMA-U ZA SADA NE DIRAM
const student = new mongoose.Schema({
  firstName: {
    type: String,
    required: true,
    unique: true
  },

  favFood: [{type: String}],


  info: {

    /* school: {        // OVO DAKLE VISE NECE OSTATI OVAKO, I TAKODJE school NECE BITI
                        // U OBICNOM OBJEKTU

      name: {
        type: String
      }

    }, */

    shoeSize: {
      type: Number
    }
  },


  school: {         // ZELIM DA school REPREZENTUJE DOKUMENT IZ schoolS KOLEKCIJE

    type: mongoose.Schema.Types.ObjectId,    // ZBOG OVOGA OVO CE BITI DOKUMENT

    ref: 'school'             // ZBOG OVOGA TO CE MORATI DA BUDE DOKUMENT IZ schools KOLEKCIJE
                              // KOJEG DESCRIBE-UJE School MODE, ODNOSNO school SCHEMA 
  }
    // POMENUTI FILED (ODNOSNO DOKUMENT) IMA SAM P OSEBI SVOJ FIELD name (A JASNO DA SE OVDE TO NE VIDI)
    //                                                                    (I NE TREBA D ASE VIDI)



}, { timestamps: true })



const school = new mongoose.Schema({
  name: String
})


const Student = mongoose.model('student', student)

const School = mongoose.model('school', school) // JASN OTI JE DA JE STRINGM ODNOSNO IME KOJE SAM OVDE PROSLEDIO
                                                // U POTREBLJENO GORE, KAO VREDNOST ref PROPERTIJA

```

## PREDLAZEM DA 