# PISANJE MUTATION TYPE-A

OVDE ZELI MDA GOVORIM O SPECIJALNOM TYPE-U, KOJ ISE ZOVE **Input** *TYPE*

DA BIH MOGL IDA SE AXCCEPT-UJU ARGUMENTI U MUTACIJAMA, MORAS KREIRATI POMENUTE TYPE-OVE

ONI SU LITTERALL YEXACT SAME THING AS TYPES, SAM OSA RAZLIKO DA SE SAMO KORISTE ZA INPUTS, ODNOSNO ARGUMENTS

KREIRAM IH POTPUNO ISTO SAM OSA RAZLIKOM DA CE POSTOJATI, JOS JEDNA REC

## IME 'PROPERTIJA' TOG INPUT TYPE JE VAZNO (GOVORIM O NJEGOVOM KORISCENJU U QUERY TYPE-U), JER CES U OBIMIMAMA RESOLVER-A TI UPRAVO KORISITI TO IME DA BIH ACCESS-OVAO ARGUMENTIMA

SCOTT MOSS, KORISTITI IME *input*, MADA JE MOGUCE BILO KOJE DRUGO IME

A UZ TO IME (NAKON SEMICOLON-A) DEFINISEM ZELJENI TYPE ZA TAJ INPUT (ODNOSNO REFERENCIRAM GA, JER SAM GA NEGDE U SCHEMA-I KREIRAO)

## VAZNO JE DA SE TAJ INPUT TYPE SE KREIRA SA **input** KEYWORD-OM

*AUTOR WORKSHOPA TAKODJE VOLI DA U IMENU TOG INPUT TYPE-A, KORISTI ODREDNICU Input* (KAKO BI SE ZNALO DA SE RADI O INPUT TYPE-U A NE )

SADA C USVE TO I DEFINISATI

```javascript
const rootSchema = `
    type Cat {
      name: String
      amount: Int!
      bestFriend: Cat!
    }

    // ********  EVO KREIRAM INPUT TYPE   ************* (NE ZABORAVI DA SE KORISTI input KEYWORD)

    input CatInput {
      name: String
      amount: Int!
      bestFriend: Cat!
    }

    type Query {
      myCat: [Cat]
      myMouse: String
    }

    // ************ SADA TAJ INPUT TYPE KORISTIM U MUTATION TYPE-U (MOZEZ ZADATI IME ARGUMANTA KOJE ZELIS 
    // *************  A U OVOM SLUCAJU ONO SE ZOVE input (TO JE I MOSSOVA KONVENCIJA DA GA TAKO IMENUJE))

    type Mutation {
      newCat(input: CatInput): Cat!
    }

    schema {
      query: Query
    }
  `
```

**ONO STO JE VAZNO JESTE, DA NE MOZES STAVLJATI REGULAR TYPE NA MUTATION TYPE, TO MORA BITI INPUT TYPE**
