# JWT MODULE

SADA CU KREIRATI DVE FUNKCIJE

OD KOJIH CE JEDNOJ BITI ULOGA DA UZME USER OBJECT, ODNOSNO USER DOCUMENT IZ DATBASE-A ID I DA SE OD TOGA US POMOC JWT-A NAPRAVI TOKEN, BASED ON USER ID

DAKLE ONA CE RETURN-OVATI JSON WEB TOKEN, BASED ON USER ID, I SIGNED SA CORRECT SECRET-OVIMA; I EXPIRATIO NTIME-OM

A DRUGA CE BITI TAKVA DA CE BITI OPOSITE, ODNOSNO TREBA DA JOJ SE PROSLEDI TOKEN; I ONA TREBA DA VERIFIKUJE DA JE TA JTOKEN KREIRAN SA SAME SECRET-OM, SA SAME SERVER-A, A RETURN-OVACE PAYLOAD, STO CE U OVOM SLUCAJU BITI USER

## POSTOJI TONE PAKETA, A JA CU KORITITI *jsonwebtoken* FROM NPM

OVAJ JE NAJPOPULARNIJI I IMa **sign** METODU, KOJ MI OMOGUCAVA DA SIGN-UJEM OBJEKAT, SA SECRET-OM, I MOGU DODATI OPCIONI EXPIRES TIME, KADA CE TAJ TOKEN EXPIRE-OVATI

A METODA **verify**, RADI THE OPOSITE; TAKES I NTOKEN; ISTI ONAJ SECRET SA KOJIM JE TREBALO SIGNOVATI, I TRECI ARGUMENT JE CALLBACK SA PARAMETRIMA KOJ ISE ODNOSE NA ERROR I PAYLOAD, KOJI SE KORISTIO ZA KREIRANJE TOKENA

## JA SADA ZELIM DA POSMATRAM KAKO JE AUTOR WORKSHOPA DEFINISAO TE FUNKCIJE I ZELI MDA VIDIM KAKO JE ON U OVOM PRIMERU KORISTIO SECRETS

******

FILE/FOLDER STRUKTURA PROJEKTA:

```unix
│   index.js
│   server.js
│
├───config                // (2) ONO STO JE INTERESANTNO JESTE DA JE SECRET UZET ODAVDE
|                         // IZ KONFIGURACIJE DAKLE, PREDPOSTAVLJAM DA SE IZ ENVIROMENTA (env)
|                         // PROSLEDJUJE SECRET, KOJI MOZE DA OVERRIDE-UJE DEFAULT SECRET
|                         // ZADAT U KONFIGURACIJAMA (TAKO JE DEFINISAO AUTOR WORKSHOP-A)
│       dev.js
│       index.js
│       prod.js
│       testing.js
│
├───resources
│   │
│   └───user            // (3) OVDE CU KORISTITI POMENUTE KONTROLERE ZA SIGNING IN AND OUT, I MIDDLEWARE
│           user.controllers.js
│           user.model.js
│           user.router.js
│
├───utils
│   │   auth.js  // (1) OVDE SE NALAZE TVOJE FUNKCIJE ZA KREIRANJE NOVOG TOKENA I ZA VERIFIKACIJU TOKENA
|   |           //U ISTOM FAJLU CES PRAVITI KONTROLERE, KOJE SLUZE ZA SIGNING IN I SIGNING OUT
|   |             // AL ICES PRAVITI I MIDDLEWARE, PREDPOSTAVLJAM DA CE UPRAVO MIDDLEWARE BITI ODGOVORAN
|   |             // ZA VERIFICATION
│   │   crud.js
│   │   db.js

```

******

auth.js FAJL:

```javascript
import config from '../config'      // UVOZIM DAKLE OBJEKAT U KOJEM JE SECRET
import { User } from '../resources/user.model'  // UVOZIM I MODEL ZA USER-A

// NARAVNO UVOZIM I jwt PAKET
import jwt from 'jsonwebtokens'


// SAD MOGU DEFINISATI I METODE, I MOGU KORISTITI Promise, KAKO BI WRAPP-OVAO POZIVANJE
// jwt.verify METODE (TO RADI MZATO STO JE ONA CALLBACK BASED)


// NOVI TOKEN DOBIJAM KAO POVRATNU VREDNSOT sign METODE
const newToken = user => {

  return jwt.sign(
    {id: user.id},         // OBJEKAT SA USER ID-JEM SE KORISTITI KAO PAYLOAD
    config.secrets.jwt,            // SECRET JE PROCITAN IZ config FOLDERA
    {                             // I ZADATO JE VREME KOLIK OTRAJE OVAJ OUTPUTED TOKEN (I TO JE SECRET)
      expiresIn: config.secrets.jwtExp
    }
  )

}

// DAKLE SECRET SE KORISTI KAO KLJUC U SLEDECOJ METODI

const verifyToken = token => {

  return new Promise((res, rej) => {

    jwt.verify(token, config.secrets.jwt, (err, payload) => {

      if(err) return rej(err)           // OVDE JE SVE JASNO

      res(payload)
    })

  })

}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//  U SLEDECIM KONTROLERIMA TREBA DA SE KORISTE, POMENUTE DVE METODE

export const signIn = async (req, res) => {}
export const signOut = async (req, res) => {}

// MISLIM DA CE SE VERIFIKACIJA ODIGRAVATI U SLEDECEM MIDDLEWARE-U

export const protect = async (req, res, next) = {

  next()

}

```