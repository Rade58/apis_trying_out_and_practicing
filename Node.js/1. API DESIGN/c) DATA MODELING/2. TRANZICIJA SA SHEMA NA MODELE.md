# TRANZICIONIRANJE SA SCHEMA NA MODELE

ZA SVAKI OD RESURSA, KOJE ZELIM DA EXPOSE-UJEM, KROZ MOJ API (STO BI U SLUCAJU PRIMERA KOJE CU RADITI, BILI user, list I item); MORAO BI DA KREIRAM SCHEMA I MODEFL FOR IT

ALI U REST API, TO MOZES IAMTI RESURSE, KOJI SU PRIVAT, I KOJI NISU EXPOSED TO REST API; TAK ODA MOZES IAMTI DATBASE MODELE, KOJI NEMAJU ATTACHED RESOURCES; NA PRIMER AKO IMAS NEKU PRIVITE INTERNAL ANALITIKU; ILI NESTO POTPUNO RAZLICITO STO NE ZELIS DA EXPOSE-UJES REST API-U

AKO IMAS ROUTE-OVE, TO NE ZNACI DA MORAS IMATI MODLE KOJI ID USA NJIMA

ALI ACORDING TO REST, RESOURCES ARE IN LINE SA NECIM STO ZELIS DA RADIS U DATBASE-U

*DA LI TREBAJU DA SE ZOVU ISTO?*

MOZDA BI TRBAL ODA IH ZOVES ISTO (TO SAVE PEOPLES SANITY), ALI MOZES URADITI STA GOD ZELIS; MOGU BITI VIRTUAL, ILI SOMETHING THAT CALLS SOMETHING ELSE

>> NA ROUTE-U SE MOZE ZVATI user, A NEGDE DRUGDE SE ZOVE person

ALI TO JE UOBICAJENO, KAKO SE STAVRI LINE-UJU UP: **RESOURCE LINES UP WITH A MODEL** I **MODEL JE KREIRAN OD SCHEMA-E**

## SCHEMAS SU INSTRUKCIJE ZA MODELE

NE MOZES KREIRATI MODEL BEZ TOGA DA PRVO NISI KREIRAO SCHEM-U

DA KLE SCHEMAS HOLD INSTRUKCIJE ZA MODELE KA OSTO SU: validations, names, indexes I hooks

## KADA PRAVIS MIGRATION, MORAS PROMENITI SCHEMA; JER SCHEMA JE EVERYTHING

## EVO KAKO IZGLEDA JEDNA SCHEMA

```javascript
import mongoose from 'mongoose'
import bcrypt from 'bcrypt'

// EVO OVO JE JEDNA SCHEMA

const userSchema = new mongoose.Schema(

  // DAKLE OVAJ OBJEKAT JE PROSLEDJEN U mongoose.Schema I TO JE BASICALLY A SCHEMA
  // OODNOSN ORETUEN-OVACE SE NOVA SCHEMA, IZ OVOGA

  {
    // AKO ZELIM DA KORISNIK IMA firstName, STAVLJAM TO U SCHEMA-A
    firstName: String, // String KONSTRUKTOR U OVO MSLUCAJU PREDSTAVLJA type ZA firstName

    // STO SE TICE LAST NAME-A, ZELIM DA ONO BUDE REQUIRED

    // ZATO JE SADA TYPE OBJEKAT
    // A  UTOM OBJEKTU DEFINISEM DA JE LAST NAME REQUIRED

    lastName: {
      type: String,
      required: true          // DAKLE SADA IMA I REQUIRED VALIDATION ON IT
    }

    // OVO ME SVE PODSECA NA TYPESCRIPT

  },
  { timestamps: true }
)
// DAKEL GORE SAM POKAZAO KAK OSE BUILD-UJE SCHEMA, KOJ UCU ONDA DA KORISTIM ,DA BIH KREIRAO MODEL


// NA OVO STO SE RADIL OSA bcrypt PAKETOM SADA NE MORAS OBRACATI PAZNJU, SAMO POSMATRAJ GORNJU SCHEME-U

userSchema.pre('save', function(next) {
  if (!this.isModified('password')) {
    return next()
  }

  bcrypt.hash(this.password, 8, (err, hash) => {
    if (err) {
      return next(err)
    }

    this.password = hash
    next()
  })
})

userSchema.methods.checkPassword = function(password) {
  const passwordHash = this.password
  return new Promise((resolve, reject) => {
    bcrypt.compare(password, passwordHash, (err, same) => {
      if (err) {
        return reject(err)
      }

      resolve(same)
    })
  })
}

// OVDE MOZES VIDETI KAKO SE KREIRA MODEL OD SCHEME

export const User = mongoose.model('user', userSchema)
```

I TAJ MODEL CE MI EVENTUALLY POMOCI U MOJIM CONTROLLER-IMA, KOJE CU EVANTUALLY BUILD-OVATI, A TI KONTROLERI CE DA IMAJU ATTACHED RESURSE KOJE CU EXPOSE-OVATI PREKO REST API-A

DAKLE SVE POCINJE SA SCHEMA-OM; DAKLE SVOJE PODAKE TI DIZAJNIRAS SA SCHEMA-MA; I ONDA IH KONVERTUJES U MODELE

ONDA KORISTIS MODELE ZA QUERYING I DEFINISES PERFORMING CRUD-A NA MODELIMA

I ONDA RESURS AKTIVIRAJU KONTROLERE, I TO JE TO; IMAS REST API

## OVDE U OVOM WORKSHOPU POSTOJE PRIMERI ZA SVE RAZLICITE POSSIBILITIES, KOJE SCHEMA MOZE URADIDITI SA Mongoose-OM

STO SE TICE MongoDB-JA I Mongoose-A, POSTOJI ONAJ DETALJAN WORKSHOP KOJI CU NARAVNO PROCI

ALI ODAVDE CE BITI SASVIM DOVOLJNO DA JA RAZUMEM STA SE USTVARI RADI

OVDE MOGU POGLEDATI DVE SCHEME, KOJE CU DEFINITIVNO EXPLORE-OVATI (OVO JE MUST, JER SU DETALJNO URADJENE)

So I already have examples of all the different possibilities this schema could do with Mongoose
