# OVDE ZELIM DA OBJASNIM *GENERIC CONSTAINTS*, NESTO BOLJE, JER MISLIM DA U LEKCIJI NISAM POCEO OD JEDNOSTAVNOG PRIMERA

:bangbang::bangbang: EVO, ZA POCETAK POGLEDAJ PRIMER KAKO U STVARI **NE MOZES** KORISTITI GENERICS

```typescript
interface Plain {
    model: string;
    wings: boolean
}

function plainFunction<T extends Plain>(flyingStuff: T){

    // OVAKO NESTO NE MOGU DA KORISTIM

    let nekaLokalnaVarijabla: T;

    nekaLokalnaVarijabla = {model: "cesna", wings: false};      // !! ---->        ERROR

    // ERROR GLASI OVAKO

    // !        Type '{ model: string; wings: false; }' is not assignable to type 'T'.
    // !        '{ model: string; wings: false; }' is assignable to the constraint of type 'T',
    // !        but 'T' could be instantiated with a different subtype of constraint 'Plain'

    // OVO IMA SMISLA JER JA ZAISTA JER SE NE ZNA KAKAV JE      T       USTVARI TYPE

    // I NA POMENUTI NACIN, JA NE BIH MOGAO KORISTITI GENERICS
}
```

**DAKLE, U GORNJEM PRIMERU *T* JE, NEDOVOLJNO ODREDJENOG TYPE-A, DA BIH JA MOGAO TAKO *loosely* KORISTITI**

**NAIME TO IMA SMISLA: *"ZASTO USTVARI RADITI NESTO NELOGICNO KAO STO JE ASSIGN-OVANJE VREDNSOT VARIJABLI ODREDJENOG TYPE, KADA ZNAS DA JE TAJ TYPE NEPOZNAT (ON JE TYPE VARIJABLA, ODNOSNO PARAMETAR)"***

**I JOS JEDNA STVAR JE NELOGICNA: *"TYPING NECEGA, SA TYPE PARAMETROM, I UPOTREBA TOG TYPE NA TAKAV NAIN DA JA USTVARI ZELI MDA SE BAVIM **`INTERNAL ENTITETIMA TOG TYPE-A`**"***

STO ME NAVODI DA DAM SLEDECI ZAKLJUCAK

## TYPE PARAMETAR, PA CAK IAKO SE KORISTI CONSTRAINTS, TREBA SAMO KORISTITI AKO ZELIS DA TAJ PARAMETER TYPE UPOTREBIS U, TAKORECI 'TYPE COMPOSITION-U' (MOJ TERMIN KOJI SAM LUPIO), ODNOSNO PRAVLJENJU DRUGIH TYPE-OVA U KOJIMA CE UCESTVOVATI TVOJ

DAKLE OPET NAPOMINJEM, NEMOJ NAIKAKO DA SE BAVIS VREDNOSCU TYPE-A, JER JE **OBIM DEKLARACIJE FUNKCIJE USTVARI AGNOSTIC OD TOGA, KOJI JE,ZAISTA TYPE, USTVARI *T*; JER JE *T* USTVARI PROMENLJIVA**

ZATO OVAKVA UPOTREBA TYPE PARAMETERA, KOJI IMA CONSTRAINTS JE DOBRA UPOTREBA

```typescript

```
