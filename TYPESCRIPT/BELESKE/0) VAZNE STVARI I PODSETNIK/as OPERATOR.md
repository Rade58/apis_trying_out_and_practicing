# as OPERATOR

DA ZAISTA, JE MOGUCE I MENJANJE TYPE-A, USTVARI TACNIJE JE RECI **NADOGRADNJE TYPE-A**, PO POTREBI

PODELICU OVA OBJASNJENJA NA DVA DELA

PRVO CE BITI BAVLJENJE, U OPSTEM SMISLU SA as-OM, A DRUGI DEO CU POSVETITI NIZOVIMA

## :one: as OPERATOR I 'RAZLICITE VERZIJE' JEDNOG TE ISTOG OBJEKTA

### MEDJUTIM PRE NEGO STO OBJASNIM STA SE POSTIZE SA as OPERATOROM, JA MORAM OBJASNITI, KADA TO JEDAN INTERFACE OVERLAP-UJE DRUGI

POSMATRAJ TO NA PRIMER-U

```typescript
// EVO OVDE CU PRVO KREIRATI DVA INTERFACE-A
// ALI S TIM STO JEDAN INTERFACE OVERALP-UJE DRUGI

// ODNOSNO TACNIJE JE RECI DA SE DVA INTERFACE-A OVERALAPUJU (JEDAN OVERLP-UJE DRUGI, ALI I DRUGE OVERLAPUJE TOG JEDNOG)

// STA TO USTVARI ZNACI?

// PA JEDAN INTERFACE, PORED SAMO SEBI SVOJSTVENIH DEFINICIJA TYPE-OVA
// * IMA I ONE DEFINICIJE TYPE-OVA, KOJE IMA I NEKI DRUGI INTERFACE

export interface Visnja {
    peteljka: boolean;
    boja: string;
    rok_upotrebe: number

    // IMA JEDAN OPCIONI TYPE (KOJ INIJE BITAN ZA OVERLAPING)
    tezina?: number
}

export interface Tresnja {
    // OVAJ INTERFACE IMA OVA DVA TYPE-A, KOJA SU NJEM USVOJSTVENA
    dzem: boolean;
    etikeata: string;

    // ALI IMA I DODATNE
    // SLEDECI TYPE-OVI KOJI OVAJ INTERFACE IMA, POTPUNO SU IDENTICNI PREDHODNOM INTERFACE-U
    // IZOSTAVLJAJUCI NARAVNO OPCIONE

    // ** ODNOSNO BOLJE JE RECI DA OVAJ INTERFACE OVERLAP-UJE, PREDHODNI
    rok_upotrebe: number;
    peteljka: boolean;
    boja: string
}
```

### UPRAVO ZBOG POMENUTE SITUACIJE OBA INTERFACE-A, BEZ OBZIRA KOJI OVERLAPUJE ILI JE OVERALPED BY, IMAJU DODATNE 'TYPING MOCI'

**OVO BUKVALNO ZNACI DA OBJEKAT, KOJI JE U SKLADU SA TAKVIM INTERFACE-OM IMA 'DVA LICA'** (A NEKAD I VISE, AKO POSTOJI SITUACIJA, PO KOJOJ GA OVERLAP-UJE VECI BROJ INTERFACE-OVA)

POSMATRAJ UPRAVO JEDAN OBJEKAT, KOJEM CU ZADATI TYPE ANNOTATION U SKLADU SA, GORE DEKLARISANIM Visnja INTERAFACE-OM

I JEDAN OBJEKAT, KOJEM CU ZADATI TYPE ANNOTATION U SKLADU SA, GORE DEKLARISANIM Tresnja INTERFACE-OM

```typescript
let dzemOdVisanja: Visnja = {
    peteljka: false,
    boja: "bordo",
    rok_upotrebe: 1948
};

let dzemOdTresanja: Tresnja = {
    dzem: false,
    etiketa: "devojka drzi teglu",
    rok_upotrebe: 2019
    peteljka: true,
    boja: "bordo"
};

// NAIME ZELIM DA OVOM OBJEKTU, KOJI JE OVERLAPED BY, DODAM, NOVI PROPERTI
// !!!!! ALI OVO CE PROUZROKOVATI TYPE ERROR
dzemOdVisanja.etiketa = "lepa devojka koja ima tresnjin cvet u kosi";                   // --> TYPING ERROR
// !!!!! NE MOZE DA PRIHVATI TAJ PROPERTI JER NIJE U SKLADU SA TYPE-OM      Visnja

// ALI CONVINIENT JE STO JE TAJ         etiketa         PROPERTI USTVARI PROPERTI U SKLADU SA
// Tresnja      INTERFACE-OM, KOJI OVERLAPUJE       Vuisnja     INTERFACE
```

**UPRAVO ZBOG TOGA OBJEKAT REFERENCED BY dzemOdVisanja VARIABLE, MOZE DA IMA JOS JEDNU VERZIJU**

ON MOZE DA POSEDUJE I PROPERTIJE SA TYPING-OM, KOJI SU U SKLADU SA Tresnja INTERFACE-OM

**OVDE TREBA VODITI RACUNA I SHVATITI DA SU NJEGOVE VERZIJE *AGNOSTIC* JEDNA U ODNOSU NA DRUGU**

*E TU UPRAVO NA SCENU STUPA **as** OPERATOR, I PO MOJOJ SLOBODNOJ INTERPRETACIJI, ON SE PONASA KAO **ACESSOR ONE DRUGE VERZIJE OBJEKTA, ONE VERZIJE KOJA JE U SKLADU SA DRUGIM INTERFACE-OM***

```typescript
// TO NE ZNACI DA SADA OBJEKAT dzemOdVisanja IMA PROPERTI     etiketa
// USTVARI IMA GA KADA JE U DRUGOJ VERZIJI

// !!!! ZATO BI OVO PROUZROKOVALO ERROR
console.log(dzemOdVisanja.etiketa);          // ---->    ERROR

// **** ALI OVO BI BILO SASVIM U REDU
console.log(
    (dzemOdVisanja as Tresnja).etiketa
);

// STO SE TICE ONOG DRUGOG OBJEKTA KOJI JE ONAJ KOJI OVERLAPUJE DRUGI
// I ON MOZE IMATI DRUGIU VERZIJU

console.log(        // IAK OJE OVO SASVIM KOREKTNO, JA OVOM OBJEKTU (OVOJ VERZIJI) NE MOGU DAVATI DODATNE PROPERTIJE (JER ONAJ OBJEKAT, KOJI
                    // JE OVERLAPED BY HIM, PO PRIRODI ISTVARI MU NE MOZE POZAJMITI NI JEDAN NOVI PROPERTI JER IH NEMA)
    (dzemOdTresanja as Visnja).etiketa
)

```

### TAKODJE NISTA ME NE SPRECAVA DA JA VERZIJU CUVAM U VARIJABLI, FOR QUICK REFERENCE

```typescript
let dzemOdTresanja_Tresnja_version =  dzemOdVisanja as Tresnja,

// I OVO JE SASVIM KOREKTNO
dzemOdTresanja_Tresnja_version.etikeata = "lepa devojka koja ima tresnjin cvet u kosi"
```

### ALI BEZ OBZIRA NA SVE NEMOJ UCI U ZABLUDU I POMISLITI DA SU DVE VERZIJE, USTVARI DVA RAZLICITA OBJEKTA; JER OVDE SE UVEK RADI O ISTOM OBJEKTU

```typescript
//  OVO CE DAKLE PRODUCE-OVATI          true

dzemOdTresanja_Tresnja_version === dzemOdVisanja;

```

### JOS JEDNA NAPOMENA BI SE ODNSILA NA TO DA NE IGNORISES KADA TYPESCRIPT OZNACI DA SI POGRESIO; TO GOVORIM JER BEZ OBZIRA TI POGRESIO ILI NE, AKO RUNN-UJES COMPILED JAVASCRIPT, ON CE SASVI MFUNKCIONISATI (JAVASCRIPT JE AGNOSTIC U ODNSU NA TYPE-OVE TYPESCRIPTA, I ZATO NECE PAZITI NA VERZIJE, JER BILO KOLIKO VERZIJA, RADI SE O JEDNOM OBJEKTU U JAVASCRIPTU, KOJI ONDA MOZE PRISTUPATI, I DEFINISATI BILO KOJI PROPERTI)

ALI IMAS KOD SEBE ONDA UVEK 'BROKEN TYPES' U SVOM TYPESCRIPT FAJLU (I CEMU ONDA TYPESCRIPT)

ZATO NIKAD NE IGNORISI NI JEDNU GRESKU KOJU TI JAVLJA TYPESCRIPT

### ON OSTO SAM MOZDA PRESKOCIO A STO JE MOZDA VAZNO JESTE 'SLUCAJ EMPTY OBJEKTA' (OVO SAMO PO SEBI NISTA NIJE POSEBNO, A NI POTREBNO, A VIDECES NA KRAJ UPODNASLOVA I ZASTO JE TAKO)

*TO USTVARI NIJE NIKAKAV, POSEBAN SLUCAJ SLUCAJ, VEC MOZDA NACIN NA KOJI SE MOZE KORISTITI as SINTAKSA*

EVO I PRIMER-A

```typescript
interface Alkohol {
    jacina: number;
    ime: string;
    poreklo: string;
    dozvoljeno?: boolean
}

// OVDE NISTA NIJE SPORNO
// DOK NE POKRIEM SVE TYPE-OVE U SKLADU SA Alkohol INTERFACE-OM, IMAO BIH ERROR MESSAGE (PODVUCEN CODE)
let cognaque: Alkohol = {
    jacina: 680,
    ime: "bourbone",
    poreklo: "french"
}

// *** ja naime mogu odmah koristiti *  as   * sintaksu pri inicijalizaciji

// JER PRAZAN OBJEKAT JESTE TYPE-A, KOJI OVERLAP-UJE BILO KOJI DRUGI  
let wiskey = {} as Alkohol;         // ZATO MI JE OVO DOZVOLJENO

// SADA ZA RAZLIKU OD    cognaque   OBJEKTA       wiskey        OBJEKAT, MOZE PRIMATI
// PROPERTIJE ON THE RUN
// SVE DOK POTPUNO NE IZGRADI OBJEKAT, U SKALDI SA      alkohol         INTERFACE-OM

wiskey.ime = "Glendlough";
wiskey.jacina = 80000;
wiskey.poreklo = "irish";
wiskey.dozvoljeno = true;

// NARAVNO BIL OKOJI NOVI PROPERTI NE BIH MOGAO DODATI wiskey-U, JER BI TO NE BI BILO U SKLADU SA Aljkohol INTERFACE-OM
```

*U SUSTINI POMENUTO STO SAM DEFINISAO NIJE NI BITNO, JER MI JE OVO DOZVOLJENO*

```typescript
let rucak: Jelo;        // MOGU PRESKOCITI INICIJALIZACIJU, ALI ZADATI TYPE NOTATION

rucak.ime = "rucak";
rucak.kolicina = 280;
```

### unknown TYPE; ODNOSNO MOGUCE JE 'PREVARITI' UNSUFFICIENT OVERLAPING, I TO KORISCENJEM unknown TYPE-A, ILI any TYPE, MEDJUTIM TYPESCRIPT SUGERISE (PRILIKOM HOVERINGA PREKO ERROROUS CODE-A), DA KORISTIM IPAK unknown

```typescript
// EVO PAR INTERFACE-OVA KOJI IMAJU UNSUFFICIENT OVERLAPING
interface Pice {
    alkoholno: boolean;
    temperatura: number
    ime: string,
    cena?: number,
}

interface Jelo {
    ime: string;
    temperatura: number
    poreklo: string,
    kolicina?: number,
}

// JASNO JE DA PREDHODNA DVA INTERFACE-A NISU OVERLAPING
// DA BI TO BILI, ILI Jelo BI MORALO DA IMA DEFINSIAN TYPE ZA alkoholno
// ILI BI Pice MORALO DA IMA TYPE ZA poreklo 

let vecera :Jelo = {
    ime: "steak",
    temperatura: 140,
    poreklo: "britain"
}

// !!!!!     OVO BI ZATO PROUZROKOVALO ERROR
let dorucak = vecera as Pice;                   // -->  ERROR

// *** MOGAO BIH URADITI NESTO OVAKO, AKO BI ZELO DA ISKORITIM vecera OBJEKAT
let rucak = (vecera as unknown) as Pice;
// ****  ILI OVAKO
let uzina = (vecera as any) as Pice;

// I ONDA BIH MOGAO DEFINISATI PROPERTIJE U SKLADU SA Pice INTERFACE-OM
uzina.alkoholno = true;
rucak.alkoholno = false;
```

**POSTO MI JE SVE OVO JAKO NOVO, NE ZNAM JOS DA LI JE OVO NEKA PRAKSA KORISCENJA ALI IPAK JE DOBRO DA SAM PROVEZBAO**

## :two: MOGU PROSIRITI 'as PRICU' I NA NIZOVE

### PRVO MALI PODSETNIK ZA NIZOVE I TYPOVE

```typescript
// EVO PAR INTERFACE-OVA
interface Pice {
    alkoholno: boolean;
    ime: string,
    cena?: number
}

interface Jelo {
    ime: string;
    poreklo: string,
    kolicina?: number
}

// TYPE OVOG PROPERTIJA JESTE NIZ, CIJI CLANOVI IMAJU       Pice        TYPE NOTATION
// ILI  NIZ CIJI CLANOVI IMAJU       Jelo        TYPE NOTATION
// NIZ MOZE BITI PRAZAN JER         NEMAS OGRANICENJE ZA LENGTH
let dorucak: Pice[] | Jelo[] = [];
// ALI U SLUCAJU PREDHODNOG NIZA, NE MOGU MESATI CLANOVE SA DVA TYPE-A
// TO DAKLE MORA BITI NIZ ILI SA JEDIN TYPE-OM ILI SA DRUGIM

// ALI AKO ZELIM DA MESAM TYPE-OVE, MOGU DEFINISATI NIZ, U KOJI MOGU STAVLJATI CLANOVE RAZLITIH ANNOTATED TYPE-OVA
let rucak: (Pice | Jelo)[] = [];


// PRI OVAKVOJ TYPE NOTATACIJI, VELICINA NIZA JE OGRANICENA
// ZA OVAJ PRIMER, PRI INICIJALIZACIJI MORAM IMATI NIZ OD TACNO TRI CLANA
// ALI POSTO IMA MCONDITIONAL, MOGU BIRATI IZMEDJU DVE OPCIJE U POGLEDU
// TYPE-OVA ZA CLANOVE NIZA
let vecera: [Pice, Pice, Jelo] | [Jelo, Pice, Jelo] = [
    // izabrao sam prvu opciju za ovaj objekat
    {alkoholno: false, ime: "kokta"},
    {alkoholno: true, ime: "wiskey", cena: 4800},
    {ime: "steak", kolicina: 200, poreklo: "french"}

];

```

### NISTA NIJ SPORNO IZ GORNJEG CODE-A, ALI HAJDE DA SADA UPOTREBIM as OPERATOR

