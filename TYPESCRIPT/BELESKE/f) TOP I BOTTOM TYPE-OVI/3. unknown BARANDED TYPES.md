# TYPE-OVI MARKIRANI, KAO unknown

POSTOJI NESTO UNSETTLING U VEZAI OVAKVIH TYPE-OVA

POGLEDAJ PRIMER

```typescript
// IMAM DVE unknown VARIJABLE, ALI KAD POGLEDAM NJIHOVU VREDNSOT, VIDIM DA SU POTPUNO DRUGACIJEG 
// TYPE-A

let foo: unknown = 48;

let bar: unknown = ["blah", "nesto drugo"];


// NISTA ME NE SPRECAVA DA URADIM OVAKO NESTO
foo = bar;      // !!!     *NIJE JAVLJENA*      NIMKAKAVA GRESKA

```

## UPRAVO IZ GORE POMENUTOG RAZLOGA JAVLJA SE POTREBA DA SE KORISTI NESTO STO SE ZOVE *BRANDED TYPE*

POCECU OD PRIMERA

```typescript
// IMAM JEDAN INTERFACE, KOJI IMA JEDAN SPECIAL PROPERTI

// OVAKAV INTERFACE IMAM VEOMA MALO SANSE DA SE OVERLAPP-UJE SA BILO KOJIM DRUGIM INTERFACE-OM
// KOJI DESCRIBE-UJE NEKI DRUGI OBJEKAT

interface BrandedA {
    _ovo_je_branded_sa_a: "a";
}



// U SUSTINI SADA CU KREIRATI JEDNU FUNKCIJU, KOJA CE 'MARKIRATI' ODREDJENI TYPE, KAO      BarndedA
// I KREIRACU DRUGU FUNKCIJU, KOJA CE 'DEMARKIRATI' BrandedA TYPE

function brandA(val: string): BrandedA {

    return (val as unknown) as BrandedA;

}


function unbrandA(val: BrandedA): string {

    return (val as unknown) as string;

}
```

AUTOR WORKSHOPA KAZE DA BI TIPICALLY, OVO BILO UNSAFE

TO SE USTVARI ZOVE TYPE CASTING

JA USTVARI FORCE-UJEM VALUE DA BUDE ODREDJENI TYPE

U GORNJEM PRIMERU JASNO JE DA SE string I BrandedA NEMAJU SIGNIFICANT OVERLAPPING; I ZATO KORISTIM unknown, PRI 'KONVERZIJI', ODNOSNO PRETVARAM TYPER U unknown DA BI SA unknown-A, MOGAO PRETVORITI U DRUGI TYPE

**A DOZVOLJENO MI JE TYPING U unknown, ZATO STO JE unknown, TOP TYPE** (TO NE TREBAM DA ZABORAVIM)

**NAIME JA SAM U GORNJEM PRIMERU TAKORECI 'PREVARIO TYPESCRIPT', CINECI DA ZA NJEGA string IZGLEDA KAO OBJEKAT SA SPECIJALNIM PROPERTIJEM**

**A U DRUGOJ FUNKCIJI, URADIJO SAM SAMO INVERZIJU POMENUTOGA**

*CEMU TO, KADA NIKO NECE MOCI DA UPOTREBI OBJEKAT, KAO STRING AND VICE VERSA*?

DAKLE DA SE PRVO SLOZIM SA TIM DA TAJ OBJEKAT JESTE OPAQUE USTVARI (ON NIJE STRING, I NE MOGU DA RADIM STRING STVARI SA NJIM)

EVO STA JE ADVANTAGE

POKAZACU GA, USVARI NAKON STO KREIRAM JOS JEDAN 'SPECIJALNI' INTERFACE

```typescript

interface BrandedB {
    _ovo_je_branded_sa_b: "b";
}

function brandB(value: {properti: string}): BrandedB {

    return (val as unknown) as BrandedB;

}

function unbrandB(value: BrandedB): {properti: string} {

    return (value as unknown) as {properti: string};

}
```

**SADA CU KREIRATI DVE VARIJABLE INFERED TYPE-OVA** (OVAKO SAMO POCINJEM DA MI STVARI BUDU OCITE KADA IH POSMATRAM)

**JEDAN TYPE CE BITI string, A DRUGI CE BITI {properti: string}**

```typescript
let aString = "neki string";

let bObjekat = {properti: "neki string blah"}


// I NIJE SPORNO, DA CE OVO PROUZROKOVATI ERROR

aString = bObjekat      // ----> ERROR

// HAJDE SADA DA OVE ENTITETE BRAND-UJEM RESPEKTIVNO

let brandedA = brandA(aString);             // KADA HOVERUJEM VIDECU DA JE brandedA TYPE-A BrandedA 

let brandedB = brandB(bObjekat);            // KADA HOVERUJEM VIDECU DA JE brandedB TYPE-A BrandedB


// OVO CE DATI ERROR (I TO JE JASNO)

brandedA = brandedB     // ----> ERROR


// A MOGU SE VRATITI NA TYPE-OVE, kakvi bi postojali da nisam originalne varijable type-ovao kao undefined

let unbrandedA = unbrandA(brandedA);
let unbrandedB = unbrandB(brandedB)

// I OVO JE ONO STA MI ODGOVARA

unbrandedA = unbrandedB         // -----> ERROR


```
