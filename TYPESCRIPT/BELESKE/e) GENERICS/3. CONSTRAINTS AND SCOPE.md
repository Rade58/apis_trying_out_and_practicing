# CONSTRAINTS AND SCOPE

TYPE PARAMETERS TAKODJE MOGU IMATI CONSTRAINTS

## ODMAH ZELIM DA SE POZABAVIM KONKRETNIM PRIMEROM

[PRE TOGA SE MALO PODSETI NA TUPLES, ARRAYS, I INDEX SIGNATURE](https://github.com/Rade58/apis_trying_out_and_practicing/blob/master/TYPESCRIPT/BELESKE/0%29%20VAZNE%20STVARI%20I%20PODSETNIK/INDEX%20SIGNATURE%20AND%20OTHER.md#ovde-zelim-da-se-pozabavim-index-signature-om-ali-takodje-i-da-pregledam-osobine-array-eva-i-tuple-ova)

TAMO SAM SE NA KRAJU DOTAKAO I DICTIONARY OBJEKAT-A (NA SAMOM KARAJU), TO KAZEM JER CE ONI UCESTVOVATI U OVOM PRIMERU

TREBALO BI JOS JEDNOM DA SE POSVETIS [INFERED TYPE-OVIMA](https://github.com/Rade58/apis_trying_out_and_practicing/blob/master/TYPESCRIPT/BELESKE/0%29%20VAZNE%20STVARI%20I%20PODSETNIK/INFERED%20TYPE.md#infered-type)

SA [POMENUTOG LINKA](https://github.com/Rade58/apis_trying_out_and_practicing/blob/master/TYPESCRIPT/BELESKE/0%29%20VAZNE%20STVARI%20I%20PODSETNIK/INFERED%20TYPE.md#ali-obrati-paznju-kada-assign-ujes-object-literal) NAROCITO JE VAZNO DA ZNAS STA SE DOGADJE AKO ASSIGN-UJES OBJECT LITERAL, EKSPLICITNO TYPED VARIJABLI

KADA KAZEO OBJECT LITERAL MISLIM NA ASSIGNEOVANJE VREDNOSTI, KOJA IZGLEDA OVAKO `{properti: vrednsot...}`, I KOJA NIJE EKSPLICITNO TYPED

### :one: SADA CU DEFINISATI PRIMER, U KOJEM CU KREIRATI FUNKCIJU, CIJE CILJ DA OD ARRAY-A (CIJI SU CLANOVI GENERIC TYPE-A), USTVARI NAPRAVI DICTIONARY :exclamation:

```typescript
function NizToRecnik<T>(arrayOfGenerics: T[]): {[name: string]: T} {

    const output: {[name: string]: T} = {}

    // NAIME, POTREBA, DA BI UOPSTE MOGAO DA FORMISRAM DICTIOANRY
    // JESTE IME ZA PROPERTI, KOJI TREBAM DA DODAM

    // IDEJA JE DA TO BUDE id; STO ZNACI DA CE     T        BITI TAKAV
    // TYPE DA MORA DA IMA PROPERTI id

    arrayOfGenerics.forEach(t => {
        output[t.id] = t;               // !!!! OVDE CU IMATI ERROR JER NISAM TYPE-OVAO     T       NA TAKAV
                                        // !!!! NACIN DA ON UOPSTE IMA id PROPERTI (KOJI NARAVN OTREBA DA BUDE string TYPE-A)
    })                                  // id CE BITI PODVUCENO OD STRANE TYPESCRIPT-A


    return output;

}
```

### :two: GORE POMENUTI PROBLEM MOGU PREVAZICI, NA TAJ NACIN STO CU extend-OVATI *T* (TYPE PARAMETER), I TO SA INTERFACE-OM, KOJI DESCRIBE-UJE OBJEKAT SA PROPERTIJEM id I NJEGOVIM TYPE-OM

```typescript
                        // EVO POGLEDAJ KAKAO SAM EXTEND-OVAO TYPE PARAMETER
function nizToRecnik<T extends {id: string}>(arrayOfGenerics: T[]): {[name: string]: T} {

    const output: {[name: string]: T} = {}

    arrayOfGenerics.forEach(t => {
        output[t.id] = t;               // **** SADA OVDE VISE     *  NEMA  *     ERRORO-A
    })

    return output;

}

```

POENTA JE BILA DAKLE U TOME DA TYPRE PARAMETER (GENERIC TYPE) NIJE IMAO DOVOLJNO DOBE DEFINISANE REQUIREMENTS, I JA SAM ZATO MORAO DEFINISATI DA **T** JESTE TYPE KOJI PROSIRUJE INTERFACE, KOJI IMA JEDAN PROPERTI *id*, KOJI JE **string** TYPE-A

### :three: MEDJUTIM DA JA NISAM U GORNJEM PRIMERU KORISTITIO GENERIC, KOJI EXTEND-UJE INTERFACE, NAISAO BIH NA TAKAKV PROBLEM DA BI MOJ CODE POSTAO GLOMAZAN

POGLEDAJ

```typescript
// SADA SAM DOLE KAO STO SE VIDI ELIMINISAO GENERIC I TYPE

// SVUDA GDE JE, RANIJE BILO        T       ,SADA SE NALAZI         {id: string}

function nizToRecnik(arrayOfGenerics: {id: string}[]): {[name: string]: {id: string}} {

    const output: {[name: string]: {id: string}} = {}

    arrayOfGenerics.forEach(t => {
        output[t.id] = t;
    })

    return output;

}
```

### :four: ALI U GORNJEM PRIMERU, NAKO NSTO SAM GA REDEFINISAO, DOBIO SAM PROBLEM