# GENERICS

*GENERICS PARAMETARIZUJU TYPE-OVE, NA ISTI NACIN KAO STO FUNKCIJE PARAMETARIZUJU VREDNOSTI*

## EVO MOZES ODMAH DA POSMATRAS JEDAN INTERFACE

```typescript
interface WrappedValue<X> {

    value: x;

}
```

JASNO TI JE KAKO BI SE GORE MOGA OFORMIRATI TYPE ZA value

ALI EVO TI KONKRETAN PRIMER

```typescript
let bar: WrappedValue<string[]> = {value: []}

let otherValue: WrappedValue<string[]>;

otherValue = {value: []}

```

DA INTERPRETIRAM

*UPOTREBLJENI INTERFACE TYPE-UJE VARIJABLU KAO OBJEKAT TYPE (STO JE NARAVNO OCIGLEDNO) A TAKODJE PROSLEDJUJE TYPE: 'NIZ OD STRINGOVA', KAO TYPE, KOJI MOGU KORISTITI PROPERTIJI OBJEKTA, A ZA SADA TO JE SAMO value PROPERTI*

NARAVNO ZA POCETAK ZNAM DA NIZ MOZE BITI PRAZAN

ONO STO JE PROSLEDJENO KROZ **<>** SE USTVARI NAZIVA *GENERICNIM TYPE-OM*

## KONVENCIJA, KOJU MOZES VIDETI JESTE DA SE CAPITAL LETTER `T` DEFINISE KAO IME TYPE PARMAETRA

OVA KONVENCIJA JE PREUZETA IZ C++

## POSTOJI I MOGUCNOST ZADAVANJA DEFAULT TYPE-OVA

POGLEDAJ PRIMER

```typescript
// OVO JE PRIMER KOJI SE MOZE KORISTITI ZA      TYPING       ARGUMENT CALLBACK-A
// Array.prototype.filter    METODE

interface FilterFunction<T = any> {
    (val: T): boolean;

    // DA INTRTPRETIRAM:

    // GORE JE UPITANJU DESCRIBING CALL SIGNATURE-A

    //      PARAMETAR FUNKCIJE JE TYPE-A        T
    //      POVRATNA VREDNSOT JE TYPE-A         BOOLEAN
}


```

MOGU I DA TESTIRAM

```typescript

const fil:FilterFunction<string> = x => typeof "string" === x

// testiram funkciju
fil("blah");  // **     U REDU
fil(8);       // !!     ERROR

// DAKLE POMENUTI TYPE ODGOVARA FUNKCIJI CIJI PARAMETAR JE TRING

```
