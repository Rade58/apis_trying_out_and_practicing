# TYPE PARAMETERS

OPET DA SE OVDE OSVRNEM NA DEFAULT TYPE PARAMETERS

```typescript
interface BlahFunction<T = any> {

    (param: T): boolean

}

// NA PRIMER AKO NE PROSLEDIS NISTA KADA KORISTIS OVAJ INTERFACE, any CE BITI FALLBACK



const blahFunction: BlahFunction = value => true

//** * I TADA   NECE DOCI DO ERRORA   U SVIM OVIM SLUCAJEVIMA

blahFunction(8);
blahFunction(undefined);
blahFunction("neki string")
```

## :bangbang::bangbang::bangbang::bangbang: MEDJUTIM PRIMETIO SAM JEDNU, ZA MENE NELOGICNOST U VEZI KORISCENJA *DEFAULT TYPE PARAMETRA*, KADA DESCRIBE-UJEME TYPE *CALL SIGNATURE-A*

KONKRETNO PROBLEM NASTAJE U VEZI TYPE-A, ZA POVRATNU VREDNOST

```typescript


interface FooFunk<T = any> {

    // TVOJA PREDPOSTAVKA BI BILA
    // DA FUNKCIJA KOJA JE DESCRIBED SA OVIM SIGNATURE-OM, BEZ OBZIRA NA T
    // MORA IMATI string KAO TYPE

    (par: T): string

    // !!!! ALI NIJE TAKO KADA KORISTIM FALLABCK (KADA NE PROSLEDIM TYPE PARAMETAR)

}

// EVO POSMATRAJ OVU FUNKCIJU, KOJ USAM TYPE-OVAO SA GORNJIM INTERFACE-OMA, A
// PRI UPOTREBI INTERFACE-A NISAM PROSLEDIO GENERIC

const fooFunk: FooFunk = val => val             // NEMA NIKAKVOG ERROR-A

// PREDPOSTAVIO BIH DA ZATO STO POVRATNA VREDNOST JESTE SADA any (STO MOZES VIDETI HOVERINGOM PREKO VREDNSTI)
// JER JE I PARAMETAR any
// DA BI TO DOVELO DO ERRORA, JER JE POVRATNA VREDNSOT TYPED KAO        string   U INTERFACE-U

// ** MEDJUTIM IZGEDA DA KORISCENJE DEFAULT TYPE PARAMETRA 'BREAK-UJE' TYPE I ZA POVRATNU VREDNOST
```

NECU DODATNO KOMENTARIATI OVU NELOGICNOST (BAR JE ZA MENE NELOGICNO), VEC CU SE TRUDITI DA OVO ZAPAMATIM

**USTVARI DOSAO SAM DO OBJASNJENJA**

- U, KONKRETNO GORNJEM PRIMERU, POSTO PARAMETAR JESTE TYPED SA any, A TA JPARAMETAR SE PROSLEDJUJE KAO POVRATNA VREDNOST (ZAKLJUCAK BI BIO DA TAJ PARAMETAR, MOZE BITI I string (TYPE ZA POVRATNU VREDNOST)); I ZATO TYPESCRIPT NECE 'DA VICE NA MENE'

**ALI IPAK NE VIDIM DA JE USTVARI CINJENJE POMENUTOGA (ODNOSNO NE PROSLEDJIVANJE TYPE-A, TYPE PARAMETRU) U REDU, JER OVO SLEDECE NE BI DALO NIKAKAV ERROR**

```typescript
fooFunk(8)      // *** NEMA ERRORA   // !!! A TRBAL OBI DA GA BUDE, JER SAM TYPE-OVAO POVRATNU VREDNSOT KAO STRING
```

POVRATNA VREDNOST CE DAKLE BITI number, IAKO SAM JE TYPE-OVAO KA OSTRING (DAKLE NIJE U REDU, I JA NE VIDIM DA JE POMENUTI NACIN DEFINISANJA IKAKO KORISTAN)

## TYPE PARAMETAR SE NE MORA SAMO DEFINISATI ZA INTERFACE; NA PRIMER, ON SE MOZE DEFINISATI I NA FUNKCIJI

```typescript
// EVO POSMATRAJ OVU FUNKCIJU

function blahBaz<T>(a: T | boolean): T | boolean {

    return a;

}

// a PARAMETAR MOZE BITI TYPE, KOJEG PROSLEDIM ZA   T   ILI     boolean

// POVRATNA VREDNSOT MOZE BITI ISTOG TAKVOG TYPE-A

blahBaz<string>(true);

blahBaz<string>("foo bar baz");

blahBaz<string>(68);        // !      -->   ERROR

```

## :bangbang::bangbang::bangbang::bangbang: PROBLEMATICNO MI JE DA WRAPP-UJEM MY MIND AROUND: KORISCENJE GENERICS-A, ZAJEDNO SA NECIM STO VEC POSTOJI, KAO API, KAO STO JE NAPRIMER Promise

- **`Promise<T>`**

**STA PREDSTAVLJA T OVDE** *?*

>>>>> DA LI PREDSTAVLJA TIP ONE VREDNOSTI SA KOJOM JE RESOLVED/REJECTED PROMISE, ILI PREDSTAVLJA TYPE ZA RESOLVE/REJECT CALLBACKS, ILI PREDSTAVLJA TYPE ZA Promise-OV DIREKTNI CALLBACK, KOJEM SU RESOLVE REJECT FUNKCIJE ARGUMENI

ALI IPAK KADA SE NAPISE OVAKO NESTO:

- **`Promise<number>`**

TO ZNACI DA TYPE VREDNOSTI, KOJOM PROMISE TREBA DA SE RESOLVE-UJE, JESTE number

MOGU TO DA STAVIM NA TEST

```typescript
let somePromise: Promise<string>;

somePromise = new Promise((res, rej) => {
    res("foo bar baz");     // ** OVO BI TREBALO DA BUDE U REDU
})


let someOtherPromise: Promise<number> = Promise.resolve("bar baz");         // !!!! -->     ERROR
```

*DOBRO UTVRDIO SAM DA JE ONO PROSLEDJENO KAO GENERIC TYPE USTVARI TYPE VREDNSOTI SA KOJOM PROMISE TREBA DA BUDE RESOLVED*

A KOJI TYPE ZADATI, AKO ZELIM Promise, KOJI SE RESOLVE-UJE SA void

```typescript
// OVO JE SASVIM VALIDNO
let promBlah: Promise<void> = Promise.resolve();

// ALI AKO NAPISEM DA ZELIM IDA SE PROMISE RESOLVE-UJE SA undefined
// JA CU undefined MORATI PROSLEDITI
let probBlah2: Promise<undefined> = Promise.resolve(undefined);

// CISTO POMENUTO NAPOMINJEM, AKO UPADNEM U ZABLUDU
```
 
## U SLEDECEM PRIMERU CU KORISTITI Promise, ALI ON OSTO CU OVOG PUTA RADITI, JESTE DA CU KORISTITI TYPE PARAMETER ZA FUNKCIJU


**KADA RAZMISLIM O OVOME, LAKSE MI JE DA WRAPP-UJEM MY MIND AROUND TYPE PARAMETER I Promise, JER SU AUTORI TYPESCRIPT-A UPRAVO DEFINISALI DA SE ZA PROMISE PROSLEDJUE TYPE ARGUMENT, NA DEFINISANI NACIN**

*MOGU TO ZAMISLITI ISTO KAO DA SU ONI DEFINISALI FUNKCIJU POPUT MOJE SA MOGUCNOSTU PASSINGA-A TYPE ARGUMENTA*