# TYPE PARAMETERS

OPET DA SE OVDE OSVRNEM NA DEFAULT TYPE PARAMETERS

```typescript
interface BlahFunction<T = any> {

    (param: T): boolean

}

// NA PRIMER AKO NE PROSLEDIS NISTA KADA KORISTIS OVAJ INTERFACE, any CE BITI FALLBACK



const blahFunction: BlahFunction = value => true

//** * I TADA   NECE DOCI DO ERRORA   U SVIM OVIM SLUCAJEVIMA

blahFunction(8);
blahFunction(undefined);
blahFunction("neki string")
```

## :bangbang::bangbang::bangbang::bangbang: MEDJUTIM PRIMETIO SAM JEDNU, ZA MENE NELOGICNOST U VEZI KORISCENJA *DEFAULT TYPE PARAMETRA*, KADA DESCRIBE-UJEME TYPE *CALL SIGNATURE-A*

KONKRETNO PROBLEM NASTAJE U VEZI TYPE-A, ZA POVRATNU VREDNOST

```typescript


interface FooFunk<T = any> {

    // TVOJA PREDPOSTAVKA BI BILA
    // DA FUNKCIJA KOJA JE DESCRIBED SA OVIM SIGNATURE-OM, BEZ OBZIRA NA T
    // MORA IMATI string KAO TYPE

    (par: T): string

    // !!!! ALI NIJE TAKO KADA KORISTIM FALLABCK (KADA NE PROSLEDIM TYPE PARAMETAR)

}

// EVO POSMATRAJ OVU FUNKCIJU, KOJ USAM TYPE-OVAO SA GORNJIM INTERFACE-OMA, A
// PRI UPOTREBI INTERFACE-A NISAM PROSLEDIO GENERIC

const fooFunk: FooFunk = val => val             // NEMA NIKAKVOG ERROR-A

// PREDPOSTAVIO BIH DA ZATO STO POVRATNA VREDNOST JESTE SADA any (STO MOZES VIDETI HOVERINGOM PREKO VREDNSTI)
// JER JE I PARAMETAR any
// DA BI TO DOVELO DO ERRORA, JER JE POVRATNA VREDNSOT TYPED KAO        string   U INTERFACE-U

// ** MEDJUTIM IZGEDA DA KORISCENJE DEFAULT TYPE PARAMETRA 'BREAK-UJE' TYPE I ZA POVRATNU VREDNOST
```

NECU DODATNO KOMENTARIATI OVU NELOGICNOST (BAR JE ZA MENE NELOGICNO), VEC CU SE TRUDITI DA OVO ZAPAMATIM

**USTVARI DOSAO SAM DO OBJASNJENJA**

- U, KONKRETNO GORNJEM PRIMERU, POSTO PARAMETAR JESTE TYPED SA any, A TA JPARAMETAR SE PROSLEDJUJE KAO POVRATNA VREDNOST (ZAKLJUCAK BI BIO DA TAJ PARAMETAR, MOZE BITI I string (TYPE ZA POVRATNU VREDNOST)); I ZATO TYPESCRIPT NECE 'DA VICE NA MENE'

**ALI IPAK NE VIDIM DA JE USTVARI CINJENJE POMENUTOGA (ODNOSNO NE PROSLEDJIVANJE TYPE-A, TYPE PARAMETRU) U REDU, JER OVO SLEDECE NE BI DALO NIKAKAV ERROR**

```typescript
fooFunk(8)      // *** NEMA ERRORA   // !!! A TRBAL OBI DA GA BUDE, JER SAM TYPE-OVAO POVRATNU VREDNSOT KAO STRING
```

POVRATNA VREDNOST CE DAKLE BITI number, IAKO SAM JE TYPE-OVAO KA OSTRING (DAKLE NIJE U REDU, I JA NE VIDIM DA JE POMENUTI NACIN DEFINISANJA IKAKO KORISTAN)

## TYPE PARAMETAR SE NE MORA SAMO DEFINISATI ZA INTERFACE; NA PRIMER, ON SE MOZE DEFINISATI I NA FUNKCIJI

```typescript
// EVO POSMATRAJ OVU FUNKCIJU

function blahBaz<T>(a: T | boolean): T | boolean {

    return a;

}

// a PARAMETAR MOZE BITI TYPE, KOJEG PROSLEDIM ZA   T   ILI     boolean

// POVRATNA VREDNSOT MOZE BITI ISTOG TAKVOG TYPE-A

blahBaz<string>(true);

blahBaz<string>("foo bar baz");

blahBaz<string>(68);        // !      -->   ERROR

```

## :bangbang::bangbang::bangbang::bangbang: PROBLEMATICNO MI JE DA WRAPP-UJEM MY MIND AROUND: KORISCENJE GENERICS-A, ZAJEDNO SA NECIM STO VEC POSTOJI, KAO API, KAO STO JE NAPRIMER Promise

- **`Promise<T>`**

**STA PREDSTAVLJA T OVDE** *?*

>>>>> DA LI PREDSTAVLJA TIP ONE VREDNOSTI SA KOJOM JE RESOLVED/REJECTED PROMISE, ILI PREDSTAVLJA TYPE ZA RESOLVE/REJECT CALLBACKS, ILI PREDSTAVLJA TYPE ZA Promise-OV DIREKTNI CALLBACK, KOJEM SU RESOLVE REJECT FUNKCIJE ARGUMENI

ALI IPAK KADA SE NAPISE OVAKO NESTO:

- **`Promise<number>`**

TO ZNACI DA TYPE VREDNOSTI, KOJOM PROMISE TREBA DA SE RESOLVE-UJE, JESTE number

MOGU TO DA STAVIM NA TEST

```typescript
let somePromise: Promise<string>;

somePromise = new Promise((res, rej) => {
    res("foo bar baz");     // ** OVO BI TREBALO DA BUDE U REDU
})


let someOtherPromise: Promise<number> = Promise.resolve("bar baz");         // !!!! -->     ERROR
```

*DOBRO UTVRDIO SAM DA JE ONO PROSLEDJENO KAO GENERIC TYPE USTVARI TYPE VREDNSOTI SA KOJOM PROMISE TREBA DA BUDE RESOLVED*

A KOJI TYPE ZADATI, AKO ZELIM Promise, KOJI SE RESOLVE-UJE SA void

```typescript
// OVO JE SASVIM VALIDNO
let promBlah: Promise<void> = Promise.resolve();

// ALI AKO NAPISEM DA ZELIM IDA SE PROMISE RESOLVE-UJE SA undefined
// JA CU undefined MORATI PROSLEDITI
let probBlah2: Promise<undefined> = Promise.resolve(undefined);

// CISTO POMENUTO NAPOMINJEM, AKO UPADNEM U ZABLUDU
```

**ALI STA JE SA REJECTED TYPE-OM, ODNOSNO SA TYPEOM VREDNSOTI SA KOJOM JE REJECTED Promise**

E TA VREDNSOT SA KOJOM JE Promise REJECTED NE MOZE DA IMA TYPE

**USTVARI NE MOZE IMATI TYPE ZATO STO Error JESTE IMPLICITNO TYPED KAO *any***, A KADA JE PROMISE REJECTED, ERROR JE THROWN

>>>> The error is implicitly of type **any**

>>>> And is not specified in the Promise generic type (AKO POKUSAM DA PROSLEDIM VISE TYPE-OVA KROZ PROMISE-OV GENERIC, TO NECE IMATI NIKAKVOG EFEKTA)

```typescript
let someProm: Promise<string> = Promise.reject(8)      // OVO CE SAMO PO SEBI DATI ERROR
                                                       // ALI U POGLEDU TYPESCRIPT-A
                                                       // ON KONKRETNO NISTA nece
                                                       // 'VIKATI' NA MENE

// !! ALI ZATO BI TYPESCRIPT ZBOG OVOGA 'YELLED AT ME'

let someProm2: Promise<number> = Promise.reject(8).catch(8)

// !! STO SE TICE OVAKVOG CHAINING-A, TO NE BI DALO NIKAKVOG EFEKTA U POGLEDU TYPE-OVA
// JER JE TYPE ZADAT SOM ZA somProm VARIJABLU

someProm.catch(broj => (broj | Math.random()))

// * JER ONO STO CE SADA PROIZICI JESTE NOVI Promise KOJI NEMA NIKAKAV EKSPLICITNI TYPING

```

## U SLEDECEM PRIMERU CU KORISTITI TYPE PARAMETER ZA FUNKCIJU, ALI PRIMER CE BITI NESTO KOMPLEKSNIJI, NEGO TAMO GDE SAM SAMO POKAZAO DA SE TYPE PARAMETAR MOZE KORITITI I ZA FUNKCIJU

ONO STO KONKRETNO RANIJE NISAM REKAO JESTE DA SE **TYPE PARAMTER, NE MORA SAMO KORISTITI U OBIMU FUNKCIJE, VEC I U NJENOM SIGNATURE-U, ODNSONO TAJ TYPE PARAMETAR IL IGENERIC TYPE, MOGU KORISTITI TYPE ANNNOTATIONI ARGUMENATA FUNKCIJE, IL ITYPE ANNOTATION ZA POVRATN UVREDNOST FUNKCIJE**

EVO PRIMERA

```typescript
function resolvujIliTimeoutuj<T>(promise: Promise<T>, seconds: number): Promise<T> {

    // PRVI PARAMETAR MORA BITI PROMISE KOJI JE RESOLVED SA
    // VREDNOSCU KOJA JE TYPE-A     T


    return new Promise((res, rej) => {

        // POVRATNA VREDNSOT FUNKCIJE TREBA DA BUDE PROMISE

        // AKO SE OVAJ PROMISE NE RESOLVE-UJE NE VREME
        // BICE ASINHRONO REJECTED

        // AKO JE REJECTED NECE VISE BITI BITAN TIPE ANNOTATION ZA POVRATNU VREDNOST

        let timerID = window.setTimeout(() => {
            rej("time's out");
        }, seconds)

        promise.then(val => {
            window.clearTimeout(timerID);

            // AKO SE RESOLVE-UJE, MORA SE RESOLVE-OVATI SA VREDNOSCU
            // KOJA JE TYPE ZADATOG KROZ GENERIC        T

            // POSTO SE U FUNKCIJU PROSLEDJUJE PROMISE RESOLVED SA      T
            // SA ISTOM VREDNOSCU SAM RESOLVEOVAO I PROMISE KOJI JE POVRATNA VREDNSOT

            // A TA VREDNSOT JE TYPE-A      T

            res(val)
        })


    })

}

// OVO NIJE SPORNO


// POGLEDAJ OVO
resolvujIliTimeoutuj(window.fetch(''), 2000);

// ps. KADA POZIVAS fetch, PROMISE SE RESAVA SA Response-OM
// TO MOZES VIDETI I HOVERING-OM

//  I OVO JE BAS SLUCAJ KADA NISAM PROSLEDIO TYPE PARAMETAR

// ON JE DAKLE INFERED DA BUDE TYPE-A Response

// I UPRAVO TO MOGU VIDETI HOVERINGOM

// OVO BI ONDA IZAZVAL OERROR

resolvujIliTimeoutuj<string>(window.fetch(''), 2000)        // !        ERROR
                                                            // !     fetch POZIV CE BITI PODVUCEN JE JE POGRESNOG TYPE-A
                                                            // !            RESOLVED JE SA Response A NE SA string-OM
```

