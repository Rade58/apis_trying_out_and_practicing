# DECLARATION MERGING

OVO JE JEDAN VARY VARY IMPORTANT SECTION, U POGLEDUM FORMIRANJA PRAVOG MENTALNOG MODELA, KAKO TYPESCRIPT FUNKCIONISE

OVAJ NASLOV JE POJEDNOSTAVLJEN, A ONO USTVARI STA JA ZELIM DA IZVUCEM I OVOGA, JESTE SAZNANJE KAKO TO TYPESCRIPT, ODNOSNO VS CODE FORMIRA TOOLTIPS U KOJIM MI POKAZUJE STA JE DOZVOLJENO, A STA NIJE; I KOJE MI POMAZU DA SAZNAM KADA JE NEKA STVAR VALUE, A KADA JE U PITANJU TYPE

UZ TO, OVO NAM POMAŽE DA SHVATIMO KAKO MOŽEMO STAVITI MALE ISPRAVKE NA VRH BIBLIOTEKA ILI INFORMACIJE O NESAVRŠENIM TIPOVIMA, ILI MOŽDA ŽELITE DA PROTOTIPIRATE NEŠTO, A TIPOVI ZA TO JOŠ NE POSTOJE. OVO VAM POMAŽE DA POVEĆATE NEKE OD POSTOJEĆIH INFORMACIJA O TIPU U VAŠOJ APLIKACIJI

**U NAREDNO MDELU CU SE DOTACI I *namespace*-OVA (SA NJIMA SE PRVI PUT SUSRECE, ALI BICE MI ODMAH JASNO CEMU SLUZE)**

**MIKE NORTH KAZE DA SU ONI LES AND LESS POPULAR, I DA NISU VREDNI DA BIH IH POSEBNO COVER-OVAO, ODNOSNO NE TREBAM SE BAVITI NJIMA POSEBNO, A OVDE CES VIDETI STA ONI PREDSTAVLJAJU**

## :one: IDETIFIERS

NA PRIMER, TO SU: *VARIJABLA*, *KLASA*, *FUNKCIJA*, *INTERFACE*

**O NJIMA MOGU RAZMISLJATI KAO *STVARIMA KOJE MOGU EXPORT-OVATI***

**INTERNALY TYPESCRIPT IDETIFIKATORE USTVARI NAZIVA *`SYMBOLS`***

```typescript
function foo(){}

interface Bar {}

namespace baz {

    let priv = "nesto"

    export const blah = priv + "drugacije";

}


//////////////// SVE OVE GORNJE STVARI SU IMPORTABLE I EXPORTABLE

export {foo, Bar, baz}

```

IDENTIFIKATORI MOGU BITI ASSOCIATED SA TRI STVARI:

- VALUE

- TYPE

- NAMESPACE

**NAMESPACE JE ABSTRAKCIJA, ALI U SUSTINI ON JE OBJEKAT KOJI IMA TYPE I IMA VALUE**

```typescript
//  U SLUCAJU GORNJEG namespace-A, MOZES RADITI SLEDECE

baz.blah       // PRISTUPIO SI VARIJABLI TOG NAMESPACE-A (ALI SAMO AKO SE KORISTIO export NA NJOJ)

// DAKLE NAMESPACE JE USTVARI KOLEKCIJA STVARI, ALL MERGED TOGETHER

baz.priv    // **  error  (ZATO STO NIJE KORISCENO SA export)
```

### JA USTVARI MOGU TESTIRATI DA LI JE NESTO VALUE, DALI JE NESTO TYPE, I DA LI JE NESTO NAMESPACE

- AKO MOZE DA BUDE ASSIGNED, ONDA JE TO VALUE, JER AKO NIJE VALUE TYPESCRIPT CE TO PODVUCI I RECI DA JE ERROR

```typescript
const x = foo
```

- DA POSTAVIM TO NA TEST POZICIJU (SINTAKSA SA *COLON*), I ISTO TAKO AKO NIJE TYPE, TYPESCRIPT WILL 'YELL AT ME'

```typescript
const y: Bar = {}
```

- DA PROVERIM DA LI JE NESTO NAMESPACE, HOVERUJEM PREKO NJEGA; DAKLE MORAM SE POUZDATI SAMO U TOOLTIPS

## :two: FUNKCIJE I VARIAJBLE, DAKLE PURELY JESU VALUES

KAO STO ZNAS, *NJIHOVI TYPE-OVI MOGU BITI EXTRACTED, KORISCENJEM SAMO [TYPE QUERIES](https://github.com/Rade58/apis_trying_out_and_practicing/blob/master/TYPESCRIPT/BELESKE/g%29%20ADVANCED%20TYPE-OVI/3.%20TYPE%20QUERIES.md#type-queries)*

```typescript
const blahA = 48;

let fortyEight: typeof blahA;
```

## :three: INTERFACE-OVI SU PURELY, SAMO TYPES

```typescript
//  NEMA ASSIGNMENTA

interface Foo {

}

let foo = Foo;      // !!!! VALUE TEST FAILED

```

## :four: KLASE SU OBOJE, I TYPE-OVI I VALUE-OVI

**ONE CE DAKLE PASS, I VALUE I TYPE TEST-OVE**

```typescript
class Kontaktiranje {

    name: string

    static blah = "foobarbaz"

}

let KlasaKontakt = Kontaktiranje;       // PROSLA VALUE TEST

Kontaktiranje.blah      // SAMO SE PODSECAM DA POSTOJI I static (JAVASCRIPT-OV FEATURE)

let KontaktKlasa: Kontaktiranje = new Kontaktiranje();      // PROSLA I TYPE TEST
```

EVO STA SE DESAVA:

SA JEDNE STRANE KLASA JESTE FACTORY, KOJI PRODUCE-UJE INSTANCE (IMA KONSTRUKTOR, IMA PROTOTYPE)

**A KORISCENJE KLASE KAO TYPE-A, DESCRIBE-UJE INSTANCES THEMSELF**

>>>> SKORO DA SE KORISTITI, POPUT NEKOG INTERFACE ZA INSTANCU

## :five: KADA DEKLARACIJE IMAJU ISTA IMENA; ONE SE ODPRILIKE STACK-UJU UP ON EACHOTHER

DAKLE JA U TYPESCRIPT-U, NEMAM TAKVU SITUACIJU DA SE VALUES COLIDE WITH THE VALUES

I AKO STVARI ARENGE-UJEM NA PRAVI NACIN, MOGU NAPRAVITI NESTO POPUT OVOGA

```typescript
class AudioPloca {

    record_lable: AudioPloca = new AudioPloca() 

}

namespace AudioPloca {

    export class AudioPloca {}

}

interface AudioPloca {
    muzicar: string
}
```

MOGU SADA SVE OVO DA ISTETIRAM SA VALUE, TYPE I NAMESPACE TESTOVIMA

```typescript
let audioObjekat: AudioPloca = {muzicar: "Hasim Hucuk Hoki", record_lable: new AudioPloca()  }   
                    // ETO GA PRIMER TOG STACKINGA
                    // MORAO SAM ZADATI I PROPERTI KLASE I PROPERTI INTERFACE-A
                                                                // TYPE TEST PROSAO
                                                                // (KORISCENO KAO INTERFACE)

let AudioInstance: AudioPloca = new AudioPloca()            // TYPE TEST PROSAO
                                                            // (KORISCENO KAO INTERFACE)

const AudioKlasa = AudioPloca                   // VALUE TEST PROSAO
                                                // ASSIGN-OVAO SAM KLASU

// A KADA NAPISEM SLEDECE
export {AudioPloca}
// SVA TRI IDENTIFIKATORA SU EXPORTOVANI

// HOVER-UJ I VIDECES DA JE SVE IZVEZENO

// DAKLE SVE TRI IDENTIFIERA, SU STACKED NA ISTOM * SYMBOLU * I TAKO SU IZVEZENI

// NE SMEM DA ZANEMARUJEM INFORMACIJE U TOOLTIP-U, JER MI ONE **  GOVORE MNOGO  **

```

*MISLI MDA JE OVO VAZNO STO AUTOR TUTORIJALA KAZEM*

- AKO JE NE KO U NEKOM LIBRARY-JU ZABORAVIO NESTO, JA USTVARI MOGU THROW-OVATI INTERFACE TU, I ON CE SE STACKOVATI

BAS KAO STO SI VIDEO GORE NA PRIMERU KLASE I INTERFACE-A

SVE BI SE TO APPLY-OVALO GLOBALNO KROZ CEO MOJ APP (POSTOJI JEDAN SCOPE U KOJEM SU TYPE INFORMATION HELD) (HOLISTICLY ALL THROUGH THE APP)

## :six: NAMESPACE-OVI, IMAJU SVOJ SOPSTVENI *SLOT*; I NAMESPACE-OVI SU VALUES

**ONI SE CAK MOGU MERGE-OVATI SA KLASAMA**

```typescript
class Kontaktiranje {

    name: string

    static blah = "foobarbaz"

}



class Adresar {
    kontakti!: Kontaktiranje[]
}

namespace Adresar {

    export class OtherKontaktiranje extends Kontaktiranje {}        // UNUTRASNJA KALSA

}

// POGLEDAJ OVO (MALO KOMPLIKOVANO ALI MOGU DA SAGLEDAM STA JE STA)

let adresar1: Adresar = new Adresar()

adresar1.kontakti.push(new Adresar.OtherKontaktiranje())

```

**A TAKODJE NAMESPACE-OVI SE MOGU MERGE-OVATI I SA FUNKCIJAMA**

```typescript
function dajNovci(par: number){

    return `${dajNovci.valuta}${par.toFixed(2)}`
}

namespace dajNovci {

    export const valuta: string = "$ " 

}


dajNovci(48.468);       // -->  $ 48.46

dajNovci.valuta         // -->  $

```

>>>> OVO JE SVE DOZVOLJENO JER NAMESPACE USTVARI SLUZI DA TACK THINGS ON ITSELF

## SUMIRANJE

ŠTO SE TIČE STVARI KOJE TREBAS DA PONESES IZ MENTAL MODEL PERSPEKTIVE, JESTE KNOWING KOJI JE TIP I KNOWING KOJA JE VREDNOST (A TO MOGU PROVERAVATI TESTOVIMA)

THAT WILL TAKE YOU A LONG WAY

> I ZNAJUĆI ŠTA SE MOGU PROŠIRITI SUČELJA NASUPROT TOME ŠTO ZNATE ŠTA MORATE OSTAVITI NA MIRU, KAD SU DEFINISANI U TIPOVIMA, VREDNOSTIMA.
 
DAKLE, JEDNOM KADA IMATE VREDNOST, NE MOZES JE OVERWRITE-OVATI JER BI TO BILO U SUKOBU SA NAČINOM NA KOJI SE PONAŠA JAVASCRIPT, A INTERFACE-EVI SU FAIR GAME POVODO MTOGA