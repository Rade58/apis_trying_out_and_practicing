# CONDITIONAL TYPES (SINTAKSA KORISTI I infer KEYWORD)

******

DA ODMAH KAZEM DA JE DOBRO DA SE PROSTUDIRA [SLEDECI CLANAK](https://mariusschulz.com/blog/conditional-types-in-typescript), U KOJEM SU DETALJNO OBJASNJENI CONDITIONAL TYPES (A TREBAO BIH PROCITATI SVAKI CLANAK, KOJI SE TICE TypeScript-A, SA POMENUTE STRANICE)

******

ZELIM DA NAPOMENEM VAZNU STVAR NA POCETKU A TICE SE TERMINA **INFER**, JER *MOGUCE JE DA SAM TAJ TERMIN SHVATAO POGRESNO* (NA KRAJU SE ISPOSTAVIL ODA NISAM, ALI DA OSAM OVDE USTVARI PREVOD TOG TERMINA)

**STA USTVARI TAJ TERMIN, [INFERENCE, ONDONSO INFER](https://www.typescriptlang.org/docs/handbook/type-inference.html), USTVARI PREDSTAVLJA**

>>>> изводити закључак (infer, deduce)

ILI

>>>> закључити (infer, close, take out, sign, induce, conclude)

******

DA SE SADA VRATIM NA CONDITIONAL TYPES

CONDITIONAL TYPES SU, ODNEDAVNO DODATI (2018)

KORISTE SE SAMO SA GENERICS-IMA

ONO STO PRVENSTVENO OVAKAVA SINTAKSA UPOTREBLJAVA JESTE *TERNARY OPERATOR*

A ONO STA SE USTVARI RADI SA *CONDITINAL TYPES*, MOZE SE OBJASNITI, KAO SLEDECE:

>>>> EXTRACTION TYPE PARAMETARA, KORISCENJEM **infer**

PRVO JEDNA DIGRESIJA, ZA KUJU MISLIM DA JE VAZNA

******

```typescript
// POZNATO TI JE DA JE MOGUCE KORISCENJE GENERICSA SA FUNKCIJAMA, I SA INTERFACE-OVIMA
// **** ALI ONO JE MOGUCE I SA KORISCENJEM TYPE ALIASA

type nekiAlias<T> = {
    nesto: T;
}

```

******

## :one: JA CU SADA DA KREIRAM, JEDAN JEDNOSTAVNIJI PRIMER, GDE *NECU KORISTITI infer KEYWORD*, A ONO STO CU KORISTITI JESTE **extends CLAUSE (KLAUZULA)** *(OBRATI PAZNJU DA OVDE NIRE REC O DEFINISANJU EXTENDING-A, IZMEDJU TYPE-OVA, VEC O USLOVNOJ IZJAVI)*

U SUSTINI PRE BILO CEGA ZELI MDA KAZEM DA SE CONDITIONAL TYPE KORISTI SAMO SA GENERICSIMA,  IDA SE TU MORA KORISTITI TERNARY

```typescript
//  POSMATRAJ STA TO STVARNO EXTEND-UJE TYPE PARAMETAR   T U SLEDECOJ DEFINICIJI, I GDE SE TAJ
//  exdends KEYWORD USTVARI KORISTI

//  ODNOSNO POSMATRAJ ONAJ DEO TERNARY-JA, KOJI PREDSTAVLAJ USLOV

//                  NAIME extends IZJAVA U OVOM SLUCAJU PREDSTAVLJA USLOV

// **       SAZNAO SAM DA TAJ USLOV NAZIVAJU I              ****    EXTENDS KLAUZULA    *****

//                  USTVARI AKO JEDAN INTERFACE ZAISTA EXTEN-UJE DRUGI, TAJ USLOV CE BITI EVALUATED KAO true
//                  U SUPROTNOM BICE false

type nekiAlias<T, S> = T extends S?  T   :   string;

//  A U ODNOSU NA USLOV     KONACNA VREDNOST TYPE ALIAS-A, MOZE BITI
// *    - ONO STO JE PROSLEDJENO ZA TYPE PARAMETAR          T
// *    - ILI MOZE BITI                                 string
//  JER SAM JA TAKO ZDAO


// **********************************************************************
// HAJDE DA IPAK NESTO TESTIRAM

interface Prasuma {
    ime: string;
}

interface Tundra {
    ime: string;
    habitable: boolean;
}

// 'GOLIM OKOM' SE MOZE VIDETI DA JE Tundra OVRLAPPED BY Prasuma
// ISTO TAKO PO IZGLEDU INTERFACE TACNIJE MOGU RECI DA Prasuma 'EXTENDUJE' Tundru

//      JA SEBI POSTAVLJAM PITANJE DA LI JE NESTO OVAKO NESTO MOGUCE?

//          type pokusajBooleanTypea = Tundra extends Prasuma;      // !!!!  ---->      ERROR (POMENUTO, ZAISTA//
                                                                                                // NIJE MOGUCE)

//       JA SEBI POSTAVLJAM, JOS JEDNO PITANJE: DA LI JE ONAD OVAKO NESTO MOGUCE?

//          type booleanType<T, U> = T extends U;               // ---->        ERROR

// DAKLE GORE POMENUTA DVA DEFINISANA type ALIAS-A, NISU DOBRA, I TYPESCRIPT JE PODVUKAO TU SINTAKSU
// I ONA NE PRODUCE-UJE NISTA

// ************     DAKLE **MORA SE KORISTITI TENARY**, DA BIH POSTIGAO TAKVU 'SITUACIJU'
// **************       DA SE TYPE-POVI, TAKORECI ANNOTATE-UJU CONDITIONALY, ODNOSNO USLOVNO

let blahVarijabla: nekiAlias<Tundra, Prasuma>;  

// AKO HOVER-UJEM PREKO GORNJE VARIJABLE VIDECU DA JE ONA       Tundra              TYPE-A

```

IZ PREDHODNOG PRIMERA JE JASNO KAKO FUNKCIONISE TERNARY, ALI JOS NISAM POKAZAO KAKO FUNKCIONISE infer KEYWORD

## :two: **infer** KEYWORD

HAJDE DA KAZEM DA BI PRE SVEGA, DOBRO BILO DA [PROCITAM OVO](https://mariusschulz.com/blog/conditional-types-in-typescript#type-inference-in-conditional-types)

I JA CU ZAISTA KORISTITI PRIMER IZ PREDHODNOG CLANKA, ALI HAJDE DA KAZEM SLEDECE

- ***infer* SE KORISTI U extends KLAUZULI**

- ***infer* SLUZI DA SE *EXTRACT*-UJE NEKI *INFERED* TYPE, KOJI PREDSTAVLJA `GRADIVNI ILI PARCIJALNI TYPE`(MOJI IZRAZI) NEKOG DRUGOG TYPE-A**

VIDECU SVE OVO PREKO JEDNOG PRIMER-A

```typescript
// OVAJ PRIMER JE ZAISTA DIVAN

type FirstInsider<T> = T extends [infer S, number]? S : undefined;

// INTERPRETIRACU, GORNJI CONDITIONAL

//    **      T       TREBA DA BUDE   *TUPLE OD DVA CLANA*

//    **      DRUGI CLAN JE number TYPE-A

//    **      PRVI CLAN JE **INFERED TYPE-A**

// A STA TO ZNACI **INFERED TYPE-A**

//          TO ZNACI DA CE      S-U         BITI PROSLEDJENO STA GOD SAM PROSLEDIO PRI KORISCENJU
//                                          POMENUTOG FirstInsider<T> TYPE, PRI KREIRANJU NOVOG TYPE-A

// GLEDAJ OVAJ TYPE, E ON JE VALIDAN TYPE DA BUDE ARGUMENT
// ODNOSNO DA BUDE PROSLEDJEN KAO       T       PRI KORISCENJU  FirstInsider<T>
type TupleType = [string, number];

// OVDE SAM GA PROSLEDIO
let firstInsiderFromTuple1: FirstInsider<TupleType>;
// SADA KADA HOVER-UJEM PREKO GORNJE VARIJABLE, TYPESCRIPT CE MI RECIDA JE U PITANJU        string


// A MOGAO SAM URADITI I OVO (PROSTO VEZBAM)

let nekiTuple: [number, number] = [48, 156];

let firstInsiderFromTuple2: FirstInsider<typeof nekiTuple>
// KADA HOVER-UJEM PREKO GORNJE VARIJABLE VIDECU DA JE ONA      number      TYPE-A


// MISLIM DA SAM DOVOLJNO OBJASNIO POMENUTO
```

JOS IDALJE OSTAJE PODSETNIKA DA SE POZABAVIM [CELIM OVIM CLANKOM](https://mariusschulz.com/blog/conditional-types-in-typescript)

ALI ONO STA MOGU IZVUCI DA JE VAZNO IZ NJEGA A TICE SE infer, JESTE SLEDECE

**INFERING TYPE-A POVRATNE VREDNOSTI, NEKOG FUNCTION TYPE-A**

USTVARI MOGU DA IDEM TOLIKO DALEKO DA KORISTIM *INFERENCE, SAMO DELA TYPE-A, POVRATNE VREDNOSTI*, STO CU SADA I DEFINISATI

```typescript
type returnedFirst<T> = T extends (param: number) => [infer S, ...unknown[]]?
    S
    :
    never

// I AKO MISLIM DA JE SUVISNO OBJASNJAVATI, IPAK CU RECI

// PROSLEDJENO      T-u     MORA DA BUDE FUNCTION TYPE, CIJA JE TYPE POVRATNE VREDNSTI, USTVARI ARRAY

// TYPE PRVOG CLANA ARRAY-A, JESTE       **     INFERED    S    **

//   MOGU OVO I DA TESTIRAM

// EVO JEDNE FUNKCIJE, CIJA JE POVRATNE VREDNOST NIZ

function specialBlahFunkcija(arg: string): [{telefon: number}, ...unknown[]]{

    return [{telefon: 567675668}, "blah", 456565, arg, "trah"]

}

// JA ZELIM DA GETT-UJEM TYPE, PRVOG CLANA IZ NJENOG RETURN ARRAY-A 

// UPOTREBICU MOJ, type ALIAS, KOJI SAM KREIRAO I, U KOJEM SAM KORISTIO infer KEYWORD  

type firtMemeberType = returnedFirst<typeof specialBlahFunkcija>

// *******  SADA KADA HOVER-UJES PREKO GORNJEG TYPE ALIAS-A, VIDECES DA ON HOLD-UJE SLEDECI
// *******  TYPE :       {telefon: number}
```

### ZA KRAJ CU PRIKAZATI I ONAJ CONDITIONAL TYPE, KOJI JE DEFINISAO AUTOR WORKSHOPA-A

```typescript

type promiseResovementType<T> = T extends Promise<infer S> ? S: T;

// KAKAV CE BITI FORMIRAN TYPE, KORISCENJEM OVOG CONDITIONAL-A
// MOGU ZAKLJUCITI SLEDECE:

//          -      AKO JE ONO STO SE PROSLEDI KROZ      T        USTVARI **JESTE** SLEDECI TYPE:      
//                 Promise<>, A IZMEDJU <>, TO MOZE BITI BILO KOJI TYPE ()
//                 , NA KRAJU CE TVOJ OUTPUTED TYPE BITI BAS ONAJ TYPE IZMEDJU <>
//
//          -      AKO      T        **NIJE**    Promise<..> TYPE-A, ONDA CE BILO STA STO JE
//                 PROSLEDJENO    T-u      BITI OUTPUTED TYPE

// EVO DA TO I TESTIRAM:

let resolvedProm = Promise.resolve(["Alpaka", "Gvanaka"]);      // CISTO NAPOMINJEM DA JE OVAKAV Promise INFERELY TYPED SA Promise<string[]>

const someValue = "lama";       // CISTO NAPOMINJEM DA SDE KONSTANTE INFERELY TYPE-UJU SA ASSIGNED VREDNOSCU

type toBePromiseTypeOrSomeOtherType1 = promiseResovementType<typeof resolvedProm>;

// AKO HOVERUJEM PREKO GORNJEG ALIAS-A, MOGU VIDETI DA JE NJEGOVA VREDNOST      string[]

type toBePromiseTypeOrSomeOtherType2 = promiseResovementType<typeof someValue>;

// AKO HOVERUJEM PREKO GORNJEG ALIAS-A, MOGU VIDETI DA JE NJEGOVA VREDNOST      "lama"

```
