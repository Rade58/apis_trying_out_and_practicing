# CONDITIONAL TYPES (SINTAKSA KORISTI I infer KEYWORD)

******

ZELIM DA NAPOMENEM VAZNU STVAR NA POCETKU A TICE SE TERMINA **INFER**, JER *MOGUCE JE DA SAM TAJ TERMIN SHVATAO POGRESNO*

**STA USTVARI TAJ TERMIN, [INFERENCE, ONDONSO INFER](https://www.typescriptlang.org/docs/handbook/type-inference.html), USTVARI PREDSTAVLJA**

>>>> изводити закључак (infer, deduce)

ILI

>>>> закључити (infer, close, take out, sign, induce, conclude)

******

DA SE SADA VRATIM NA CONDITIONAL TYPES

CONDITIONAL TYPES SU, ODNEDAVNO DODATI (2019)

KORISTE SE SAMO SA GENERICS-IMA

ONO STO PRVENSTVENO OVAKAVA SINTAKSA UPOTREBLJAVA JESTE *TERNARY OPERATOR*

A ONO STA SE USTVARI RADI SA *CONDITINAL TYPES*, MOZE SE OBJASNITI, KAO SLEDECE:

>>>> EXTRACTION TYPE PARAMETARA, KORISCENJEM **infer**

PRVO JEDNA DIGRESIJA, ZA KUJU MISLIM DA JE VAZNA

******

```typescript
// POZNATO TI JE DA JE MOGUCE KORISCENJE GENERICSA SA FUNKCIJAMA, I SA INTERFACE-OVIMA
// **** ALO INO JE MOGUCE I SA KORISCENJEM TYPE ALIASA

type nekiAlias<T> = {
    nesto: T;
}

```

******

## :one: JA CU SADA DA KREIRAM, JEDAN JEDNOSTAVNIJI PRIMER, GDE NECU KORISTITI infer KEYWORD, A KASNIJE CU ODRADITI NESTO STO JE KOMPLIKOVANIJE

```typescript
//  POSMATRAJ STA TO STVARNO EXTEND-UJE TYPE PARAMETAR   T

//  ODNOSNO POSMATRAJ ONAJ DEO TERNARY-JA, KOJI PREDSTAVLAJ USLOV

//                  NAIME extends IZJAVA U OVOM SLUCAJU PREDSTAVLJA USLOV

//                  USTVARI AKO JEDAN INTERFACE ZAISTA EXTEN-UJE DRUGI, TAJ USLOV CE BITI EVALUATED KAO true
//                  U SUPROTNOM BICE false

type nekiAlias<T, S> = T extends S?  T   :   string;

//  A U ODNOSU NA USLOV     KONACNA VREDNOST TYPE ALIAS-A, MOZE BITI        ONO STO JE PROSLEDJENO KAO TYPE 
//  PARAMETER,      ILI MOZE BITI       string

```

IZ PREDHODNOG PRIMERA JE JASNO KAKO FUNKCIONISE TERNARY, A SAD DA PROSIRIM MALO PRICU

## :two: **infer** KEYWORD 

```typescript

```