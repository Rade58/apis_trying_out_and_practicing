# CONDITIONAL TYPES (SINTAKSA KORISTI I infer KEYWORD)

******

DA ODMAH KAZEM DA JE DOBRO DA SE PROSTUDIRA [SLEDECI CLANAK](https://mariusschulz.com/blog/conditional-types-in-typescript), U KOJEM SU DETALJNO OBJASNJENI CONDITIONAL TYPES (A TREBAO BIH PROCITATI SVAKI CLANAK, KOJI SE TICE TypeScript-A, SA POMENUTE STRANICE)

******

ZELIM DA NAPOMENEM VAZNU STVAR NA POCETKU A TICE SE TERMINA **INFER**, JER *MOGUCE JE DA SAM TAJ TERMIN SHVATAO POGRESNO*

**STA USTVARI TAJ TERMIN, [INFERENCE, ONDONSO INFER](https://www.typescriptlang.org/docs/handbook/type-inference.html), USTVARI PREDSTAVLJA**

>>>> изводити закључак (infer, deduce)

ILI

>>>> закључити (infer, close, take out, sign, induce, conclude)

******

DA SE SADA VRATIM NA CONDITIONAL TYPES

CONDITIONAL TYPES SU, ODNEDAVNO DODATI (2019)

KORISTE SE SAMO SA GENERICS-IMA

ONO STO PRVENSTVENO OVAKAVA SINTAKSA UPOTREBLJAVA JESTE *TERNARY OPERATOR*

A ONO STA SE USTVARI RADI SA *CONDITINAL TYPES*, MOZE SE OBJASNITI, KAO SLEDECE:

>>>> EXTRACTION TYPE PARAMETARA, KORISCENJEM **infer**

PRVO JEDNA DIGRESIJA, ZA KUJU MISLIM DA JE VAZNA

******

```typescript
// POZNATO TI JE DA JE MOGUCE KORISCENJE GENERICSA SA FUNKCIJAMA, I SA INTERFACE-OVIMA
// **** ALO INO JE MOGUCE I SA KORISCENJEM TYPE ALIASA

type nekiAlias<T> = {
    nesto: T;
}

```

******

## :one: JA CU SADA DA KREIRAM, JEDAN JEDNOSTAVNIJI PRIMER, GDE *NECU KORISTITI infer KEYWORD*, A ONO STO CU KORISTITI JESTE **extends CLAUSE (KLAUZULA)** *(OBRATI PAZNJU DA OVDE NIRE REC O DEFINISANJU EXTENDING-A, IZMEDJU TYPE-OVA, VEC O USLOVNOJ IZJAVI)*

U SUSTINI PRE BILO CEGA ZELI MDA KAZEM DA SE CONDITIONAL TYPE KORISTI SAMO SA GENERICSIMA,  IDA SE TU MORA KORISTITI TERNARY

```typescript
//  POSMATRAJ STA TO STVARNO EXTEND-UJE TYPE PARAMETAR   T U SLEDECOJ DEFINICIJI, I GDE SE TAJ
//  exdends KEYWORD USTVARI KORISTI

//  ODNOSNO POSMATRAJ ONAJ DEO TERNARY-JA, KOJI PREDSTAVLAJ USLOV

//                  NAIME extends IZJAVA U OVOM SLUCAJU PREDSTAVLJA USLOV

// **       SAZNAO SAM DA TAJ USLOV NAZIVAJU I              ****    EXTENDS KLAUZULA    *****

//                  USTVARI AKO JEDAN INTERFACE ZAISTA EXTEN-UJE DRUGI, TAJ USLOV CE BITI EVALUATED KAO true
//                  U SUPROTNOM BICE false

type nekiAlias<T, S> = T extends S?  T   :   string;

//  A U ODNOSU NA USLOV     KONACNA VREDNOST TYPE ALIAS-A, MOZE BITI
// *    - ONO STO JE PROSLEDJENO ZA TYPE PARAMETAR          T
// *    - ILI MOZE BITI                                 string
//  JER SAM JA TAKO ZDAO


// **********************************************************************
// HAJDE DA IPAK NESTO TESTIRAM

interface Prasuma {
    ime: string;
}

interface Tundra {
    ime: string;
    habitable: boolean;
}

// 'GOLIM OKOM' SE MOZE VIDETI DA JE Tundra OVRLAPPED BY Prasuma
// ISTO TAKO PO IZGLEDU INTERFACE TACNIJE MOGU RECI DA Prasuma 'EXTENDUJE' Tundru

//      JA SEBI POSTAVLJAM PITANJE DA LI JE NESTO OVAKO NESTO MOGUCE?

//          type pokusajBooleanTypea = Tundra extends Prasuma;      // !!!!  ---->      ERROR (POMENUTO, ZAISTA//
                                                                                                // NIJE MOGUCE)

//       JA SEBI POSTAVLJAM, JOS JEDNO PITANJE: DA LI JE ONAD OVAKO NESTO MOGUCE?

//          type booleanType<T, U> = T extends U;               // ---->        ERROR

// DAKLE GORE POMENUTA DVA DEFINISANA type ALIAS-A, NISU DOBRA, I TYPESCRIPT JE PODVUKAO TU SINTAKSU
// I ONA NE PRODUCE-UJE NISTA

// ************     DAKLE **MORA SE KORISTITI TENARY**, DA BIH POSTIGAO TAKVU 'SITUACIJU'
// **************       DA SE TYPE-POVI, TAKORECI ANNOTATE-UJU CONDITIONALY, ODNOSNO USLOVNO

let blahVarijabla: nekiAlias<Tundra, Prasuma>;  

// AKO HOVER-UJEM PREKO GORNJE VARIJABLE VIDECU DA JE ONA       Tundra              TYPE-A

```

IZ PREDHODNOG PRIMERA JE JASNO KAKO FUNKCIONISE TERNARY, ALI JOS NISAM POKAZAO KAKO FUNKCIONISE infer KEYWORD

## :two: **infer** KEYWORD

HAJDE DA KAZEM DA BI PRE SVEGA, DOBRO BILO DA [PROCITAM OVO](https://mariusschulz.com/blog/conditional-types-in-typescript#type-inference-in-conditional-types)

I JA CU ZAISTA KORISTITI PRIMER IZ PREDHODNOG CLANKA, ALI HAJDE DA KAZEM SLEDECE

- ***infer* SE KORISTI U extends KLAUZULI**

- ***infer* SLUZI DA SE *EXTRACT*-UJE NEKI *INFERED* TYPE, KOJI PREDSTAVLJA `GRADIVNI ILI PARCIJALNI TYPE`(MOJI IZRAZI) NEKOG DRUGOG TYPE-A**

VIDECU SVE OVO PREKO JEDNOG PRIMER-A

```typescript

```
